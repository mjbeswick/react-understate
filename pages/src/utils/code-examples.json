{
  "actionAsync": "import React from 'react';\nimport { state, action, useUnderstate } from 'react-understate';\n\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n};\n\nconst users = state<User[]>([]);\nconst isLoading = state(false);\nconst error = state<string | null>(null);\n\n// Async action to fetch users\nconst fetchUsers = action(async () => {\n  isLoading.value = true;\n  error.value = null;\n\n  try {\n    const response = await fetch('/api/users');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const fetchedUsers = await response.json();\n    users.value = fetchedUsers;\n  } catch (err) {\n    error.value = err instanceof Error ? err.message : 'Failed to fetch users';\n  } finally {\n    isLoading.value = false;\n  }\n}, 'fetchUsers');\n\n// Async action to create a new user\nconst createUser = action(async (userData: Omit<User, 'id'>) => {\n  isLoading.value = true;\n  error.value = null;\n\n  try {\n    const response = await fetch('/api/users', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(userData),\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to create user');\n    }\n\n    const newUser = await response.json();\n    users.value = [...users.value, newUser];\n  } catch (err) {\n    error.value = err instanceof Error ? err.message : 'Failed to create user';\n  } finally {\n    isLoading.value = false;\n  }\n}, 'createUser');\n\n// Async action to update a user\nconst updateUser = action(async (id: number, updates: Partial<User>) => {\n  try {\n    const response = await fetch(`/api/users/${id}`, {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(updates),\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to update user');\n    }\n\n    const updatedUser = await response.json();\n    users.value = users.value.map(user =>\n      user.id === id ? updatedUser : user,\n    );\n  } catch (err) {\n    error.value = err instanceof Error ? err.message : 'Failed to update user';\n  }\n}, 'updateUser');\n\nfunction UserManager() {\n  const {\n    users: userList,\n    isLoading: loading,\n    error: err,\n  } = useUnderstate({\n    users,\n    isLoading,\n    error,\n  });\n\n  React.useEffect(() => {\n    fetchUsers(); // Load users on mount\n  }, []);\n\n  const handleCreateUser = () => {\n    createUser({\n      name: 'New User',\n      email: 'new@example.com',\n    });\n  };\n\n  return (\n    <div>\n      <h2>User Manager</h2>\n\n      {loading && <p>Loading...</p>}\n      {err && <p style={{ color: 'red' }}>Error: {err}</p>}\n\n      <button onClick={handleCreateUser} disabled={loading}>\n        Create User\n      </button>\n\n      <button onClick={fetchUsers} disabled={loading}>\n        Refresh\n      </button>\n\n      <ul>\n        {userList.map(user => (\n          <li key={user.id}>\n            {user.name} ({user.email})\n            <button\n              onClick={() =>\n                updateUser(user.id, { name: user.name + ' Updated' })\n              }\n              disabled={loading}\n            >\n              Update\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n",
  "actionBasicUsage": "import { state, action, useUnderstate } from 'react-understate';\n\nconst count = state(0);\n\n// Create named actions for state modifications\nconst increment = action(() => {\n  count.value++;\n}, 'increment');\n\nconst decrement = action(() => {\n  count.value--;\n}, 'decrement');\n\nconst reset = action(() => {\n  count.value = 0;\n}, 'reset');\n\n// Action with parameters\nconst setCount = action((newValue: number) => {\n  count.value = newValue;\n}, 'setCount');\n\nconst addAmount = action((amount: number) => {\n  count.value += amount;\n}, 'addAmount');\n\nfunction Counter() {\n  const [currentCount] = useUnderstate(count);\n\n  return (\n    <div>\n      <h2>Count: {currentCount}</h2>\n      <button onClick={increment}>+1</button>\n      <button onClick={decrement}>-1</button>\n      <button onClick={() => addAmount(5)}>+5</button>\n      <button onClick={() => setCount(100)}>Set to 100</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n",
  "actionBatching": "import { state, action, batch } from 'react-understate';\n\nconst firstName = state('');\nconst lastName = state('');\nconst email = state('');\nconst phone = state('');\n\n// Without batching - triggers 4 re-renders\nconst updateUserUnbatched = action((data: any) => {\n  firstName.value = data.firstName;\n  lastName.value = data.lastName;\n  email.value = data.email;\n  phone.value = data.phone;\n}, 'updateUserUnbatched');\n\n// With batching - triggers only 1 re-render\nconst updateUserBatched = action((data: any) => {\n  batch(() => {\n    firstName.value = data.firstName;\n    lastName.value = data.lastName;\n    email.value = data.email;\n    phone.value = data.phone;\n  });\n}, 'updateUserBatched');\n\n// Complex batched operations\nconst processFormSubmission = action(async (formData: any) => {\n  // Validation and preparation...\n\n  batch(() => {\n    // Update multiple related states atomically\n    firstName.value = formData.firstName.trim();\n    lastName.value = formData.lastName.trim();\n    email.value = formData.email.toLowerCase();\n    phone.value = formData.phone.replace(/\\D/g, '');\n  });\n\n  // Continue with async operations...\n}, 'processFormSubmission');\n",
  "actionComplexState": "import { state, action, useUnderstate } from 'react-understate';\n\ntype Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n  createdAt: Date;\n};\n\nconst todos = state<Todo[]>([]);\nconst newTodoText = state('');\n\n// Actions for todo management\nconst addTodo = action(() => {\n  if (newTodoText.value.trim()) {\n    todos.value = [\n      ...todos.value,\n      {\n        id: Date.now(),\n        text: newTodoText.value.trim(),\n        completed: false,\n        createdAt: new Date(),\n      },\n    ];\n    newTodoText.value = '';\n  }\n}, 'addTodo');\n\nconst toggleTodo = action((id: number) => {\n  todos.value = todos.value.map(todo =>\n    todo.id === id ? { ...todo, completed: !todo.completed } : todo,\n  );\n}, 'toggleTodo');\n\nconst removeTodo = action((id: number) => {\n  todos.value = todos.value.filter(todo => todo.id !== id);\n}, 'removeTodo');\n\nconst clearCompleted = action(() => {\n  todos.value = todos.value.filter(todo => !todo.completed);\n}, 'clearCompleted');\n\nconst updateTodoText = action((id: number, newText: string) => {\n  todos.value = todos.value.map(todo =>\n    todo.id === id ? { ...todo, text: newText } : todo,\n  );\n}, 'updateTodoText');\n\nfunction TodoApp() {\n  const { todos: todoList, newTodoText: newText } = useUnderstate({\n    todos,\n    newTodoText,\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    addTodo();\n  };\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <input\n          value={newText}\n          onChange={e => (newTodoText.value = e.target.value)}\n          placeholder=\"Add new todo...\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n\n      <ul>\n        {todoList.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id)}\n            />\n            <span\n              style={{\n                textDecoration: todo.completed ? 'line-through' : 'none',\n              }}\n            >\n              {todo.text}\n            </span>\n            <button onClick={() => removeTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n\n      {todoList.some(todo => todo.completed) && (\n        <button onClick={clearCompleted}>Clear Completed</button>\n      )}\n    </div>\n  );\n}\n",
  "actionComposition": "import { state, action, batch } from 'react-understate';\n\nconst user = state({ name: '', email: '', preferences: { theme: 'light' } });\nconst isLoading = state(false);\nconst notification = state<string | null>(null);\n\n// Basic actions\nconst setLoading = action((loading: boolean) => {\n  isLoading.value = loading;\n}, 'setLoading');\n\nconst showNotification = action((message: string) => {\n  notification.value = message;\n  setTimeout(() => {\n    notification.value = null;\n  }, 3000);\n}, 'showNotification');\n\nconst updateUserField = action((field: string, value: any) => {\n  user.value = { ...user.value, [field]: value };\n}, 'updateUserField');\n\n// Composed actions\nconst updateProfile = action(async (name: string, email: string) => {\n  setLoading(true);\n\n  try {\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Update multiple fields atomically\n    batch(() => {\n      updateUserField('name', name);\n      updateUserField('email', email);\n    });\n\n    showNotification('Profile updated successfully!');\n  } catch (error) {\n    showNotification('Failed to update profile');\n  } finally {\n    setLoading(false);\n  }\n}, 'updateProfile');\n\nconst resetToDefaults = action(() => {\n  batch(() => {\n    user.value = {\n      name: '',\n      email: '',\n      preferences: { theme: 'light' },\n    };\n    notification.value = null;\n  });\n  showNotification('Reset to defaults');\n}, 'resetToDefaults');\n\n// Complex workflow action\nconst onboardNewUser = action(\n  async (userData: { name: string; email: string }) => {\n    setLoading(true);\n\n    try {\n      // Step 1: Validate data\n      if (!userData.email.includes('@')) {\n        throw new Error('Invalid email address');\n      }\n\n      // Step 2: Update profile\n      await updateProfile(userData.name, userData.email);\n\n      // Step 3: Set default preferences\n      updateUserField('preferences', {\n        theme: 'light',\n        notifications: true,\n        language: 'en',\n      });\n\n      // Step 4: Show welcome message\n      showNotification(`Welcome, ${userData.name}!`);\n\n      // Step 5: Additional setup...\n      console.log('User onboarding completed');\n    } catch (error) {\n      showNotification(error.message);\n      resetToDefaults();\n    } finally {\n      setLoading(false);\n    }\n  },\n  'onboardNewUser',\n);\n",
  "actionDebugging": "import { state, action, configureDebug } from 'react-understate';\n\n// Enable debugging globally\nconfigureDebug({ \n  enabled: true, \n  showFile: true,\n  showTimestamp: true\n});\n\nconst count = state(0, 'counter');\n\n// Actions will be automatically logged with timing\nconst increment = action(() => {\n  console.log('Before increment:', count.value);\n  count.value++;\n  console.log('After increment:', count.value);\n}, 'increment');\n\nconst expensiveOperation = action(async (n: number) => {\n  // Simulate expensive work\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  for (let i = 0; i < n; i++) {\n    count.value = i;\n  }\n}, 'expensiveOperation');\n\n// Manual timing for complex operations\nconst complexAction = action(async () => {\n  const startTime = performance.now();\n  \n  try {\n    await expensiveOperation(100);\n    \n    const endTime = performance.now();\n    console.log(`Complex action completed in ${endTime - startTime}ms`);\n    \n  } catch (error) {\n    console.error('Complex action failed:', error);\n  }\n}, 'complexAction');\n\n// Debug output will show:\n// [increment] Action called\n// [increment] Completed in 0.1ms\n// [expensiveOperation] Action called with args: [100]\n// [expensiveOperation] Completed in 1002.3ms\n",
  "actionErrorHandling": "import { state, action } from 'react-understate';\n\nconst data = state<any[]>([]);\nconst errors = state<Record<string, string>>({});\nconst isLoading = state(false);\n\n// Centralized error handling\nconst handleError = action((operation: string, error: Error) => {\n  errors.value = { \n    ...errors.value, \n    [operation]: error.message \n  };\n  console.error(`${operation} failed:`, error);\n}, 'handleError');\n\nconst clearError = action((operation: string) => {\n  const newErrors = { ...errors.value };\n  delete newErrors[operation];\n  errors.value = newErrors;\n}, 'clearError');\n\n// Action with comprehensive error handling\nconst fetchDataWithRetry = action(async (url: string, maxRetries = 3) => {\n  const operation = 'fetchData';\n  clearError(operation);\n  isLoading.value = true;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      data.value = result;\n      clearError(operation); // Clear any previous errors\n      return result;\n      \n    } catch (error) {\n      const isLastAttempt = attempt === maxRetries - 1;\n      \n      if (isLastAttempt) {\n        handleError(operation, error as Error);\n        throw error; // Re-throw on final attempt\n      }\n      \n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n    }\n  }\n}, 'fetchDataWithRetry');\n\n// Action with validation\nconst validateAndSave = action(async (userData: any) => {\n  const operation = 'saveUser';\n  clearError(operation);\n  \n  try {\n    // Validation\n    if (!userData.email || !userData.email.includes('@')) {\n      throw new Error('Valid email is required');\n    }\n    \n    if (!userData.name || userData.name.trim().length < 2) {\n      throw new Error('Name must be at least 2 characters');\n    }\n    \n    // Save operation\n    const response = await fetch('/api/users', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(userData)\n    });\n    \n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.message || 'Save failed');\n    }\n    \n    const savedUser = await response.json();\n    data.value = [...data.value, savedUser];\n    \n  } catch (error) {\n    handleError(operation, error as Error);\n    throw error; // Let caller handle UI response\n  }\n}, 'validateAndSave');\n",
  "arrayStateBasic": "import { arrayState } from 'react-understate';\n\n// Basic array state usage\nconst todos = arrayState<string>(['Learn React', 'Build app'], {\n  name: 'todos',\n});\n\n// Mutating methods that trigger subscriptions\ntodos.push('Deploy app'); // ['Learn React', 'Build app', 'Deploy app']\ntodos.pop(); // ['Learn React', 'Build app']\ntodos.unshift('Plan project'); // ['Plan project', 'Learn React', 'Build app']\ntodos.splice(1, 1, 'Learn TypeScript'); // ['Plan project', 'Learn TypeScript', 'Build app']\n\n// Non-mutating methods (don't trigger subscriptions)\nconst completed = todos.filter(todo => todo.includes('Learn')); // ['Learn TypeScript']\nconst joined = todos.join(', '); // 'Plan project, Learn TypeScript, Build app'\nconst first = todos.at(0); // 'Plan project'\nconst last = todos.at(-1); // 'Build app'\n\n// Subscribe to changes\ntodos.subscribe(() => {\n  console.log('Todos changed:', todos.value);\n});\n\n// Utility methods\ntodos.clear(); // []\ntodos.set(['New task 1', 'New task 2']); // ['New task 1', 'New task 2']\n\n// Batch operations\ntodos.batch(arr => {\n  arr.push('Task 3');\n  arr.push('Task 4');\n  arr.sort(); // Sorts in place\n}); // ['New task 1', 'New task 2', 'Task 3', 'Task 4']\n\nexport { todos };\n",
  "arrayStateReact": "import React from 'react';\nimport { arrayState, useUnderstate } from 'react-understate';\n\n// Array state for shopping cart\nconst cart = arrayState<{ id: number; name: string; price: number; quantity: number }>([\n  { id: 1, name: 'Laptop', price: 999, quantity: 1 },\n  { id: 2, name: 'Mouse', price: 25, quantity: 2 },\n], { name: 'cart' });\n\n// Derived values\nconst totalItems = () => cart.reduce((sum, item) => sum + item.quantity, 0);\nconst totalPrice = () => cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n\n// Actions for cart operations\nconst addToCart = (product: { id: number; name: string; price: number }) => {\n  const existingItem = cart.find(item => item.id === product.id);\n  \n  if (existingItem) {\n    // Update quantity\n    const index = cart.findIndex(item => item.id === product.id);\n    cart.splice(index, 1, { ...existingItem, quantity: existingItem.quantity + 1 });\n  } else {\n    // Add new item\n    cart.push({ ...product, quantity: 1 });\n  }\n};\n\nconst removeFromCart = (productId: number) => {\n  const index = cart.findIndex(item => item.id === productId);\n  if (index !== -1) {\n    cart.splice(index, 1);\n  }\n};\n\nconst updateQuantity = (productId: number, quantity: number) => {\n  const index = cart.findIndex(item => item.id === productId);\n  if (index !== -1) {\n    if (quantity <= 0) {\n      cart.splice(index, 1);\n    } else {\n      cart.splice(index, 1, { ...cart[index], quantity });\n    }\n  }\n};\n\nconst clearCart = () => {\n  cart.clear();\n};\n\n// React component\nfunction ShoppingCart() {\n  const [cartItems] = useUnderstate(cart);\n  const [itemCount] = useUnderstate({ totalItems });\n  const [price] = useUnderstate({ totalPrice });\n\n  return (\n    <div>\n      <h2>Shopping Cart ({itemCount} items)</h2>\n      \n      {cartItems.length === 0 ? (\n        <p>Your cart is empty</p>\n      ) : (\n        <div>\n          {cartItems.map(item => (\n            <div key={item.id} style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>\n              <span>{item.name}</span>\n              <span>${item.price}</span>\n              <input\n                type=\"number\"\n                value={item.quantity}\n                onChange={(e) => updateQuantity(item.id, parseInt(e.target.value) || 0)}\n                min=\"0\"\n                style={{ width: '60px' }}\n              />\n              <button onClick={() => removeFromCart(item.id)}>Remove</button>\n            </div>\n          ))}\n          \n          <div style={{ marginTop: '20px', fontWeight: 'bold' }}>\n            Total: ${price.toFixed(2)}\n          </div>\n          \n          <button onClick={clearCart} style={{ marginTop: '10px' }}>\n            Clear Cart\n          </button>\n        </div>\n      )}\n      \n      <div style={{ marginTop: '20px' }}>\n        <h3>Add Items</h3>\n        <button onClick={() => addToCart({ id: 3, name: 'Keyboard', price: 75 })}>\n          Add Keyboard\n        </button>\n        <button onClick={() => addToCart({ id: 4, name: 'Monitor', price: 200 })}>\n          Add Monitor\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport { ShoppingCart, addToCart, removeFromCart, updateQuantity, clearCart };\n",
  "arraystateapi": "const items = arrayState<string>(['a', 'b', 'c']);\n\n// for...of loop\nfor (const item of items) {\n  console.log(item);\n}\n\n// Spread operator\nconst spread = [...items];\n\n// Array.from()\nconst fromArray = Array.from(items);",
  "arraystateapi2": "const addTodo = action((text: string) => {\n  const newId = Math.max(...todos.map(t => t.id), 0) + 1;\n  todos.push({ id: newId, text, completed: false });\n}, 'addTodo');\n\nconst toggleTodo = action((id: number) => {\n  const index = todos.findIndex(todo => todo.id === id);\n  if (index !== -1) {\n    todos.splice(index, 1, {\n      ...todos[index],\n      completed: !todos[index].completed,\n    });\n  }\n}, 'toggleTodo');",
  "arraystateapi3": "items.batch(arr => {\n  arr.push('item1');\n  arr.push('item2');\n  arr.sort();\n  // Only triggers one subscription notification\n});",
  "arraystateapi4": "const completedTodos = derived(() => \n  todos.filter(todo => todo.completed)\n);\n\nconst todoStats = derived(() => ({\n  total: todos.length,\n  completed: completedTodos.value.length,\n  pending: todos.length - completedTodos.value.length,\n}));",
  "arraystateapi5": "// Get array length\nitems.length: number\n\n// Get/set array value\nitems.value: T[]\n\n// Subscribe to changes\nitems.subscribe(fn: () => void): () => void",
  "arraystateapi6": "const items = arrayState<string>(['a', 'b', 'c']);\n\n// for...of loop\nfor (const item of items) {\n  console.log(item);\n}\n\n// Spread operator\nconst spread = [...items];\n\n// Array.from()\nconst fromArray = Array.from(items);",
  "arraystateapi7": "const addTodo = action((text: string) => {\n  const newId = Math.max(...todos.map(t => t.id), 0) + 1;\n  todos.push({ id: newId, text, completed: false });\n}, 'addTodo');\n\nconst toggleTodo = action((id: number) => {\n  const index = todos.findIndex(todo => todo.id === id);\n  if (index !== -1) {\n    todos.splice(index, 1, {\n      ...todos[index],\n      completed: !todos[index].completed,\n    });\n  }\n}, 'toggleTodo');",
  "arraystateapi8": "items.batch(arr => {\n  arr.push('item1');\n  arr.push('item2');\n  arr.sort();\n  // Only triggers one subscription notification\n});",
  "arraystateapi9": "const completedTodos = derived(() => \n  todos.filter(todo => todo.completed)\n);\n\nconst todoStats = derived(() => ({\n  total: todos.length,\n  completed: completedTodos.value.length,\n  pending: todos.length - completedTodos.value.length,\n}));",
  "asyncdataloading": "import { state, derived, action, effect } from 'react-understate';\n\n// Data types\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n};\n\ntype LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n// State\nexport const users = state<User[]>([], { name: 'users' });\nexport const loadingState = state<LoadingState>('idle', {\n  name: 'loadingState',\n});\nexport const error = state<string | null>(null, { name: 'error' });\nexport const lastFetch = state<Date | null>(null, { name: 'lastFetch' });\n\n// Derived values\nexport const isLoading = derived(() => loadingState() === 'loading', {\n  name: 'isLoading',\n});\n\nexport const hasError = derived(() => error() !== null, {\n  name: 'hasError',\n});\n\nexport const isEmpty = derived(() => users().length === 0, {\n  name: 'isEmpty',\n});\n\nexport const shouldRefresh = derived(\n  () => {\n    const last = lastFetch();\n    if (!last) return true;\n\n    // Refresh if data is older than 5 minutes\n    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n    return last < fiveMinutesAgo;\n  },\n  { name: 'shouldRefresh' },\n);\n\n// Actions\nexport const fetchUsers = action(\n  async (_: void, { signal }: { signal: AbortSignal }) => {\n    console.log('action: fetching users');\n\n    loadingState('loading');\n    error(null);\n\n    try {\n      const response = await fetch('/api/users', { signal });\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch users: ${response.statusText}`);\n      }\n\n      const userData: User[] = await response.json();\n\n      // Only update if not aborted\n      if (!signal.aborted) {\n        users(userData);\n        loadingState('success');\n        lastFetch(new Date());\n      }\n    } catch (err) {\n      // Don't treat aborted requests as errors\n      if (err instanceof Error && err.name === 'AbortError') {\n        console.log('action: fetch cancelled');\n        return;\n      }\n\n      console.error('action: fetch error', err);\n      error(err instanceof Error ? err.message : 'Unknown error');\n      loadingState('error');\n    }\n  },\n  { name: 'fetchUsers' },\n);\n\nexport const refreshUsers = action(\n  async () => {\n    console.log('action: refreshing users');\n    await fetchUsers();\n  },\n  { name: 'refreshUsers' },\n);\n\nexport const clearError = action(\n  () => {\n    console.log('action: clearing error');\n    error(null);\n    if (loadingState() === 'error') {\n      loadingState('idle');\n    }\n  },\n  { name: 'clearError' },\n);\n",
  "asyncdataloading2": "// Auto-cancellation is handled by Understate via AbortSignals.\n// Multiple calls to the same async action will abort previous requests.\n\nexport const fetchUsersWithCancellation = action(\n  async () => {\n    console.log('action: fetching users with cancellation');\n    await fetchUsers();\n  },\n  { name: 'fetchUsersWithCancellation' },\n);\n\n// Kept for API parity with examples; note that explicit cancel isn't necessary\n// because unmounts and subsequent calls auto-abort in-progress requests.\nexport const cancelCurrentRequest = action(\n  () => {\n    console.log('action: cancel not required; previous requests auto-abort');\n  },\n  { name: 'cancelCurrentRequest' },\n);\n",
  "asyncdataloading4": "type ResourceState<T> = {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n  lastFetch: Date | null;\n};\n\ntype ResourceConfig = {\n  cacheDuration?: number; // milliseconds\n  retryAttempts?: number;\n  retryDelay?: number;\n};\n\nexport function createResourceManager<T>(\n  fetcher: (signal: AbortSignal) => Promise<T>,\n  config: ResourceConfig = {}\n) {\n  const {\n    cacheDuration = 5 * 60 * 1000, // 5 minutes\n    retryAttempts = 3,\n    retryDelay = 1000,\n  } = config;\n  \n  // State\n  const resourceState = state<ResourceState<T>>({\n    data: null,\n    loading: false,\n    error: null,\n    lastFetch: null,\n  });\n  \n  let currentController: AbortController | null = null;\n  let retryCount = 0;\n  \n  // Derived values\n  const data = derived(() => resourceState().data);\n  const loading = derived(() => resourceState().loading);\n  const error = derived(() => resourceState().error);\n  \n  const isStale = derived(() => {\n    const state = resourceState();\n    if (!state.lastFetch) return true;\n    \n    const now = Date.now();\n    const fetchTime = state.lastFetch.getTime();\n    return now - fetchTime > cacheDuration;\n  });\n  \n  // Actions\n  const fetch = action(async (force = false) => {\n    const state = resourceState();\n    \n    // Skip if already loading or data is fresh\n    if (state.loading || (!force && !isStale() && state.data)) {\n      return state.data;\n    }\n    \n    // Cancel previous request\n    if (currentController) {\n      currentController.abort();\n    }\n    \n    currentController = new AbortController();\n    const signal = currentController.signal;\n    \n    // Update loading state\n    resourceState({\n      ...state,\n      loading: true,\n      error: null,\n    });\n    \n    try {\n      const result = await fetcher(signal);\n      \n      if (!signal.aborted) {\n        retryCount = 0; // Reset retry count on success\n        resourceState({\n          data: result,\n          loading: false,\n          error: null,\n          lastFetch: new Date(),\n        });\n        return result;\n      }\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        return; // Don't handle aborted requests\n      }\n      \n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      \n      // Retry logic\n      if (retryCount < retryAttempts) {\n        retryCount++;\n        console.log(`Retrying request (attempt ${retryCount}/${retryAttempts})`);\n        \n        setTimeout(() => {\n          if (!signal.aborted) {\n            fetch(force);\n          }\n        }, retryDelay * retryCount); // Exponential backoff\n        \n        return;\n      }\n      \n      // Max retries reached\n      resourceState({\n        ...resourceState(),\n        loading: false,\n        error: errorMessage,\n      });\n    } finally {\n      if (currentController?.signal === signal) {\n        currentController = null;\n      }\n    }\n  });\n  \n  const refresh = action(() => fetch(true));\n  \n  const cancel = action(() => {\n    if (currentController) {\n      currentController.abort();\n      currentController = null;\n    }\n    \n    resourceState({\n      ...resourceState(),\n      loading: false,\n    });\n  });\n  \n  const clearError = action(() => {\n    resourceState({\n      ...resourceState(),\n      error: null,\n    });\n  });\n  \n  return {\n    // State\n    data,\n    loading,\n    error,\n    isStale,\n    \n    // Actions\n    fetch,\n    refresh,\n    cancel,\n    clearError,\n  };\n}\n\n// Usage example\nexport const userResource = createResourceManager<User[]>(\n  async (signal) => {\n    const response = await fetch('/api/users', { signal });\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    return response.json();\n  },\n  {\n    cacheDuration: 10 * 60 * 1000, // 10 minutes\n    retryAttempts: 3,\n    retryDelay: 1000,\n  }\n);",
  "asyncdataloading5": "import React, { useEffect } from 'react';\nimport { useUnderstate } from 'react-understate';\nimport {\n  users,\n  isLoading,\n  hasError,\n  error,\n  isEmpty,\n  fetchUsersWithCancellation,\n  cancelCurrentRequest,\n  clearError,\n  userResource,\n} from './userStore';\n\n// Basic usage\nfunction UserList() {\n  const userList = useUnderstate(users);\n  const loading = useUnderstate(isLoading);\n  const hasErr = useUnderstate(hasError);\n  const errorMsg = useUnderstate(error);\n  const empty = useUnderstate(isEmpty);\n\n  useEffect(() => {\n    // Fetch on mount\n    fetchUsersWithCancellation();\n    \n    // Cancel on unmount\n    return () => {\n      cancelCurrentRequest();\n    };\n  }, []);\n\n  if (loading) {\n    return (\n      <div>\n        Loading users...\n        <button onClick={cancelCurrentRequest}>Cancel</button>\n      </div>\n    );\n  }\n\n  if (hasErr) {\n    return (\n      <div>\n        <p>Error: {errorMsg}</p>\n        <button onClick={clearError}>Dismiss</button>\n        <button onClick={fetchUsersWithCancellation}>Retry</button>\n      </div>\n    );\n  }\n\n  if (empty) {\n    return <p>No users found.</p>;\n  }\n\n  return (\n    <div>\n      <h2>Users</h2>\n      <button onClick={() => fetchUsersWithCancellation()}>\n        Refresh\n      </button>\n      <ul>\n        {userList.map(user => (\n          <li key={user.id}>\n            {user.name} ({user.email})\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Using resource manager\nfunction UserListWithResource() {\n  const data = useUnderstate(userResource.data);\n  const loading = useUnderstate(userResource.loading);\n  const error = useUnderstate(userResource.error);\n  const isStale = useUnderstate(userResource.isStale);\n\n  useEffect(() => {\n    userResource.fetch();\n    \n    return () => {\n      userResource.cancel();\n    };\n  }, []);\n\n  return (\n    <div>\n      {isStale && <p>Data may be outdated</p>}\n      \n      {loading && <p>Loading...</p>}\n      \n      {error && (\n        <div>\n          <p>Error: {error}</p>\n          <button onClick={userResource.clearError}>Dismiss</button>\n          <button onClick={userResource.refresh}>Retry</button>\n        </div>\n      )}\n      \n      {data && (\n        <div>\n          <button onClick={userResource.refresh}>\n            Refresh {loading ? '(Loading...)' : ''}\n          </button>\n          <ul>\n            {data.map(user => (\n              <li key={user.id}>{user.name}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport { UserList, UserListWithResource };",
  "asyncdataloading6": "export const addUserOptimistic = action(async (newUser: Omit<User, 'id'>) => {\n  console.log('action: adding user optimistically');\n  \n  // Generate optimistic ID\n  const optimisticId = Date.now();\n  const optimisticUser: User = { ...newUser, id: optimisticId };\n  \n  // Immediately add to UI\n  const currentUsers = users();\n  users([...currentUsers, optimisticUser]);\n  \n  const controller = new AbortController();\n  \n  try {\n    const response = await fetch('/api/users', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(newUser),\n      signal: controller.signal,\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to add user: ${response.statusText}`);\n    }\n    \n    const savedUser: User = await response.json();\n    \n    // Replace optimistic user with real user\n    users(prev => prev.map(user => \n      user.id === optimisticId ? savedUser : user\n    ));\n    \n  } catch (err) {\n    if (err instanceof Error && err.name === 'AbortError') {\n      return;\n    }\n    \n    // Roll back optimistic update\n    users(prev => prev.filter(user => user.id !== optimisticId));\n    \n    // Show error\n    error(err instanceof Error ? err.message : 'Failed to add user');\n    throw err;\n  }\n}, { name: 'addUserOptimistic' });\n\nexport const deleteUserOptimistic = action(async (userId: number) => {\n  console.log('action: deleting user optimistically');\n  \n  // Store original state for rollback\n  const originalUsers = users();\n  \n  // Immediately remove from UI\n  users(prev => prev.filter(user => user.id !== userId));\n  \n  try {\n    const response = await fetch(`/api/users/${userId}`, {\n      method: 'DELETE',\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to delete user: ${response.statusText}`);\n    }\n    \n    // Success - no need to update UI, already removed\n    \n  } catch (err) {\n    // Roll back - restore original state\n    users(originalUsers);\n    \n    error(err instanceof Error ? err.message : 'Failed to delete user');\n    throw err;\n  }\n}, { name: 'deleteUserOptimistic' });",
  "batchapi": "import { state, useUnderstate } from 'react-understate';\n\nconst firstName = state('');\nconst lastName = state('');\nconst email = state('');\n\nfunction updateUser(userData: any) {\n  // ❌ This triggers 3 separate re-renders\n  firstName.value = userData.firstName;\n  lastName.value = userData.lastName; \n  email.value = userData.email;\n}\n\nfunction UserForm() {\n  const { firstName: first, lastName: last, email: userEmail } = useUnderstate({\n    firstName,\n    lastName,\n    email\n  });\n  \n  console.log('Component rendered'); // This logs 3 times!\n  \n  return (\n    <div>\n      <p>{first} {last} - {userEmail}</p>\n      <button onClick={() => updateUser({\n        firstName: 'John',\n        lastName: 'Doe', \n        email: 'john@example.com'\n      })}>\n        Update User\n      </button>\n    </div>\n  );\n}",
  "batchapi10": "function updateItems(updates: Array<{ id: number; changes: any }>) {\n  if (updates.length === 1) {\n    // Single update - no need to batch\n    const update = updates[0];\n    const newItems = items.value.map(item =>\n      item.id === update.id ? { ...item, ...update.changes } : item\n    );\n    items.value = newItems;\n    \n  } else {\n    // Multiple updates - use batching\n    batch(() => {\n      let newItems = items.value;\n      \n      updates.forEach(update => {\n        newItems = newItems.map(item =>\n          item.id === update.id ? { ...item, ...update.changes } : item\n        );\n      });\n      \n      items.value = newItems;\n      lastUpdateCount.value = updates.length;\n      lastUpdateTime.value = Date.now();\n    });\n  }\n}",
  "batchapi2": "import { state, batch, useUnderstate } from 'react-understate';\n\nconst firstName = state('');\nconst lastName = state('');\nconst email = state('');\n\nfunction updateUser(userData: any) {\n  // ✅ This triggers only 1 re-render\n  batch(() => {\n    firstName.value = userData.firstName;\n    lastName.value = userData.lastName; \n    email.value = userData.email;\n  });\n}\n\nfunction UserForm() {\n  const { firstName: first, lastName: last, email: userEmail } = useUnderstate({\n    firstName,\n    lastName,\n    email\n  });\n  \n  console.log('Component rendered'); // This logs only once!\n  \n  return (\n    <div>\n      <p>{first} {last} - {userEmail}</p>\n      <button onClick={() => updateUser({\n        firstName: 'John',\n        lastName: 'Doe', \n        email: 'john@example.com'\n      })}>\n        Update User\n      </button>\n    </div>\n  );\n}",
  "batchapi3": "import { state, batch, useUnderstate } from 'react-understate';\n\n// Form state\nconst formData = state({\n  name: '',\n  email: '',\n  phone: '',\n  address: {\n    street: '',\n    city: '',\n    zipCode: ''\n  }\n});\n\nconst formErrors = state<Record<string, string>>({});\nconst isSubmitting = state(false);\nconst submitStatus = state<'idle' | 'success' | 'error'>('idle');\n\nfunction resetForm() {\n  batch(() => {\n    formData.value = {\n      name: '',\n      email: '',\n      phone: '',\n      address: {\n        street: '',\n        city: '',\n        zipCode: ''\n      }\n    };\n    formErrors.value = {};\n    isSubmitting.value = false;\n    submitStatus.value = 'idle';\n  });\n}\n\nfunction validateAndSubmit(data: any) {\n  const errors: Record<string, string> = {};\n  \n  // Validation logic\n  if (!data.name.trim()) errors.name = 'Name is required';\n  if (!data.email.includes('@')) errors.email = 'Valid email is required';\n  if (!data.phone.trim()) errors.phone = 'Phone is required';\n  \n  // Update form state atomically\n  batch(() => {\n    formErrors.value = errors;\n    isSubmitting.value = Object.keys(errors).length === 0;\n    \n    if (Object.keys(errors).length === 0) {\n      submitStatus.value = 'idle';\n      // Form is valid, start submission\n    } else {\n      submitStatus.value = 'error';\n    }\n  });\n  \n  // If validation passed, submit\n  if (Object.keys(errors).length === 0) {\n    submitForm(data);\n  }\n}\n\nasync function submitForm(data: any) {\n  try {\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    // Success - update multiple states\n    batch(() => {\n      isSubmitting.value = false;\n      submitStatus.value = 'success';\n      // Keep form data for now\n    });\n    \n    // Clear form after showing success\n    setTimeout(resetForm, 2000);\n    \n  } catch (error) {\n    batch(() => {\n      isSubmitting.value = false;\n      submitStatus.value = 'error';\n      formErrors.value = { submit: 'Submission failed. Please try again.' };\n    });\n  }\n}\n\nfunction ContactForm() {\n  const { \n    formData: data, \n    formErrors: errors, \n    isSubmitting: submitting,\n    submitStatus: status\n  } = useUnderstate({\n    formData,\n    formErrors,\n    isSubmitting,\n    submitStatus\n  });\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    validateAndSubmit(data);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <input\n          value={data.name}\n          onChange={(e) => {\n            batch(() => {\n              formData.value = { ...data, name: e.target.value };\n              // Clear error when user starts typing\n              if (errors.name) {\n                const newErrors = { ...errors };\n                delete newErrors.name;\n                formErrors.value = newErrors;\n              }\n            });\n          }}\n          placeholder=\"Name\"\n          disabled={submitting}\n        />\n        {errors.name && <span className=\"error\">{errors.name}</span>}\n      </div>\n      \n      <div>\n        <input\n          value={data.email}\n          onChange={(e) => {\n            batch(() => {\n              formData.value = { ...data, email: e.target.value };\n              if (errors.email) {\n                const newErrors = { ...errors };\n                delete newErrors.email;\n                formErrors.value = newErrors;\n              }\n            });\n          }}\n          placeholder=\"Email\"\n          type=\"email\"\n          disabled={submitting}\n        />\n        {errors.email && <span className=\"error\">{errors.email}</span>}\n      </div>\n      \n      <button type=\"submit\" disabled={submitting}>\n        {submitting ? 'Submitting...' : 'Submit'}\n      </button>\n      \n      {status === 'success' && <p className=\"success\">Form submitted successfully!</p>}\n      {status === 'error' && errors.submit && <p className=\"error\">{errors.submit}</p>}\n      \n      <button type=\"button\" onClick={resetForm} disabled={submitting}>\n        Reset Form\n      </button>\n    </form>\n  );\n}",
  "batchapi4": "import { state, batch } from 'react-understate';\n\nconst user = state({ name: '', age: 0 });\nconst userStats = state({ loginCount: 0, lastLogin: null });\nconst userPrefs = state({ theme: 'light', lang: 'en' });\n\n// ✅ Good - batch related user updates\nfunction loadUserProfile(userData: any) {\n  batch(() => {\n    user.value = { name: userData.name, age: userData.age };\n    userStats.value = { \n      loginCount: userData.loginCount, \n      lastLogin: userData.lastLogin \n    };\n    userPrefs.value = { \n      theme: userData.preferences.theme,\n      lang: userData.preferences.language\n    };\n  });\n}\n\n// ❌ Less ideal - separate updates cause multiple renders\nfunction loadUserProfileUnbatched(userData: any) {\n  user.value = { name: userData.name, age: userData.age };\n  userStats.value = { loginCount: userData.loginCount, lastLogin: userData.lastLogin };\n  userPrefs.value = { theme: userData.preferences.theme, lang: userData.preferences.language };\n}",
  "batchapi5": "import { state, batch } from 'react-understate';\n\nconst currentView = state('home');\nconst isLoading = state(false);\nconst data = state(null);\nconst error = state(null);\n\n// ✅ Batch state transition updates\nfunction navigateToProfile(userId: string) {\n  batch(() => {\n    currentView.value = 'profile';\n    isLoading.value = true;\n    error.value = null;\n    data.value = null; // Clear previous data\n  });\n  \n  // Then load new data\n  loadProfileData(userId);\n}\n\nfunction handleDataLoad(result: any) {\n  batch(() => {\n    data.value = result;\n    isLoading.value = false;\n    error.value = null;\n  });\n}\n\nfunction handleError(err: Error) {\n  batch(() => {\n    data.value = null;\n    isLoading.value = false;\n    error.value = err.message;\n  });\n}",
  "batchapi6": "import { state, batch } from 'react-understate';\n\nconst items = state<Array<{ id: number; name: string; selected: boolean }>>([]);\nconst selectedCount = state(0);\nconst allSelected = state(false);\n\nfunction toggleAllItems() {\n  const shouldSelectAll = !allSelected.value;\n  \n  batch(() => {\n    // Update all items\n    items.value = items.value.map(item => ({\n      ...item,\n      selected: shouldSelectAll\n    }));\n    \n    // Update derived states\n    selectedCount.value = shouldSelectAll ? items.value.length : 0;\n    allSelected.value = shouldSelectAll;\n  });\n}\n\nfunction toggleItem(id: number) {\n  const newItems = items.value.map(item =>\n    item.id === id ? { ...item, selected: !item.selected } : item\n  );\n  \n  const newSelectedCount = newItems.filter(item => item.selected).length;\n  const newAllSelected = newSelectedCount === newItems.length;\n  \n  batch(() => {\n    items.value = newItems;\n    selectedCount.value = newSelectedCount;\n    allSelected.value = newAllSelected;\n  });\n}\n\nfunction deleteSelectedItems() {\n  const remainingItems = items.value.filter(item => !item.selected);\n  \n  batch(() => {\n    items.value = remainingItems;\n    selectedCount.value = 0;\n    allSelected.value = false;\n  });\n}",
  "batchapi7": "import { state, batch } from 'react-understate';\n\nconst a = state(0);\nconst b = state(0);\nconst c = state(0);\n\nfunction updateAB() {\n  batch(() => {\n    a.value = 1;\n    b.value = 2;\n  });\n}\n\nfunction updateAll() {\n  batch(() => {\n    updateAB(); // This batch is merged into the outer batch\n    c.value = 3;\n  });\n  // All three updates (a, b, c) happen in a single re-render\n}\n\n// More complex nesting\nfunction complexUpdate() {\n  batch(() => {\n    a.value = 10;\n    \n    batch(() => {\n      b.value = 20;\n      \n      batch(() => {\n        c.value = 30;\n      });\n    });\n    \n    // More updates at outer level\n    a.value = a.value + 1; // Now 11\n  });\n  // Components re-render once with a=11, b=20, c=30\n}",
  "batchapi8": "import { state, action } from 'react-understate';\n\nconst count = state(0);\nconst message = state('');\n\n// ✅ Automatically batched in event handlers\nfunction handleClick() {\n  count.value++; // These updates are automatically\n  message.value = `Count is ${count.value}`; // batched together\n}\n\n// ✅ Automatically batched in actions\nconst incrementWithMessage = action(() => {\n  count.value++;\n  message.value = `Count is ${count.value}`;\n});\n\n// ❌ May need manual batching in async contexts\nasync function handleAsyncUpdate() {\n  const result = await fetchData();\n  \n  // These might not be automatically batched\n  batch(() => {\n    count.value = result.count;\n    message.value = result.message;\n  });\n}\n\n// ✅ Automatically batched in setTimeout/promises in React 18+\nfunction delayedUpdate() {\n  setTimeout(() => {\n    count.value++; // Automatically batched in React 18+\n    message.value = 'Updated!';\n  }, 1000);\n}",
  "batchapi9": "// ❌ Overly broad batching\nfunction processLargeDataset(data: any[]) {\n  batch(() => {\n    // Long running operation inside batch\n    const processed = data.map(item => expensiveProcessing(item));\n    \n    results.value = processed;\n    isLoading.value = false;\n  });\n}\n\n// ✅ Batch only the state updates\nfunction processLargeDataset(data: any[]) {\n  // Do expensive work outside batch\n  const processed = data.map(item => expensiveProcessing(item));\n  \n  // Batch only the state updates\n  batch(() => {\n    results.value = processed;\n    isLoading.value = false;\n  });\n}",
  "batching": "import { state, action } from 'react-understate';\n\n// Multiple state atoms\nconst count = state(0, { name: 'count' });\nconst name = state('', { name: 'name' });\nconst isVisible = state(false, { name: 'isVisible' });\n\n// Automatic batching in event handlers\nfunction handleButtonClick() {\n  // These three updates are automatically batched\n  count(prev => prev + 1);\n  name('Button clicked');\n  isVisible(true);\n  // Only one re-render will occur\n}\n\n// Automatic batching in actions\nexport const updateUserProfile = action((userData: UserData) => {\n  console.log('action: updating user profile');\n  \n  // All these updates are batched together\n  name(userData.name);\n  email(userData.email);\n  avatar(userData.avatar);\n  preferences(userData.preferences);\n  \n  // Only one re-render for all updates\n}, { name: 'updateUserProfile' });\n\n// Automatic batching in effects\nexport const syncEffect = effect(() => {\n  const data = externalData();\n  \n  if (data) {\n    // These updates are batched\n    processData(data);\n    updateCache(data);\n    notifySubscribers(data);\n  }\n}, { name: 'syncEffect' });",
  "batching2": "import { state, batch, action } from 'react-understate';\n\n// Manual batching for complex operations\nexport const complexUpdate = action(() => {\n  console.log('action: performing complex update');\n  \n  batch(() => {\n    // All updates inside batch() are grouped together\n    user(prev => ({ ...prev, name: 'John' }));\n    settings(prev => ({ ...prev, theme: 'dark' }));\n    notifications(prev => ({ ...prev, enabled: true }));\n    \n    // Derived values won't recalculate until batch completes\n    const userDisplay = `${user().name} - ${settings().theme}`;\n    console.log('User display:', userDisplay);\n  });\n  \n  // Re-renders happen after batch completes\n}, { name: 'complexUpdate' });\n\n// Nested batching\nexport const nestedBatching = action(() => {\n  console.log('action: nested batching example');\n  \n  batch(() => {\n    // First batch\n    count(1);\n    name('First');\n    \n    batch(() => {\n      // Nested batch - still part of the outer batch\n      count(2);\n      name('Second');\n      \n      batch(() => {\n        // Deeply nested - still batched\n        count(3);\n        name('Third');\n      });\n    });\n    \n    // This is also part of the outer batch\n    isVisible(true);\n  });\n  \n  // All updates are batched together, only one re-render\n}, { name: 'nestedBatching' });\n\n// Conditional batching\nexport const conditionalBatching = action((shouldBatch: boolean) => {\n  console.log('action: conditional batching', shouldBatch);\n  \n  if (shouldBatch) {\n    batch(() => {\n      updateMultipleStates();\n    });\n  } else {\n    // Updates happen individually\n    updateMultipleStates();\n  }\n}, { name: 'conditionalBatching' });\n\nfunction updateMultipleStates() {\n  state1('value1');\n  state2('value2');\n  state3('value3');\n}",
  "batching3": "// 1. Bulk data loading\nexport const loadBulkData = action(async (data: BulkData) => {\n  console.log('action: loading bulk data');\n  \n  // Without batching - multiple re-renders\n  // users(data.users);\n  // posts(data.posts);\n  // comments(data.comments);\n  // settings(data.settings);\n  \n  // With batching - single re-render\n  batch(() => {\n    users(data.users);\n    posts(data.posts);\n    comments(data.comments);\n    settings(data.settings);\n  });\n}, { name: 'loadBulkData' });\n\n// 2. Form validation updates\nexport const validateForm = action((formData: FormData) => {\n  console.log('action: validating form');\n  \n  const errors = validateFormData(formData);\n  \n  batch(() => {\n    // Update all validation states at once\n    formErrors(errors);\n    fieldErrors(errors.fieldErrors);\n    isValid(Object.keys(errors).length === 0);\n    isDirty(true);\n  });\n}, { name: 'validateForm' });\n\n// 3. UI state synchronization\nexport const syncUIState = action((uiState: UIState) => {\n  console.log('action: syncing UI state');\n  \n  batch(() => {\n    // Update all UI-related state together\n    sidebarOpen(uiState.sidebarOpen);\n    modalVisible(uiState.modalVisible);\n    activeTab(uiState.activeTab);\n    theme(uiState.theme);\n    language(uiState.language);\n  });\n}, { name: 'syncUIState' });\n\n// 4. Optimized list operations\nexport const updateListItems = action((updates: ItemUpdate[]) => {\n  console.log('action: updating list items');\n  \n  batch(() => {\n    updates.forEach(update => {\n      items(prev => prev.map(item => \n        item.id === update.id ? { ...item, ...update.changes } : item\n      ));\n    });\n    \n    // Update derived state after all item updates\n    totalCount(items().length);\n    selectedCount(items().filter(item => item.selected).length);\n  });\n}, { name: 'updateListItems' });\n\n// 5. Animation state updates\nexport const startAnimation = action(() => {\n  console.log('action: starting animation');\n  \n  batch(() => {\n    isAnimating(true);\n    animationProgress(0);\n    animationDuration(1000);\n    animationEasing('ease-in-out');\n  });\n  \n  // Animation loop outside of batch\n  animate();\n}, { name: 'startAnimation' });",
  "batching4": "// 1. Conditional batching based on state\nexport const smartBatching = action(() => {\n  console.log('action: smart batching');\n  \n  const shouldBatch = items().length > 10; // Batch only for large lists\n  \n  if (shouldBatch) {\n    batch(() => {\n      performBulkUpdates();\n    });\n  } else {\n    performBulkUpdates(); // Individual updates for small lists\n  }\n}, { name: 'smartBatching' });\n\n// 2. Batching with cleanup\nexport const batchedEffect = effect(() => {\n  const data = externalData();\n  \n  if (data) {\n    // Batch updates in effects\n    batch(() => {\n      processData(data);\n      updateCache(data);\n      notifySubscribers(data);\n    });\n  }\n  \n  return () => {\n    // Cleanup can also be batched\n    batch(() => {\n      clearCache();\n      removeSubscribers();\n      resetState();\n    });\n  };\n}, { name: 'batchedEffect' });\n\n// 3. Batching with error handling\nexport const safeBatching = action(async () => {\n  console.log('action: safe batching');\n  \n  try {\n    const data = await fetchData();\n    \n    batch(() => {\n      // All updates happen together or not at all\n      processData(data);\n      updateUI(data);\n      clearErrors();\n    });\n  } catch (error) {\n    batch(() => {\n      // Batch error state updates\n      setError(error.message);\n      setLoading(false);\n      resetData();\n    });\n  }\n}, { name: 'safeBatching' });\n\n// 4. Batching with performance monitoring\nexport const monitoredBatching = action(() => {\n  console.log('action: monitored batching');\n  \n  const startTime = performance.now();\n  \n  batch(() => {\n    performComplexUpdates();\n  });\n  \n  const endTime = performance.now();\n  const duration = endTime - startTime;\n  \n  if (duration > 16) { // Longer than one frame\n    console.warn(`Batched update took ${duration.toFixed(2)}ms`);\n  }\n}, { name: 'monitoredBatching' });\n\n// 5. Custom batching utility\nexport const createBatchingUtility = () => {\n  let pendingUpdates: (() => void)[] = [];\n  let isBatching = false;\n  \n  const batchedUpdate = (update: () => void) => {\n    if (isBatching) {\n      pendingUpdates.push(update);\n    } else {\n      update();\n    }\n  };\n  \n  const startBatch = () => {\n    isBatching = true;\n    pendingUpdates = [];\n  };\n  \n  const endBatch = () => {\n    if (pendingUpdates.length > 0) {\n      batch(() => {\n        pendingUpdates.forEach(update => update());\n      });\n    }\n    isBatching = false;\n    pendingUpdates = [];\n  };\n  \n  return { batchedUpdate, startBatch, endBatch };\n};\n\n// Usage\nconst { batchedUpdate, startBatch, endBatch } = createBatchingUtility();\n\nexport const customBatchingExample = action(() => {\n  console.log('action: custom batching example');\n  \n  startBatch();\n  \n  batchedUpdate(() => state1('value1'));\n  batchedUpdate(() => state2('value2'));\n  batchedUpdate(() => state3('value3'));\n  \n  endBatch(); // All updates are batched together\n}, { name: 'customBatchingExample' });",
  "batching5": "// Derived values and batching\nconst items = state<Item[]>([], { name: 'items' });\nconst filter = state('', { name: 'filter' });\nconst sortBy = state('name', { name: 'sortBy' });\n\n// Derived value that depends on multiple state atoms\nconst filteredAndSortedItems = derived(() => {\n  console.log('derived: recalculating filtered and sorted items');\n  \n  const allItems = items();\n  const filterValue = filter();\n  const sortField = sortBy();\n  \n  let filtered = allItems;\n  if (filterValue) {\n    filtered = allItems.filter(item => \n      item.name.toLowerCase().includes(filterValue.toLowerCase())\n    );\n  }\n  \n  return filtered.sort((a, b) => \n    a[sortField].localeCompare(b[sortField])\n  );\n}, { name: 'filteredAndSortedItems' });\n\n// Batching updates to multiple dependencies\nexport const updateFilterAndSort = action((newFilter: string, newSortBy: string) => {\n  console.log('action: updating filter and sort');\n  \n  batch(() => {\n    filter(newFilter);\n    sortBy(newSortBy);\n    // filteredAndSortedItems only recalculates once after both updates\n  });\n}, { name: 'updateFilterAndSort' });\n\n// Batching with derived value dependencies\nexport const addItemAndUpdateStats = action((item: Item) => {\n  console.log('action: adding item and updating stats');\n  \n  batch(() => {\n    items(prev => [...prev, item]);\n    // These derived values will recalculate after the batch\n    totalCount(items().length);\n    lastAddedItem(item);\n    updateTimestamp(new Date());\n  });\n}, { name: 'addItemAndUpdateStats' });\n\n// Performance monitoring for derived values\nconst createMonitoredDerived = <T>(\n  computation: () => T,\n  name: string\n) => {\n  let calculationCount = 0;\n  \n  return derived(() => {\n    calculationCount++;\n    const start = performance.now();\n    \n    const result = computation();\n    \n    const duration = performance.now() - start;\n    if (duration > 5) { // Log slow calculations\n      console.warn(`Derived \"${name}\" calculation #${calculationCount} took ${duration.toFixed(2)}ms`);\n    }\n    \n    return result;\n  }, { name });\n};\n\n// Usage\nconst expensiveDerived = createMonitoredDerived(\n  () => performExpensiveCalculation(),\n  'expensiveDerived'\n);",
  "batching6": "// 1. Batching debug utility\nexport const createBatchingDebugger = () => {\n  let batchCount = 0;\n  let updateCount = 0;\n  let isInBatch = false;\n  \n  const originalBatch = batch;\n  \n  // Override batch function for debugging\n  const debugBatch = (fn: () => void) => {\n    batchCount++;\n    isInBatch = true;\n    updateCount = 0;\n    \n    console.group(`Batch #${batchCount}`);\n    console.log('Starting batch');\n    \n    const startTime = performance.now();\n    \n    originalBatch(() => {\n      fn();\n    });\n    \n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    console.log(`Batch completed: ${updateCount} updates in ${duration.toFixed(2)}ms`);\n    console.groupEnd();\n    \n    isInBatch = false;\n  };\n  \n  // Override state functions to count updates\n  const createDebugState = <T>(initialValue: T, name: string) => {\n    const stateInstance = state(initialValue, { name });\n    const originalSet = stateInstance;\n    \n    return (value: T | ((prev: T) => T)) => {\n      updateCount++;\n      console.log(`Update #${updateCount} in ${isInBatch ? 'batch' : 'individual'}: ${name}`);\n      return originalSet(value);\n    };\n  };\n  \n  return { debugBatch, createDebugState, getStats: () => ({ batchCount, updateCount }) };\n};\n\n// 2. Performance monitoring\nexport const createPerformanceMonitor = () => {\n  const metrics = {\n    batchCount: 0,\n    individualUpdateCount: 0,\n    totalBatchTime: 0,\n    maxBatchTime: 0,\n  };\n  \n  const monitorBatch = (fn: () => void) => {\n    const start = performance.now();\n    batch(fn);\n    const duration = performance.now() - start;\n    \n    metrics.batchCount++;\n    metrics.totalBatchTime += duration;\n    metrics.maxBatchTime = Math.max(metrics.maxBatchTime, duration);\n  };\n  \n  const logMetrics = () => {\n    const avgBatchTime = metrics.totalBatchTime / metrics.batchCount;\n    console.table({\n      'Total Batches': metrics.batchCount,\n      'Individual Updates': metrics.individualUpdateCount,\n      'Average Batch Time (ms)': avgBatchTime.toFixed(2),\n      'Max Batch Time (ms)': metrics.maxBatchTime.toFixed(2),\n    });\n  };\n  \n  return { monitorBatch, logMetrics, metrics };\n};\n\n// 3. Batching analyzer\nexport const analyzeBatching = () => {\n  const analysis = {\n    recommendedBatches: [] as string[],\n    performanceIssues: [] as string[],\n    suggestions: [] as string[],\n  };\n  \n  // Analyze state update patterns\n  const stateUpdatePatterns = analyzeStateUpdates();\n  \n  stateUpdatePatterns.forEach(pattern => {\n    if (pattern.frequency > 10 && pattern.updatesPerSecond > 5) {\n      analysis.recommendedBatches.push(\n        `Consider batching updates to ${pattern.stateName} (updated ${pattern.frequency} times)`\n      );\n    }\n    \n    if (pattern.averageUpdateTime > 5) {\n      analysis.performanceIssues.push(\n        `Slow updates detected for ${pattern.stateName} (${pattern.averageUpdateTime}ms average)`\n      );\n    }\n  });\n  \n  return analysis;\n};\n\n// 4. Real-time batching monitor\nexport const createRealtimeMonitor = () => {\n  const monitor = {\n    isMonitoring: false,\n    startTime: 0,\n    updates: [] as Array<{ state: string; time: number; batched: boolean }>,\n  };\n  \n  const startMonitoring = () => {\n    monitor.isMonitoring = true;\n    monitor.startTime = performance.now();\n    monitor.updates = [];\n    \n    console.log('🔍 Starting batching monitor');\n  };\n  \n  const stopMonitoring = () => {\n    monitor.isMonitoring = false;\n    \n    const duration = performance.now() - monitor.startTime;\n    const batchedUpdates = monitor.updates.filter(u => u.batched).length;\n    const individualUpdates = monitor.updates.length - batchedUpdates;\n    \n    console.log('📊 Batching Monitor Results:');\n    console.log(`Duration: ${duration.toFixed(2)}ms`);\n    console.log(`Total Updates: ${monitor.updates.length}`);\n    console.log(`Batched Updates: ${batchedUpdates}`);\n    console.log(`Individual Updates: ${individualUpdates}`);\n    console.log(`Batching Efficiency: ${((batchedUpdates / monitor.updates.length) * 100).toFixed(1)}%`);\n  };\n  \n  return { startMonitoring, stopMonitoring, monitor };\n};",
  "batching7": "// ✅ DO: Batch related updates together\nconst goodBatching = action(() => {\n  batch(() => {\n    // Related UI updates\n    sidebarOpen(true);\n    activePanel('settings');\n    currentTab('profile');\n  });\n}, { name: 'goodBatching' });\n\n// ❌ DON'T: Batch unrelated updates\nconst badBatching = action(() => {\n  batch(() => {\n    // Unrelated updates - confusing\n    userProfile(profile);\n    weatherData(weather);\n    gameScore(score);\n  });\n}, { name: 'badBatching' });\n\n// ✅ DO: Use batching for performance-critical operations\nconst performanceCritical = action(() => {\n  const largeDataset = generateLargeDataset();\n  \n  batch(() => {\n    // Batch updates for large datasets\n    items(largeDataset);\n    totalCount(largeDataset.length);\n    lastUpdated(new Date());\n  });\n}, { name: 'performanceCritical' });\n\n// ❌ DON'T: Over-batch simple operations\nconst overBatching = action(() => {\n  batch(() => {\n    // Unnecessary batching for simple updates\n    count(count() + 1);\n  });\n}, { name: 'overBatching' });\n\n// ✅ DO: Batch updates in effects when appropriate\nconst goodEffectBatching = effect(() => {\n  const data = externalData();\n  \n  if (data) {\n    batch(() => {\n      // Batch related updates in effects\n      processData(data);\n      updateCache(data);\n      notifySubscribers(data);\n    });\n  }\n}, { name: 'goodEffectBatching' });\n\n// ❌ DON'T: Always batch in effects\nconst badEffectBatching = effect(() => {\n  // Don't batch every effect update\n  batch(() => {\n    singleStateUpdate(value);\n  });\n}, { name: 'badEffectBatching' });\n\n// ✅ DO: Use descriptive batch names for debugging\nconst descriptiveBatching = action(() => {\n  console.log('action: updating user profile');\n  \n  batch(() => {\n    // Clear what this batch does\n    userProfile(profile);\n    userSettings(settings);\n    userPreferences(preferences);\n  });\n}, { name: 'descriptiveBatching' });\n\n// ✅ DO: Handle errors in batches properly\nconst errorHandlingBatching = action(async () => {\n  try {\n    const data = await fetchData();\n    \n    batch(() => {\n      // All updates happen together\n      processData(data);\n      updateUI(data);\n      clearErrors();\n    });\n  } catch (error) {\n    batch(() => {\n      // Batch error state updates\n      setError(error.message);\n      setLoading(false);\n      resetData();\n    });\n  }\n}, { name: 'errorHandlingBatching' });\n\n// ✅ DO: Monitor batching performance\nconst monitoredBatching = action(() => {\n  const start = performance.now();\n  \n  batch(() => {\n    performUpdates();\n  });\n  \n  const duration = performance.now() - start;\n  if (duration > 16) {\n    console.warn(`Slow batch: ${duration.toFixed(2)}ms`);\n  }\n}, { name: 'monitoredBatching' });",
  "batching8": "// ❌ Anti-pattern: Batching everything\nconst overBatching = action(() => {\n  batch(() => {\n    // Batching simple, unrelated updates\n    count(count() + 1);\n    name('John');\n    isVisible(true);\n    theme('dark');\n    language('en');\n  });\n}, { name: 'overBatching' });\n\n// ✅ Solution: Only batch related updates\nconst properBatching = action(() => {\n  // Simple updates don't need batching\n  count(count() + 1);\n  \n  // Batch related updates\n  batch(() => {\n    name('John');\n    email('john@example.com');\n    avatar('avatar.jpg');\n  });\n}, { name: 'properBatching' });\n\n// ❌ Anti-pattern: Batching in derived values\nconst badDerivedBatching = derived(() => {\n  batch(() => {\n    // Don't batch in derived values!\n    state1('value1');\n    state2('value2');\n  });\n  \n  return computeValue();\n}, { name: 'badDerivedBatching' });\n\n// ✅ Solution: Use actions for state updates\nconst goodActionBatching = action(() => {\n  batch(() => {\n    state1('value1');\n    state2('value2');\n  });\n}, { name: 'goodActionBatching' });\n\n// ❌ Anti-pattern: Nested batching without purpose\nconst unnecessaryNestedBatching = action(() => {\n  batch(() => {\n    state1('value1');\n    \n    batch(() => {\n      state2('value2');\n      \n      batch(() => {\n        state3('value3');\n      });\n    });\n  });\n}, { name: 'unnecessaryNestedBatching' });\n\n// ✅ Solution: Single batch for related updates\nconst simpleBatching = action(() => {\n  batch(() => {\n    state1('value1');\n    state2('value2');\n    state3('value3');\n  });\n}, { name: 'simpleBatching' });\n\n// ❌ Anti-pattern: Batching async operations incorrectly\nconst badAsyncBatching = action(async () => {\n  batch(() => {\n    // Don't batch async operations like this\n    const data = await fetchData();\n    processData(data);\n  });\n}, { name: 'badAsyncBatching' });\n\n// ✅ Solution: Batch after async operations\nconst goodAsyncBatching = action(async () => {\n  const data = await fetchData();\n  \n  batch(() => {\n    processData(data);\n    updateUI(data);\n    clearLoading();\n  });\n}, { name: 'goodAsyncBatching' });\n\n// ❌ Anti-pattern: Forgetting to handle errors in batches\nconst badErrorHandling = action(() => {\n  batch(() => {\n    // If any update fails, the whole batch might fail\n    riskyUpdate1();\n    riskyUpdate2();\n    riskyUpdate3();\n  });\n}, { name: 'badErrorHandling' });\n\n// ✅ Solution: Handle errors properly\nconst goodErrorHandling = action(() => {\n  try {\n    batch(() => {\n      safeUpdate1();\n      safeUpdate2();\n      safeUpdate3();\n    });\n  } catch (error) {\n    // Handle batch errors\n    console.error('Batch failed:', error);\n    rollbackChanges();\n  }\n}, { name: 'goodErrorHandling' });",
  "derivedapicontent": "import { state, derived, useUnderstate } from 'react-understate';\n\nconst firstName = state('John');\nconst lastName = state('Doe');\n\n// Derived value that combines other states\nconst fullName = derived(() => `${firstName.value} ${lastName.value}`);\n\nfunction UserDisplay() {\n  const { firstName: first, lastName: last, fullName: name } = useUnderstate({\n    firstName,\n    lastName,\n    fullName\n  });\n  \n  return (\n    <div>\n      <p>Full Name: {name}</p>\n      <input \n        value={first}\n        onChange={(e) => firstName.value = e.target.value}\n        placeholder=\"First Name\"\n      />\n      <input \n        value={last}\n        onChange={(e) => lastName.value = e.target.value}\n        placeholder=\"Last Name\"\n      />\n    </div>\n  );\n}",
  "derivedapicontent2": "import { state, derived, useUnderstate } from 'react-understate';\n\nconst radius = state(5);\nconst pi = 3.14159;\n\n// Multiple derived values\nconst diameter = derived(() => radius.value * 2);\nconst circumference = derived(() => 2 * pi * radius.value);\nconst area = derived(() => pi * Math.pow(radius.value, 2));\n\nfunction CircleCalculator() {\n  const { radius: r, diameter: d, circumference: c, area: a } = useUnderstate({\n    radius,\n    diameter,\n    circumference,\n    area\n  });\n  \n  return (\n    <div>\n      <h3>Circle Calculator</h3>\n      <label>\n        Radius: \n        <input \n          type=\"number\"\n          value={r}\n          onChange={(e) => radius.value = Number(e.target.value)}\n        />\n      </label>\n      \n      <p>Diameter: {d.toFixed(2)}</p>\n      <p>Circumference: {c.toFixed(2)}</p>\n      <p>Area: {a.toFixed(2)}</p>\n    </div>\n  );\n}",
  "derivedapicontent3": "import { state, derived, useUnderstate } from 'react-understate';\n\nconst users = state([\n  { id: 1, name: 'John', age: 25, active: true },\n  { id: 2, name: 'Jane', age: 30, active: false },\n  { id: 3, name: 'Bob', age: 35, active: true }\n]);\n\nconst searchTerm = state('');\nconst showActiveOnly = state(false);\n\n// Complex filtering and searching\nconst filteredUsers = derived(() => {\n  let result = users.value;\n  \n  // Filter by search term\n  if (searchTerm.value) {\n    result = result.filter(user => \n      user.name.toLowerCase().includes(searchTerm.value.toLowerCase())\n    );\n  }\n  \n  // Filter by active status\n  if (showActiveOnly.value) {\n    result = result.filter(user => user.active);\n  }\n  \n  return result;\n});\n\n// Statistics derived from filtered data\nconst userStats = derived(() => {\n  const filtered = filteredUsers.value;\n  return {\n    total: filtered.length,\n    averageAge: filtered.length > 0 \n      ? filtered.reduce((sum, user) => sum + user.age, 0) / filtered.length \n      : 0,\n    activeCount: filtered.filter(user => user.active).length\n  };\n});\n\nfunction UserList() {\n  const { \n    searchTerm: search, \n    showActiveOnly: activeOnly,\n    filteredUsers: users,\n    userStats: stats\n  } = useUnderstate({\n    searchTerm,\n    showActiveOnly,\n    filteredUsers,\n    userStats\n  });\n  \n  return (\n    <div>\n      <h3>User Management</h3>\n      \n      <input\n        type=\"text\"\n        value={search}\n        onChange={(e) => searchTerm.value = e.target.value}\n        placeholder=\"Search users...\"\n      />\n      \n      <label>\n        <input\n          type=\"checkbox\"\n          checked={activeOnly}\n          onChange={(e) => showActiveOnly.value = e.target.checked}\n        />\n        Show active only\n      </label>\n      \n      <div>\n        <p>Total: {stats.total} users</p>\n        <p>Average Age: {stats.averageAge.toFixed(1)}</p>\n        <p>Active: {stats.activeCount}</p>\n      </div>\n      \n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            {user.name} ({user.age}) - {user.active ? 'Active' : 'Inactive'}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
  "derivedapicontent4": "import { state, derived } from 'react-understate';\n\nconst items = state([\n  { name: 'Apple', price: 1.50, quantity: 3 },\n  { name: 'Banana', price: 0.75, quantity: 6 },\n  { name: 'Orange', price: 2.00, quantity: 2 }\n]);\n\nconst taxRate = state(0.08); // 8% tax\nconst discountPercent = state(0); // No discount initially\n\n// First level derivations\nconst subtotal = derived(() => \n  items.value.reduce((sum, item) => sum + (item.price * item.quantity), 0)\n);\n\nconst discountAmount = derived(() => \n  subtotal.value * (discountPercent.value / 100)\n);\n\n// Second level derivations (depend on other derived values)\nconst subtotalAfterDiscount = derived(() => \n  subtotal.value - discountAmount.value\n);\n\nconst taxAmount = derived(() => \n  subtotalAfterDiscount.value * taxRate.value\n);\n\n// Final derivation\nconst total = derived(() => \n  subtotalAfterDiscount.value + taxAmount.value\n);\n\n// Even more complex derivations\nconst itemBreakdown = derived(() => {\n  return items.value.map(item => ({\n    ...item,\n    lineTotal: item.price * item.quantity,\n    discountedPrice: item.price * (1 - discountPercent.value / 100),\n    finalPrice: item.price * (1 - discountPercent.value / 100) * (1 + taxRate.value)\n  }));\n});\n\nfunction ShoppingCart() {\n  const {\n    items: cartItems,\n    subtotal: sub,\n    discountAmount: discount,\n    taxAmount: tax,\n    total: finalTotal,\n    itemBreakdown: breakdown\n  } = useUnderstate({\n    items,\n    subtotal,\n    discountAmount,\n    taxAmount,\n    total,\n    itemBreakdown\n  });\n  \n  return (\n    <div>\n      <h3>Shopping Cart</h3>\n      \n      {breakdown.map((item, index) => (\n        <div key={index}>\n          {item.name}: {item.quantity} × ${item.price} = ${item.lineTotal.toFixed(2)}\n        </div>\n      ))}\n      \n      <hr />\n      <p>Subtotal: ${sub.toFixed(2)}</p>\n      <p>Discount: -${discount.toFixed(2)}</p>\n      <p>Tax: ${tax.toFixed(2)}</p>\n      <strong>Total: ${finalTotal.toFixed(2)}</strong>\n      \n      <div>\n        <label>\n          Discount %: \n          <input \n            type=\"number\"\n            value={discountPercent.value}\n            onChange={(e) => discountPercent.value = Number(e.target.value)}\n          />\n        </label>\n      </div>\n    </div>\n  );\n}",
  "derivedapicontent5": "import { state, asyncDerived, useUnderstate } from 'react-understate';\n\nconst userId = state(1);\n\n// Async derived value that fetches user data\nconst userData = asyncDerived(async () => {\n  const response = await fetch(`/api/users/${userId.value}`);\n  return response.json();\n}, null); // Initial value while loading\n\nconst userPermissions = asyncDerived(async () => {\n  if (!userData.value) return [];\n  \n  const response = await fetch(`/api/users/${userData.value.id}/permissions`);\n  return response.json();\n}, []);\n\nfunction UserProfile() {\n  const { userId: id, userData: user, userPermissions: permissions } = useUnderstate({\n    userId,\n    userData,\n    userPermissions\n  });\n  \n  if (!user) {\n    return <div>Loading user data...</div>;\n  }\n  \n  return (\n    <div>\n      <h3>{user.name}</h3>\n      <p>Email: {user.email}</p>\n      \n      <h4>Permissions:</h4>\n      <ul>\n        {permissions.map(permission => (\n          <li key={permission}>{permission}</li>\n        ))}\n      </ul>\n      \n      <button onClick={() => userId.value = userId.value + 1}>\n        Next User\n      </button>\n    </div>\n  );\n}",
  "derivedapicontent6": "import { state, derived } from 'react-understate';\n\nconst largeDataset = state([/* thousands of items */]);\nconst searchTerm = state('');\nconst sortOrder = state('asc');\n\n// ❌ Inefficient - processes everything on every change\nconst processedData = derived(() => {\n  const filtered = largeDataset.value.filter(item => \n    item.name.toLowerCase().includes(searchTerm.value.toLowerCase())\n  );\n  \n  return filtered.sort((a, b) => {\n    if (sortOrder.value === 'asc') {\n      return a.name.localeCompare(b.name);\n    } else {\n      return b.name.localeCompare(a.name);\n    }\n  });\n});\n\n// ✅ More efficient - split into steps\nconst filteredData = derived(() => \n  largeDataset.value.filter(item => \n    item.name.toLowerCase().includes(searchTerm.value.toLowerCase())\n  )\n);\n\nconst sortedData = derived(() => {\n  const filtered = filteredData.value;\n  return [...filtered].sort((a, b) => {\n    if (sortOrder.value === 'asc') {\n      return a.name.localeCompare(b.name);\n    } else {\n      return b.name.localeCompare(a.name);\n    }\n  });\n});\n\n// Now sorting only happens when sort order changes,\n// and filtering only happens when search term or data changes",
  "derivedapicontent7": "import { state, derived } from 'react-understate';\n\nconst mode = state('simple');\nconst simpleValue = state(10);\nconst complexValue = state({ x: 5, y: 15 });\n\n// Conditional computation based on mode\nconst result = derived(() => {\n  if (mode.value === 'simple') {\n    // Only depends on simpleValue when in simple mode\n    return simpleValue.value * 2;\n  } else {\n    // Only depends on complexValue when in complex mode\n    return complexValue.value.x * complexValue.value.y;\n  }\n});\n\n// This derived will only recalculate when:\n// - mode changes, OR\n// - mode is 'simple' AND simpleValue changes, OR  \n// - mode is 'complex' AND complexValue changes",
  "derivedapicontent8": "import { state, derived } from 'react-understate';\n\nconst inputValue = state('42');\n\nconst parsedNumber = derived(() => {\n  try {\n    const num = parseFloat(inputValue.value);\n    if (isNaN(num)) {\n      throw new Error('Invalid number');\n    }\n    return { value: num, error: null };\n  } catch (error) {\n    return { value: 0, error: error.message };\n  }\n});\n\nconst calculation = derived(() => {\n  const parsed = parsedNumber.value;\n  if (parsed.error) {\n    return { result: null, error: parsed.error };\n  }\n  \n  try {\n    const result = Math.sqrt(parsed.value);\n    return { result, error: null };\n  } catch (error) {\n    return { result: null, error: 'Calculation failed' };\n  }\n});\n\nfunction Calculator() {\n  const { \n    inputValue: input, \n    parsedNumber: parsed, \n    calculation: calc \n  } = useUnderstate({\n    inputValue,\n    parsedNumber,\n    calculation\n  });\n  \n  return (\n    <div>\n      <input\n        value={input}\n        onChange={(e) => inputValue.value = e.target.value}\n        placeholder=\"Enter a number\"\n      />\n      \n      {parsed.error && <p style={{ color: 'red' }}>Input Error: {parsed.error}</p>}\n      \n      {calc.error ? (\n        <p style={{ color: 'red' }}>Calculation Error: {calc.error}</p>\n      ) : (\n        <p>Square Root: {calc.result?.toFixed(2)}</p>\n      )}\n    </div>\n  );\n}",
  "derivedapicontent9": "import { state, derived, configureDebug } from 'react-understate';\n\n// Enable debugging\nconfigureDebug({ enabled: true, showFile: true });\n\nconst price = state(100, 'itemPrice');\nconst quantity = state(2, 'itemQuantity');\nconst taxRate = state(0.08, 'taxRate');\n\n// Named derived values for better debugging\nconst subtotal = derived(() => {\n  console.log('Calculating subtotal');\n  return price.value * quantity.value;\n}, 'subtotal');\n\nconst total = derived(() => {\n  console.log('Calculating total');\n  return subtotal.value * (1 + taxRate.value);\n}, 'total');\n\n// Changes will be logged with names:\nprice.value = 150; // Logs subtotal and total recalculations",
  "derivedvalues": "import { state, derived } from 'react-understate';\n\n// Basic state\nconst firstName = state('John', { name: 'firstName' });\nconst lastName = state('Doe', { name: 'lastName' });\nconst age = state(30, { name: 'age' });\n\n// Simple derived values\nexport const fullName = derived(() => {\n  return `${firstName()} ${lastName()}`;\n}, { name: 'fullName' });\n\nexport const isAdult = derived(() => {\n  return age() >= 18;\n}, { name: 'isAdult' });\n\nexport const greeting = derived(() => {\n  const name = fullName();\n  const adult = isAdult();\n  return `Hello, ${name}! You are ${adult ? 'an adult' : 'a minor'}.`;\n}, { name: 'greeting' });\n\n// Derived values automatically update when dependencies change\nfirstName('Jane'); // fullName and greeting automatically update\nage(16);           // isAdult and greeting automatically update",
  "derivedvalues2": "// Complex data structures\nconst todos = state<Todo[]>([], { name: 'todos' });\nconst filter = state<'all' | 'active' | 'completed'>('all', { name: 'filter' });\nconst searchTerm = state('', { name: 'searchTerm' });\n\ntype Todo = {\n  id: string;\n  text: string;\n  completed: boolean;\n  priority: 'low' | 'medium' | 'high';\n  tags: string[];\n  dueDate?: Date;\n};\n\n// Filtered todos based on completion status\nexport const filteredTodos = derived(() => {\n  const allTodos = todos();\n  const currentFilter = filter();\n  \n  switch (currentFilter) {\n    case 'active':\n      return allTodos.filter(todo => !todo.completed);\n    case 'completed':\n      return allTodos.filter(todo => todo.completed);\n    default:\n      return allTodos;\n  }\n}, { name: 'filteredTodos' });\n\n// Search functionality\nexport const searchedTodos = derived(() => {\n  const filtered = filteredTodos();\n  const search = searchTerm().toLowerCase();\n  \n  if (!search) return filtered;\n  \n  return filtered.filter(todo =>\n    todo.text.toLowerCase().includes(search) ||\n    todo.tags.some(tag => tag.toLowerCase().includes(search))\n  );\n}, { name: 'searchedTodos' });\n\n// Sorted todos with priority and due date\nexport const sortedTodos = derived(() => {\n  const searched = searchedTodos();\n  \n  return [...searched].sort((a, b) => {\n    // First by priority\n    const priorityOrder = { high: 3, medium: 2, low: 1 };\n    const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];\n    if (priorityDiff !== 0) return priorityDiff;\n    \n    // Then by due date\n    if (a.dueDate && b.dueDate) {\n      return a.dueDate.getTime() - b.dueDate.getTime();\n    }\n    if (a.dueDate) return -1;\n    if (b.dueDate) return 1;\n    \n    // Finally by creation order (assuming id contains timestamp)\n    return a.id.localeCompare(b.id);\n  });\n}, { name: 'sortedTodos' });\n\n// Statistics derived from todos\nexport const todoStats = derived(() => {\n  const allTodos = todos();\n  \n  const total = allTodos.length;\n  const completed = allTodos.filter(t => t.completed).length;\n  const active = total - completed;\n  \n  const byPriority = allTodos.reduce((acc, todo) => {\n    acc[todo.priority] = (acc[todo.priority] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n  \n  const overdue = allTodos.filter(todo => \n    todo.dueDate && todo.dueDate < new Date() && !todo.completed\n  ).length;\n  \n  return {\n    total,\n    completed,\n    active,\n    completionRate: total > 0 ? completed / total : 0,\n    byPriority,\n    overdue,\n  };\n}, { name: 'todoStats' });",
  "derivedvalues3": "// 1. Minimize dependencies by splitting computations\n// ❌ Inefficient: Recomputes everything when any user property changes\nconst inefficientUserDisplay = derived(() => {\n  const user = fullUserObject(); // Large object with many properties\n  return `${user.firstName} ${user.lastName} (${user.email})`;\n}, { name: 'inefficientUserDisplay' });\n\n// ✅ Efficient: Only depends on specific properties\nconst efficientUserDisplay = derived(() => {\n  const first = firstName();\n  const last = lastName();\n  const email = userEmail();\n  return `${first} ${last} (${email})`;\n}, { name: 'efficientUserDisplay' });\n\n// 2. Use intermediate derived values for complex chains\nconst userOrders = state<Order[]>([], { name: 'userOrders' });\n\n// Break down complex computation into steps\nexport const validOrders = derived(() => {\n  return userOrders().filter(order => order.status !== 'cancelled');\n}, { name: 'validOrders' });\n\nexport const ordersByMonth = derived(() => {\n  const valid = validOrders();\n  \n  return valid.reduce((acc, order) => {\n    const month = order.date.getMonth();\n    if (!acc[month]) acc[month] = [];\n    acc[month].push(order);\n    return acc;\n  }, {} as Record<number, Order[]>);\n}, { name: 'ordersByMonth' });\n\nexport const monthlyRevenue = derived(() => {\n  const byMonth = ordersByMonth();\n  \n  return Object.entries(byMonth).map(([month, orders]) => ({\n    month: parseInt(month),\n    revenue: orders.reduce((sum, order) => sum + order.total, 0),\n    orderCount: orders.length,\n  }));\n}, { name: 'monthlyRevenue' });\n\n// 3. Conditional dependencies for better performance\nconst showAdvancedStats = state(false, { name: 'showAdvancedStats' });\n\nexport const conditionalStats = derived(() => {\n  const shouldShow = showAdvancedStats();\n  \n  if (!shouldShow) {\n    // Don't access expensive data when not needed\n    return { enabled: false };\n  }\n  \n  // Only compute when actually needed\n  const stats = todoStats();\n  const revenue = monthlyRevenue();\n  \n  return {\n    enabled: true,\n    ...stats,\n    revenue,\n    // More expensive computations...\n  };\n}, { name: 'conditionalStats' });",
  "derivedvalues4": "// ✅ DO: Keep derived functions pure\nconst goodDerived = derived(() => {\n  const items = items();\n  return items.filter(item => item.active).length;\n}, { name: 'activeItemCount' });\n\n// ❌ DON'T: Cause side effects in derived functions\nconst badDerived = derived(() => {\n  const count = items().length;\n  \n  // Side effects! Don't do this\n  localStorage.setItem('itemCount', count.toString());\n  updateAnalytics('itemCountChanged', count);\n  \n  return count;\n}, { name: 'badDerived' });\n\n// ✅ DO: Use descriptive names\nconst userDisplayName = derived(() => {\n  const user = currentUser();\n  return user.preferredName || `${user.firstName} ${user.lastName}`;\n}, { name: 'userDisplayName' });\n\n// ✅ DO: Split complex computations into smaller pieces\nconst validItems = derived(() => {\n  return items().filter(item => item.isValid);\n}, { name: 'validItems' });\n\nconst sortedValidItems = derived(() => {\n  return validItems().sort((a, b) => a.priority - b.priority);\n}, { name: 'sortedValidItems' });\n\nconst displayItems = derived(() => {\n  return sortedValidItems().slice(0, 10);\n}, { name: 'displayItems' });",
  "effectapicontent": "import { state, effect } from 'react-understate';\n\nconst count = state(0, 'count');\n\n// Effect runs immediately and when count changes\nconst dispose = effect(() => {\n  console.log(`Count is now: ${count.value}`);\n}, 'logCount');\n\ncount.value = 5; // Logs: \"Count is now: 5\"\ncount.value = 10; // Logs: \"Count is now: 10\"\n\n// Stop the effect when no longer needed\ndispose();",
  "effectapicontent10": "import { state, effect, derived } from 'react-understate';\n\nconst formData = state({\n  email: '',\n  password: '',\n  confirmPassword: ''\n}, 'formData');\n\nconst validationErrors = state({}, 'validationErrors');\n\n// Email validation effect\neffect(() => {\n  const { email } = formData.value;\n  const errors = { ...validationErrors.value };\n  \n  if (email && !email.includes('@')) {\n    errors.email = 'Please enter a valid email address';\n  } else {\n    delete errors.email;\n  }\n  \n  validationErrors.value = errors;\n}, 'validateEmail');\n\n// Password validation effect\neffect(() => {\n  const { password, confirmPassword } = formData.value;\n  const errors = { ...validationErrors.value };\n  \n  if (password && password.length < 8) {\n    errors.password = 'Password must be at least 8 characters';\n  } else {\n    delete errors.password;\n  }\n  \n  if (confirmPassword && password !== confirmPassword) {\n    errors.confirmPassword = 'Passwords do not match';\n  } else {\n    delete errors.confirmPassword;\n  }\n  \n  validationErrors.value = errors;\n}, 'validatePassword');\n\n// Derived form validity\nconst isFormValid = derived(() => {\n  const { email, password, confirmPassword } = formData.value;\n  const errors = validationErrors.value;\n  \n  return email && password && confirmPassword && \n         Object.keys(errors).length === 0;\n}, 'isFormValid');\n\n// Usage\nformData.value = { ...formData.value, email: 'invalid-email' };\n// Automatically sets validationErrors.email\n\nformData.value = { ...formData.value, email: 'user@example.com' };\n// Automatically clears validationErrors.email",
  "effectapicontent11": "import { state, effect } from 'react-understate';\n\nconst isConnected = state(false, 'isConnected');\nconst room = state('general', 'room');\nconst messages = state([], 'messages');\nconst connectionStatus = state('disconnected', 'connectionStatus');\n\nlet websocket: WebSocket | null = null;\n\n// WebSocket connection management\neffect(() => {\n  if (isConnected.value && room.value) {\n    connectionStatus.value = 'connecting';\n    \n    const ws = new WebSocket(`ws://localhost:8080/rooms/${room.value}`);\n    websocket = ws;\n    \n    ws.onopen = () => {\n      connectionStatus.value = 'connected';\n      console.log(`Connected to room: ${room.value}`);\n    };\n    \n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      messages.value = [...messages.value, message];\n    };\n    \n    ws.onclose = () => {\n      connectionStatus.value = 'disconnected';\n      console.log('WebSocket connection closed');\n    };\n    \n    ws.onerror = (error) => {\n      connectionStatus.value = 'error';\n      console.error('WebSocket error:', error);\n    };\n    \n    // Cleanup function\n    return () => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n      websocket = null;\n    };\n  } else {\n    connectionStatus.value = 'disconnected';\n    messages.value = [];\n  }\n}, 'manageWebSocket');\n\n// Usage\nisConnected.value = true;   // Connects to WebSocket\nroom.value = 'developers';  // Switches to different room (reconnects)\nisConnected.value = false;  // Disconnects and cleans up",
  "effectapicontent12": "import { state, effect } from 'react-understate';\n\nconst user = state(null, 'user');\nconst userSettings = state(null, 'userSettings');\nconst isOnline = state(true, 'isOnline');\n\neffect(async () => {\n  // Early return if conditions not met\n  if (!user.value || !isOnline.value) {\n    userSettings.value = null;\n    return;\n  }\n  \n  // Only fetch when user is logged in and online\n  try {\n    const response = await fetch(`/api/users/${user.value.id}/settings`);\n    userSettings.value = await response.json();\n  } catch (error) {\n    console.error('Failed to load user settings:', error);\n  }\n}, 'loadUserSettings');",
  "effectapicontent13": "import { state, effect } from 'react-understate';\n\nconst searchTerm = state('', 'searchTerm');\nconst searchResults = state([], 'searchResults');\n\nlet searchTimeout: NodeJS.Timeout;\n\neffect(() => {\n  // Clear previous timeout\n  if (searchTimeout) {\n    clearTimeout(searchTimeout);\n  }\n  \n  const term = searchTerm.value;\n  \n  if (!term.trim()) {\n    searchResults.value = [];\n    return;\n  }\n  \n  // Debounce the search by 300ms\n  searchTimeout = setTimeout(async () => {\n    try {\n      const response = await fetch(`/api/search?q=${encodeURIComponent(term)}`);\n      const results = await response.json();\n      searchResults.value = results;\n    } catch (error) {\n      console.error('Search failed:', error);\n    }\n  }, 300);\n  \n  // Cleanup timeout on effect disposal\n  return () => {\n    if (searchTimeout) {\n      clearTimeout(searchTimeout);\n    }\n  };\n}, 'debouncedSearch');",
  "effectapicontent14": "import { state, effect } from 'react-understate';\n\nconst dataId = state(1, 'dataId');\nconst data = state(null, 'data');\nconst error = state(null, 'error');\nconst isLoading = state(false, 'isLoading');\n\neffect(async ({ signal }) => {\n  if (!dataId.value) {\n    data.value = null;\n    error.value = null;\n    return;\n  }\n\n  isLoading.value = true;\n  error.value = null;\n  \n  try {\n    const response = await fetch(`/api/data/${dataId.value}`, { signal });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    const result = await response.json();\n    data.value = result;\n    \n  } catch (err) {\n    if (err.name === 'AbortError') {\n      console.log('Request was cancelled');\n      return;\n    }\n    \n    const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n    error.value = errorMessage;\n    data.value = null;\n    \n    console.error(`Failed to load data for ID ${dataId.value}:`, err);\n    \n  } finally {\n    isLoading.value = false;\n  }\n}, 'loadData', { preventOverlap: true });",
  "effectapicontent15": "import { state, effect } from 'react-understate';\n\n// Mock localStorage for testing\nconst mockLocalStorage = {\n  data: {} as Record<string, string>,\n  setItem: jest.fn((key: string, value: string) => {\n    mockLocalStorage.data[key] = value;\n  }),\n  getItem: jest.fn((key: string) => mockLocalStorage.data[key] || null),\n  clear: jest.fn(() => { mockLocalStorage.data = {}; })\n};\n\nObject.defineProperty(window, 'localStorage', {\n  value: mockLocalStorage\n});\n\ndescribe('Preferences Effect', () => {\n  beforeEach(() => {\n    mockLocalStorage.clear();\n    jest.clearAllMocks();\n  });\n  \n  it('should save preferences to localStorage', () => {\n    const preferences = state({ theme: 'light' });\n    \n    // Create the effect\n    effect(() => {\n      localStorage.setItem('prefs', JSON.stringify(preferences.value));\n    });\n    \n    // Verify initial save\n    expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n      'prefs', \n      JSON.stringify({ theme: 'light' })\n    );\n    \n    // Update preferences\n    preferences.value = { theme: 'dark' };\n    \n    // Verify update was saved\n    expect(mockLocalStorage.setItem).toHaveBeenLastCalledWith(\n      'prefs',\n      JSON.stringify({ theme: 'dark' })\n    );\n  });\n  \n  it('should handle localStorage errors gracefully', () => {\n    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n    mockLocalStorage.setItem.mockImplementation(() => {\n      throw new Error('Storage quota exceeded');\n    });\n    \n    const preferences = state({ theme: 'light' });\n    \n    effect(() => {\n      try {\n        localStorage.setItem('prefs', JSON.stringify(preferences.value));\n      } catch (error) {\n        console.error('Failed to save preferences:', error);\n      }\n    });\n    \n    expect(consoleSpy).toHaveBeenCalledWith(\n      'Failed to save preferences:', \n      expect.any(Error)\n    );\n    \n    consoleSpy.mockRestore();\n  });\n});",
  "effectapicontent16": "import { state, effect, configureDebug } from 'react-understate';\n\n// Enable debugging globally\nconfigureDebug({ enabled: true, showFile: true });\n\nconst count = state(0, 'counter');\nconst user = state(null, 'user');\n\n// Named effects for better debugging\neffect(() => {\n  console.log(`Counter effect: count is ${count.value}`);\n}, 'logCounter');\n\neffect(async ({ signal }) => {\n  if (user.value) {\n    console.log(`User effect: loading data for ${user.value.name}`);\n    // Async operations...\n  }\n}, 'loadUserData', { preventOverlap: true });\n\n// Debug output will show:\n// [effect: logCounter] Effect running\n// [effect: loadUserData] Effect running (async)\n// [effect: loadUserData] Effect completed in 150ms\n\ncount.value = 5;\n// [effect: logCounter] Effect running (triggered by counter)",
  "effectapicontent17": "// ✅ Use derived for computed state\nconst fullName = derived(() => `${firstName.value} ${lastName.value}`);\n\n// ✅ Use effects for side effects\neffect(() => {\n  localStorage.setItem('user', JSON.stringify(user.value));\n});\n\n// ❌ Don't use effects for computations\neffect(() => {\n  fullName.value = `${firstName.value} ${lastName.value}`; // Wrong!\n});\n\n// ❌ Don't use derived for side effects\nconst saveUser = derived(() => {\n  localStorage.setItem('user', JSON.stringify(user.value)); // Wrong!\n  return user.value;\n});",
  "effectapicontent2": "import { state, effect } from 'react-understate';\n\nconst firstName = state('John', 'firstName');\nconst lastName = state('Doe', 'lastName');\nconst title = state('Mr.', 'title');\n\n// Effect automatically tracks all accessed states\neffect(() => {\n  const fullName = `${title.value} ${firstName.value} ${lastName.value}`;\n  console.log(`Full name: ${fullName}`);\n}, 'updateFullName');\n\nfirstName.value = 'Jane'; // Logs: \"Full name: Mr. Jane Doe\"\ntitle.value = 'Ms.';       // Logs: \"Full name: Ms. Jane Doe\"\nlastName.value = 'Smith';  // Logs: \"Full name: Ms. Jane Smith\"",
  "effectapicontent3": "import { state, effect } from 'react-understate';\n\nconst isPolling = state(false, 'isPolling');\nconst data = state(null, 'pollingData');\n\neffect(() => {\n  if (isPolling.value) {\n    console.log('Starting to poll...');\n    \n    const intervalId = setInterval(async () => {\n      try {\n        const response = await fetch('/api/data');\n        data.value = await response.json();\n        console.log('Data updated:', data.value);\n      } catch (error) {\n        console.error('Polling failed:', error);\n      }\n    }, 1000);\n    \n    // Return cleanup function\n    return () => {\n      console.log('Stopping polling');\n      clearInterval(intervalId);\n    };\n  }\n}, 'pollingEffect');\n\nisPolling.value = true;  // Starts polling\nisPolling.value = false; // Stops polling (cleanup runs)",
  "effectapicontent4": "import { state, effect } from 'react-understate';\n\nconst user = state(null, 'user');\n\n// Initialize user session only once\neffect(() => {\n  console.log('Initializing user session...');\n  // This will only run once, even if user changes\n  initializeUserSession();\n  loadUserPreferences();\n}, 'initializeUser', { once: true });\n\n// Setup global event listeners\neffect(() => {\n  const handleResize = () => {\n    console.log('Window resized:', window.innerWidth, window.innerHeight);\n  };\n  \n  const handleKeyPress = (e: KeyboardEvent) => {\n    if (e.ctrlKey && e.key === 'k') {\n      console.log('Search shortcut pressed');\n    }\n  };\n  \n  window.addEventListener('resize', handleResize);\n  window.addEventListener('keydown', handleKeyPress);\n  \n  // Return cleanup function\n  return () => {\n    window.removeEventListener('resize', handleResize);\n    window.removeEventListener('keydown', handleKeyPress);\n  };\n}, 'setupGlobalListeners', { once: true });",
  "effectapicontent5": "import { state, effect } from 'react-understate';\n\nconst searchQuery = state('', 'searchQuery');\nconst searchResults = state([], 'searchResults');\nconst isLoading = state(false, 'isLoading');\n\n// Search effect that prevents overlapping API calls\neffect(async () => {\n  if (!searchQuery.value.trim()) {\n    searchResults.value = [];\n    isLoading.value = false;\n    return;\n  }\n\n  isLoading.value = true;\n  \n  try {\n    const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery.value)}`);\n    const results = await response.json();\n    \n    searchResults.value = results;\n    console.log(`Found ${results.length} results for \"${searchQuery.value}\"`);\n  } catch (error) {\n    console.error('Search failed:', error);\n    searchResults.value = [];\n  } finally {\n    isLoading.value = false;\n  }\n}, 'searchEffect', { preventOverlap: true });\n\n// Multiple rapid changes won't cause overlapping API calls\nsearchQuery.value = 'react';\nsearchQuery.value = 'vue';      // Previous search is cancelled\nsearchQuery.value = 'angular';  // Previous search is cancelled\n// Only the last search ('angular') will complete",
  "effectapicontent6": "import { state, effect } from 'react-understate';\n\nconst inputData = state({ items: [] }, 'inputData');\nconst processedData = state([], 'processedData');\nconst processingLog = state([], 'processingLog');\n\n// Data processing pipeline that re-runs on any change\neffect(() => {\n  const items = inputData.value.items;\n  const currentLog = processingLog.value;\n  \n  // Process the data\n  const processed = items.map(item => ({\n    ...item,\n    processed: true,\n    timestamp: Date.now()\n  }));\n  \n  // Update processed data\n  processedData.value = processed;\n  \n  // Log the processing (this would normally cause a loop)\n  processingLog.value = [\n    ...currentLog,\n    `Processed ${processed.length} items at ${new Date().toISOString()}`\n  ];\n  \n  console.log(`Processing complete: ${processed.length} items`);\n}, 'dataProcessingPipeline', { preventLoops: false });\n\n// This will trigger multiple processing cycles\ninputData.value = { items: [{ id: 1, name: 'Item 1' }] };",
  "effectapicontent7": "import { state, effect } from 'react-understate';\n\nconst userId = state(1, 'userId');\nconst userData = state(null, 'userData');\nconst userPosts = state([], 'userPosts');\nconst isLoading = state(false, 'isLoading');\n\n// Effect with AbortSignal support\neffect(async ({ signal }) => {\n  if (!userId.value) {\n    userData.value = null;\n    userPosts.value = [];\n    return;\n  }\n\n  isLoading.value = true;\n  \n  try {\n    // Fetch user data with cancellation support\n    const userResponse = await fetch(`/api/users/${userId.value}`, { signal });\n    const user = await userResponse.json();\n    userData.value = user;\n    \n    // Fetch user posts with cancellation support\n    const postsResponse = await fetch(`/api/users/${userId.value}/posts`, { signal });\n    const posts = await postsResponse.json();\n    userPosts.value = posts;\n    \n    console.log(`Loaded data for user ${user.name}`);\n    \n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.log('Request was cancelled');\n    } else {\n      console.error('Failed to load user data:', error);\n      userData.value = null;\n      userPosts.value = [];\n    }\n  } finally {\n    isLoading.value = false;\n  }\n}, 'loadUserData', { preventOverlap: true });\n\n// Rapid changes will cancel previous requests\nuserId.value = 2; // Cancels previous request\nuserId.value = 3; // Cancels previous request\nuserId.value = 4; // Only this request will complete",
  "effectapicontent8": "import { state, effect } from 'react-understate';\n\nconst userPreferences = state({\n  theme: 'light',\n  language: 'en',\n  notifications: true,\n  autoSave: true\n}, 'userPreferences');\n\n// Automatically save preferences to localStorage\neffect(() => {\n  const prefs = userPreferences.value;\n  \n  try {\n    localStorage.setItem('userPreferences', JSON.stringify(prefs));\n    console.log('Preferences saved to localStorage');\n  } catch (error) {\n    console.error('Failed to save preferences:', error);\n  }\n}, 'savePreferences');\n\n// Load preferences on initialization\neffect(() => {\n  try {\n    const saved = localStorage.getItem('userPreferences');\n    if (saved) {\n      const parsed = JSON.parse(saved);\n      userPreferences.value = { ...userPreferences.value, ...parsed };\n      console.log('Preferences loaded from localStorage');\n    }\n  } catch (error) {\n    console.error('Failed to load preferences:', error);\n  }\n}, 'loadPreferences', { once: true });\n\n// Usage\nuserPreferences.value = { \n  ...userPreferences.value, \n  theme: 'dark' \n}; // Automatically saves to localStorage",
  "effectapicontent9": "import { state, effect, derived } from 'react-understate';\n\nconst currentPage = state('Home', 'currentPage');\nconst unreadNotifications = state(0, 'unreadNotifications');\nconst userName = state('', 'userName');\n\n// Derived title that combines multiple states\nconst documentTitle = derived(() => {\n  const page = currentPage.value;\n  const unread = unreadNotifications.value;\n  const user = userName.value;\n  \n  let title = page;\n  \n  if (unread > 0) {\n    title = `(${unread}) ${title}`;\n  }\n  \n  if (user) {\n    title += ` - ${user}`;\n  }\n  \n  return title;\n}, 'documentTitle');\n\n// Effect to update document title\neffect(() => {\n  document.title = documentTitle.value;\n  console.log(`Document title updated: ${documentTitle.value}`);\n}, 'updateDocumentTitle');\n\n// Usage\ncurrentPage.value = 'Dashboard'; // Title: \"Dashboard\"\nunreadNotifications.value = 3;   // Title: \"(3) Dashboard\"\nuserName.value = 'John Doe';     // Title: \"(3) Dashboard - John Doe\"",
  "effects": "import { state, effect } from 'react-understate';\n\n// Basic state\nconst count = state(0, { name: 'count' });\nconst isVisible = state(true, { name: 'isVisible' });\n\n// Simple effect\nexport const logCountEffect = effect(() => {\n  console.log('effect: count changed to', count());\n}, { name: 'logCountEffect' });\n\n// Effect with conditional logic\nexport const visibilityEffect = effect(() => {\n  const visible = isVisible();\n  \n  if (visible) {\n    console.log('effect: element is now visible');\n    document.title = `Count: ${count()}`;\n  } else {\n    console.log('effect: element is now hidden');\n    document.title = 'Hidden';\n  }\n}, { name: 'visibilityEffect' });\n\n// Effect with cleanup\nexport const intervalEffect = effect(() => {\n  const interval = setInterval(() => {\n    console.log('effect: interval tick, count is', count());\n  }, 1000);\n  \n  // Cleanup function\n  return () => {\n    console.log('effect: cleaning up interval');\n    clearInterval(interval);\n  };\n}, { name: 'intervalEffect' });",
  "effects2": "// Multiple dependencies\nconst user = state({ id: 1, name: 'John' }, { name: 'user' });\nconst theme = state('light', { name: 'theme' });\nconst language = state('en', { name: 'language' });\n\n// Effect depends on all three\nexport const userPreferencesEffect = effect(() => {\n  const userData = user();\n  const currentTheme = theme();\n  const currentLanguage = language();\n  \n  console.log('effect: user preferences changed', {\n    user: userData.name,\n    theme: currentTheme,\n    language: currentLanguage,\n  });\n  \n  // Apply theme to document\n  document.documentElement.setAttribute('data-theme', currentTheme);\n  \n  // Set language\n  document.documentElement.lang = currentLanguage;\n}, { name: 'userPreferencesEffect' });\n\n// Conditional dependencies\nconst showAdvancedFeatures = state(false, { name: 'showAdvancedFeatures' });\nconst advancedData = state(null, { name: 'advancedData' });\n\nexport const conditionalEffect = effect(() => {\n  const showAdvanced = showAdvancedFeatures();\n  \n  if (showAdvanced) {\n    // Only depends on advancedData when showAdvanced is true\n    const data = advancedData();\n    console.log('effect: processing advanced data', data);\n  } else {\n    console.log('effect: advanced features disabled');\n  }\n}, { name: 'conditionalEffect' });\n\n// Derived dependencies\nconst firstName = state('John', { name: 'firstName' });\nconst lastName = state('Doe', { name: 'lastName' });\n\nconst fullName = derived(() => `${firstName()} ${lastName()}`, {\n  name: 'fullName',\n});\n\nexport const nameEffect = effect(() => {\n  const name = fullName();\n  console.log('effect: full name changed to', name);\n  \n  // This effect will re-run when either firstName or lastName changes\n  // because it depends on the derived fullName\n}, { name: 'nameEffect' });",
  "effects3": "// 1. API synchronization\nconst userId = state<number | null>(null, { name: 'userId' });\nconst userData = state<any>(null, { name: 'userData' });\nconst loading = state(false, { name: 'loading' });\nconst error = state<string | null>(null, { name: 'error' });\n\nexport const userSyncEffect = effect(() => {\n  const id = userId();\n  \n  if (!id) {\n    userData(null);\n    return;\n  }\n  \n  loading(true);\n  error(null);\n  \n  let cancelled = false;\n  \n  fetchUser(id)\n    .then(data => {\n      if (!cancelled) {\n        userData(data);\n        loading(false);\n      }\n    })\n    .catch(err => {\n      if (!cancelled) {\n        error(err.message);\n        loading(false);\n      }\n    });\n  \n  return () => {\n    cancelled = true;\n  };\n}, { name: 'userSyncEffect' });\n\n// 2. Local storage persistence\nconst settings = state({\n  theme: 'light',\n  language: 'en',\n  notifications: true,\n}, { name: 'settings' });\n\nexport const settingsPersistenceEffect = effect(() => {\n  const currentSettings = settings();\n  \n  try {\n    localStorage.setItem('app-settings', JSON.stringify(currentSettings));\n  } catch (error) {\n    console.error('effect: failed to save settings', error);\n  }\n}, { name: 'settingsPersistenceEffect' });\n\n// Load settings on initialization\nexport const loadSettingsEffect = effect(() => {\n  try {\n    const saved = localStorage.getItem('app-settings');\n    if (saved) {\n      const parsed = JSON.parse(saved);\n      settings(parsed);\n    }\n  } catch (error) {\n    console.error('effect: failed to load settings', error);\n  }\n}, { name: 'loadSettingsEffect' });\n\n// 3. Document title updates\nconst pageTitle = state('Home', { name: 'pageTitle' });\nconst unreadCount = state(0, { name: 'unreadCount' });\n\nexport const documentTitleEffect = effect(() => {\n  const title = pageTitle();\n  const unread = unreadCount();\n  \n  const fullTitle = unread > 0 ? `(${unread}) ${title}` : title;\n  document.title = `${fullTitle} - My App`;\n}, { name: 'documentTitleEffect' });\n\n// 4. Analytics tracking\nconst currentPage = state('/', { name: 'currentPage' });\nconst user = state(null, { name: 'user' });\n\nexport const analyticsEffect = effect(() => {\n  const page = currentPage();\n  const userData = user();\n  \n  // Track page views\n  if (typeof gtag !== 'undefined') {\n    gtag('config', 'GA_MEASUREMENT_ID', {\n      page_title: document.title,\n      page_location: window.location.href,\n    });\n  }\n  \n  // Track user events\n  if (userData) {\n    if (typeof gtag !== 'undefined') {\n      gtag('event', 'user_login', {\n        user_id: userData.id,\n      });\n    }\n  }\n}, { name: 'analyticsEffect' });\n\n// 5. WebSocket connections\nconst isConnected = state(false, { name: 'isConnected' });\nconst messages = state<any[]>([], { name: 'messages' });\n\nexport const websocketEffect = effect(() => {\n  const connected = isConnected();\n  \n  if (!connected) return;\n  \n  const ws = new WebSocket('ws://localhost:8080');\n  \n  ws.onopen = () => {\n    console.log('effect: websocket connected');\n  };\n  \n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    messages(prev => [...prev, message]);\n  };\n  \n  ws.onclose = () => {\n    console.log('effect: websocket disconnected');\n    isConnected(false);\n  };\n  \n  ws.onerror = (error) => {\n    console.error('effect: websocket error', error);\n    isConnected(false);\n  };\n  \n  return () => {\n    console.log('effect: closing websocket');\n    ws.close();\n  };\n}, { name: 'websocketEffect' });",
  "effects4": "// 1. Debounced effects\nconst createDebouncedEffect = <T>(\n  computation: () => T,\n  delay: number,\n  name: string\n) => {\n  let timeoutId: number | null = null;\n  \n  return effect(() => {\n    // Clear previous timeout\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    \n    // Set new timeout\n    timeoutId = window.setTimeout(() => {\n      computation();\n      timeoutId = null;\n    }, delay);\n    \n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    };\n  }, { name });\n};\n\n// Usage: Debounced search\nconst searchQuery = state('', { name: 'searchQuery' });\nconst searchResults = state<any[]>([], { name: 'searchResults' });\n\nexport const debouncedSearchEffect = createDebouncedEffect(\n  () => {\n    const query = searchQuery();\n    if (!query.trim()) {\n      searchResults([]);\n      return;\n    }\n    \n    performSearch(query).then(results => {\n      searchResults(results);\n    });\n  },\n  300,\n  'debouncedSearchEffect'\n);\n\n// 2. Effect chains\nconst data = state<any[]>([], { name: 'data' });\nconst filtered = state<any[]>([], { name: 'filtered' });\nconst sorted = state<any[]>([], { name: 'sorted' });\n\n// First effect: filter data\nexport const filterEffect = effect(() => {\n  const items = data();\n  const filteredItems = items.filter(item => item.active);\n  filtered(filteredItems);\n}, { name: 'filterEffect' });\n\n// Second effect: sort filtered data\nexport const sortEffect = effect(() => {\n  const items = filtered();\n  const sortedItems = [...items].sort((a, b) => a.name.localeCompare(b.name));\n  sorted(sortedItems);\n}, { name: 'sortEffect' });",
  "effects5": "// ❌ Bad: State update in effect\nconst count = state(0, { name: 'count' });\n\neffect(() => {\n  if (count.value > 10) {\n    count.value = 0; // This should be in an action\n  }\n}, { name: 'badEffect' });",
  "effects6": "// ✅ Good: State update in action\nconst count = state(0, { name: 'count' });\n\nconst resetCount = action(() => {\n  count.value = 0;\n}, 'resetCount');\n\neffect(() => {\n  if (count.value > 10) {\n    resetCount(); // Call action instead\n  }\n}, { name: 'goodEffect' });",
  "eslint": "npm install --save-dev eslint-plugin-react-understate",
  "eslint2": "{\n  \"extends\": [\"plugin:react-understate/recommended\"]\n}",
  "eslint3": "{\n  \"extends\": [\"plugin:react-understate/recommended\"]\n}",
  "eslint4": "// ❌ Before\nconst count = state(0)\nfunction Counter() {\n  return <div>{count.value}</div>\n}\n\n// ✅ After\nfunction Counter() {\n  useUnderstate(count)\n  return <div>{count.value}</div>\n}",
  "eslint5": "// ❌ Before\nconst count = state(0)\nfunction Counter() {\n  return <div>{count.value}</div>\n}\n\n// ✅ After\nfunction Counter() {\n  useUnderstate(count)\n  return <div>{count.value}</div>\n}",
  "filteringsorting": "import { state, derived, action } from 'react-understate';\n\n// Data types\ntype Todo = {\n  id: string;\n  text: string;\n  completed: boolean;\n  priority: 'low' | 'medium' | 'high';\n  category: string;\n  createdAt: Date;\n};\n\n// State\nconst todos = state<Todo[]>([], { name: 'todos' });\nconst filterText = state('', { name: 'filterText' });\nconst filterCompleted = state<'all' | 'active' | 'completed'>('all', { name: 'filterCompleted' });\nconst filterCategory = state<string>('all', { name: 'filterCategory' });\n\n// Derived filtered todos\nexport const filteredTodos = derived(() => {\n  const allTodos = todos();\n  const text = filterText().toLowerCase();\n  const completed = filterCompleted();\n  const category = filterCategory();\n  \n  return allTodos.filter(todo => {\n    // Text filter\n    if (text && !todo.text.toLowerCase().includes(text)) {\n      return false;\n    }\n    \n    // Completion filter\n    if (completed === 'active' && todo.completed) return false;\n    if (completed === 'completed' && !todo.completed) return false;\n    \n    // Category filter\n    if (category !== 'all' && todo.category !== category) {\n      return false;\n    }\n    \n    return true;\n  });\n}, { name: 'filteredTodos' });\n\n// Actions for updating filters\nexport const setFilterText = action((text: string) => {\n  console.log('action: setting filter text', text);\n  filterText(text);\n}, { name: 'setFilterText' });\n\nexport const setFilterCompleted = action((filter: 'all' | 'active' | 'completed') => {\n  console.log('action: setting completed filter', filter);\n  filterCompleted(filter);\n}, { name: 'setFilterCompleted' });\n\nexport const setFilterCategory = action((category: string) => {\n  console.log('action: setting category filter', category);\n  filterCategory(category);\n}, { name: 'setFilterCategory' });\n\nexport const clearFilters = action(() => {\n  console.log('action: clearing all filters');\n  filterText('');\n  filterCompleted('all');\n  filterCategory('all');\n}, { name: 'clearFilters' });",
  "filteringsorting2": "// Sorting state\nconst sortField = state<keyof Todo>('createdAt', { name: 'sortField' });\nconst sortDirection = state<'asc' | 'desc'>('desc', { name: 'sortDirection' });\nconst sortPriority = state<number>(0, { name: 'sortPriority' }); // For multi-column sorting\n\n// Sort configuration\nconst sortConfig = {\n  text: (a: Todo, b: Todo) => a.text.localeCompare(b.text),\n  createdAt: (a: Todo, b: Todo) => a.createdAt.getTime() - b.createdAt.getTime(),\n  priority: (a: Todo, b: Todo) => {\n    const priorityOrder = { high: 3, medium: 2, low: 1 };\n    return priorityOrder[a.priority] - priorityOrder[b.priority];\n  },\n  category: (a: Todo, b: Todo) => a.category.localeCompare(b.category),\n};\n\n// Derived sorted todos\nexport const sortedTodos = derived(() => {\n  const filtered = filteredTodos();\n  const field = sortField();\n  const direction = sortDirection();\n  \n  const sorted = [...filtered].sort((a, b) => {\n    const result = sortConfig[field](a, b);\n    return direction === 'asc' ? result : -result;\n  });\n  \n  return sorted;\n}, { name: 'sortedTodos' });\n\n// Multi-column sorting\nexport const multiColumnSortedTodos = derived(() => {\n  const filtered = filteredTodos();\n  const primaryField = sortField();\n  const primaryDirection = sortDirection();\n  const secondaryField = sortPriority() > 0 ? 'priority' : null;\n  \n  return [...filtered].sort((a, b) => {\n    // Primary sort\n    let result = sortConfig[primaryField](a, b);\n    if (primaryDirection === 'desc') result = -result;\n    \n    // Secondary sort if primary values are equal\n    if (result === 0 && secondaryField) {\n      result = sortConfig[secondaryField](a, b);\n    }\n    \n    return result;\n  });\n}, { name: 'multiColumnSortedTodos' });\n\n// Sorting actions\nexport const setSortField = action((field: keyof Todo) => {\n  console.log('action: setting sort field', field);\n  \n  // Toggle direction if same field\n  if (sortField() === field) {\n    sortDirection(prev => prev === 'asc' ? 'desc' : 'asc');\n  } else {\n    sortField(field);\n    sortDirection('asc');\n  }\n}, { name: 'setSortField' });\n\nexport const setSortDirection = action((direction: 'asc' | 'desc') => {\n  console.log('action: setting sort direction', direction);\n  sortDirection(direction);\n}, { name: 'setSortDirection' });\n\nexport const resetSorting = action(() => {\n  console.log('action: resetting sorting');\n  sortField('createdAt');\n  sortDirection('desc');\n  sortPriority(0);\n}, { name: 'resetSorting' });",
  "filteringsorting3": "// Search and pagination state\nconst searchQuery = state('', { name: 'searchQuery' });\nconst currentPage = state(1, { name: 'currentPage' });\nconst itemsPerPage = state(10, { name: 'itemsPerPage' });\n\n// Debounced search\nlet searchTimeout: number | null = null;\nexport const debouncedSearch = action((query: string) => {\n  console.log('action: debounced search', query);\n  \n  if (searchTimeout) {\n    clearTimeout(searchTimeout);\n  }\n  \n  searchTimeout = window.setTimeout(() => {\n    searchQuery(query);\n    currentPage(1); // Reset to first page on search\n  }, 300);\n}, { name: 'debouncedSearch' });\n\n// Search results\nexport const searchResults = derived(() => {\n  const allTodos = todos();\n  const query = searchQuery().toLowerCase();\n  \n  if (!query) return allTodos;\n  \n  return allTodos.filter(todo => \n    todo.text.toLowerCase().includes(query) ||\n    todo.category.toLowerCase().includes(query)\n  );\n}, { name: 'searchResults' });\n\n// Combined filtered and searched results\nexport const filteredAndSearchedTodos = derived(() => {\n  const searched = searchResults();\n  const text = filterText().toLowerCase();\n  const completed = filterCompleted();\n  const category = filterCategory();\n  \n  return searched.filter(todo => {\n    if (text && !todo.text.toLowerCase().includes(text)) return false;\n    if (completed === 'active' && todo.completed) return false;\n    if (completed === 'completed' && !todo.completed) return false;\n    if (category !== 'all' && todo.category !== category) return false;\n    return true;\n  });\n}, { name: 'filteredAndSearchedTodos' });\n\n// Pagination\nexport const paginatedTodos = derived(() => {\n  const filtered = filteredAndSearchedTodos();\n  const page = currentPage();\n  const perPage = itemsPerPage();\n  \n  const startIndex = (page - 1) * perPage;\n  const endIndex = startIndex + perPage;\n  \n  return filtered.slice(startIndex, endIndex);\n}, { name: 'paginatedTodos' });\n\n// Pagination info\nexport const paginationInfo = derived(() => {\n  const filtered = filteredAndSearchedTodos();\n  const page = currentPage();\n  const perPage = itemsPerPage();\n  \n  const totalItems = filtered.length;\n  const totalPages = Math.ceil(totalItems / perPage);\n  const startIndex = (page - 1) * perPage + 1;\n  const endIndex = Math.min(page * perPage, totalItems);\n  \n  return {\n    totalItems,\n    totalPages,\n    currentPage: page,\n    itemsPerPage: perPage,\n    startIndex,\n    endIndex,\n    hasNextPage: page < totalPages,\n    hasPrevPage: page > 1,\n  };\n}, { name: 'paginationInfo' });\n\n// Pagination actions\nexport const setPage = action((page: number) => {\n  console.log('action: setting page', page);\n  const info = paginationInfo();\n  \n  if (page >= 1 && page <= info.totalPages) {\n    currentPage(page);\n  }\n}, { name: 'setPage' });\n\nexport const nextPage = action(() => {\n  console.log('action: next page');\n  const info = paginationInfo();\n  if (info.hasNextPage) {\n    currentPage(prev => prev + 1);\n  }\n}, { name: 'nextPage' });\n\nexport const prevPage = action(() => {\n  console.log('action: previous page');\n  const info = paginationInfo();\n  if (info.hasPrevPage) {\n    currentPage(prev => prev - 1);\n  }\n}, { name: 'prevPage' });\n\nexport const setItemsPerPage = action((perPage: number) => {\n  console.log('action: setting items per page', perPage);\n  itemsPerPage(perPage);\n  currentPage(1); // Reset to first page\n}, { name: 'setItemsPerPage' });",
  "filteringsorting4": "// Range filtering\nconst dateRange = state<{ start: Date | null; end: Date | null }>({\n  start: null,\n  end: null,\n}, { name: 'dateRange' });\n\nconst priorityRange = state<{ min: number; max: number }>({\n  min: 1,\n  max: 3,\n}, { name: 'priorityRange' });\n\n// Tag-based filtering\nconst selectedTags = state<string[]>([], { name: 'selectedTags' });\nconst availableTags = derived(() => {\n  const allTodos = todos();\n  const tags = new Set<string>();\n  \n  allTodos.forEach(todo => {\n    if (todo.tags) {\n      todo.tags.forEach(tag => tags.add(tag));\n    }\n  });\n  \n  return Array.from(tags).sort();\n}, { name: 'availableTags' });\n\n// Advanced filtered todos\nexport const advancedFilteredTodos = derived(() => {\n  const allTodos = todos();\n  const text = filterText().toLowerCase();\n  const completed = filterCompleted();\n  const category = filterCategory();\n  const dateRangeValue = dateRange();\n  const priorityRangeValue = priorityRange();\n  const tags = selectedTags();\n  \n  return allTodos.filter(todo => {\n    // Text filter\n    if (text && !todo.text.toLowerCase().includes(text)) return false;\n    \n    // Completion filter\n    if (completed === 'active' && todo.completed) return false;\n    if (completed === 'completed' && !todo.completed) return false;\n    \n    // Category filter\n    if (category !== 'all' && todo.category !== category) return false;\n    \n    // Date range filter\n    if (dateRangeValue.start && todo.createdAt < dateRangeValue.start) return false;\n    if (dateRangeValue.end && todo.createdAt > dateRangeValue.end) return false;\n    \n    // Priority range filter\n    const priorityOrder = { high: 3, medium: 2, low: 1 };\n    const todoPriority = priorityOrder[todo.priority];\n    if (todoPriority < priorityRangeValue.min || todoPriority > priorityRangeValue.max) {\n      return false;\n    }\n    \n    // Tag filter\n    if (tags.length > 0 && todo.tags) {\n      const hasMatchingTag = tags.some(tag => todo.tags!.includes(tag));\n      if (!hasMatchingTag) return false;\n    }\n    \n    return true;\n  });\n}, { name: 'advancedFilteredTodos' });\n\n// Filter actions\nexport const setDateRange = action((start: Date | null, end: Date | null) => {\n  console.log('action: setting date range', { start, end });\n  dateRange({ start, end });\n}, { name: 'setDateRange' });\n\nexport const setPriorityRange = action((min: number, max: number) => {\n  console.log('action: setting priority range', { min, max });\n  priorityRange({ min, max });\n}, { name: 'setPriorityRange' });\n\nexport const toggleTag = action((tag: string) => {\n  console.log('action: toggling tag', tag);\n  selectedTags(prev => \n    prev.includes(tag) \n      ? prev.filter(t => t !== tag)\n      : [...prev, tag]\n  );\n}, { name: 'toggleTag' });\n\nexport const selectAllTags = action(() => {\n  console.log('action: selecting all tags');\n  const tags = availableTags();\n  selectedTags(tags);\n}, { name: 'selectAllTags' });\n\nexport const clearAllTags = action(() => {\n  console.log('action: clearing all tags');\n  selectedTags([]);\n}, { name: 'clearAllTags' });",
  "filteringsorting5": "// Memoized filtering for expensive operations\nconst createMemoizedFilter = <T>(\n  items: () => T[],\n  filterFn: (item: T) => boolean,\n  name: string\n) => {\n  let lastItems: T[] = [];\n  let lastFiltered: T[] = [];\n  let lastFilterHash = '';\n  \n  return derived(() => {\n    const currentItems = items();\n    const currentFilterHash = JSON.stringify(filterFn);\n    \n    // Check if we can use cached result\n    if (currentItems === lastItems && currentFilterHash === lastFilterHash) {\n      return lastFiltered;\n    }\n    \n    // Recalculate\n    const filtered = currentItems.filter(filterFn);\n    \n    // Update cache\n    lastItems = currentItems;\n    lastFiltered = filtered;\n    lastFilterHash = currentFilterHash;\n    \n    return filtered;\n  }, { name });\n};\n\n// Usage\nexport const memoizedFilteredTodos = createMemoizedFilter(\n  () => todos(),\n  (todo) => {\n    const text = filterText().toLowerCase();\n    const completed = filterCompleted();\n    \n    if (text && !todo.text.toLowerCase().includes(text)) return false;\n    if (completed === 'active' && todo.completed) return false;\n    if (completed === 'completed' && !todo.completed) return false;\n    \n    return true;\n  },\n  'memoizedFilteredTodos'\n);\n\n// Virtual scrolling for large lists\nexport const createVirtualList = <T>(\n  items: () => T[],\n  itemHeight: number,\n  containerHeight: number,\n  name: string\n) => {\n  const scrollTop = state(0, { name: `${name}ScrollTop` });\n  \n  const visibleItems = derived(() => {\n    const allItems = items();\n    const scroll = scrollTop();\n    \n    const startIndex = Math.floor(scroll / itemHeight);\n    const endIndex = Math.min(\n      startIndex + Math.ceil(containerHeight / itemHeight) + 1,\n      allItems.length\n    );\n    \n    return allItems.slice(startIndex, endIndex).map((item, index) => ({\n      item,\n      index: startIndex + index,\n    }));\n  }, { name: `${name}VisibleItems` });\n  \n  const totalHeight = derived(() => items().length * itemHeight, {\n    name: `${name}TotalHeight`\n  });\n  \n  return {\n    scrollTop,\n    visibleItems,\n    totalHeight,\n    setScrollTop: action((top: number) => {\n      scrollTop(Math.max(0, top));\n    }, { name: `set${name}ScrollTop` }),\n  };\n};\n\n// Usage\nconst virtualList = createVirtualList(\n  () => sortedTodos(),\n  50, // item height\n  400, // container height\n  'todos'\n);\n\n// Debounced filtering for search\nexport const createDebouncedFilter = <T>(\n  items: () => T[],\n  searchQuery: () => string,\n  filterFn: (item: T, query: string) => boolean,\n  delay: number,\n  name: string\n) => {\n  const debouncedQuery = state('', { name: `${name}DebouncedQuery` });\n  let timeoutId: number | null = null;\n  \n  // Debounce search query\n  const debounceSearch = action((query: string) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    \n    timeoutId = window.setTimeout(() => {\n      debouncedQuery(query);\n      timeoutId = null;\n    }, delay);\n  }, { name: `debounce${name}Search` });\n  \n  // Filtered items\n  const filteredItems = derived(() => {\n    const allItems = items();\n    const query = debouncedQuery();\n    \n    if (!query) return allItems;\n    \n    return allItems.filter(item => filterFn(item, query));\n  }, { name: `${name}FilteredItems` });\n  \n  return {\n    debouncedQuery,\n    filteredItems,\n    debounceSearch,\n  };\n};\n\n// Usage\nconst debouncedSearch = createDebouncedFilter(\n  () => todos(),\n  () => searchQuery(),\n  (todo, query) => todo.text.toLowerCase().includes(query.toLowerCase()),\n  300,\n  'todos'\n);",
  "filteringsorting6": "import React from 'react';\nimport { useUnderstate } from 'react-understate';\nimport {\n  filteredTodos,\n  sortedTodos,\n  paginatedTodos,\n  paginationInfo,\n  setFilterText,\n  setFilterCompleted,\n  setSortField,\n  setPage,\n  nextPage,\n  prevPage,\n} from './todoStore';\n\nfunction TodoList() {\n  const todos = useUnderstate(paginatedTodos);\n  const pagination = useUnderstate(paginationInfo);\n  const filterText = useUnderstate(filterText);\n  const filterCompleted = useUnderstate(filterCompleted);\n  const sortField = useUnderstate(sortField);\n\n  return (\n    <div>\n      {/* Filters */}\n      <div className=\"filters\">\n        <input\n          type=\"text\"\n          placeholder=\"Search todos...\"\n          value={filterText}\n          onChange={(e) => setFilterText(e.target.value)}\n        />\n        \n        <select\n          value={filterCompleted}\n          onChange={(e) => setFilterCompleted(e.target.value as any)}\n        >\n          <option value=\"all\">All</option>\n          <option value=\"active\">Active</option>\n          <option value=\"completed\">Completed</option>\n        </select>\n      </div>\n\n      {/* Sort controls */}\n      <div className=\"sort-controls\">\n        <button onClick={() => setSortField('text')}>\n          Sort by Text {sortField === 'text' ? '↑' : ''}\n        </button>\n        <button onClick={() => setSortField('createdAt')}>\n          Sort by Date {sortField === 'createdAt' ? '↑' : ''}\n        </button>\n        <button onClick={() => setSortField('priority')}>\n          Sort by Priority {sortField === 'priority' ? '↑' : ''}\n        </button>\n      </div>\n\n      {/* Todo list */}\n      <div className=\"todo-list\">\n        {todos.map(todo => (\n          <div key={todo.id} className=\"todo-item\">\n            <span className={todo.completed ? 'completed' : ''}>\n              {todo.text}\n            </span>\n            <span className=\"priority\">{todo.priority}</span>\n            <span className=\"category\">{todo.category}</span>\n          </div>\n        ))}\n      </div>\n\n      {/* Pagination */}\n      <div className=\"pagination\">\n        <button \n          onClick={prevPage} \n          disabled={!pagination.hasPrevPage}\n        >\n          Previous\n        </button>\n        \n        <span>\n          Page {pagination.currentPage} of {pagination.totalPages}\n          ({pagination.startIndex}-{pagination.endIndex} of {pagination.totalItems})\n        </span>\n        \n        <button \n          onClick={nextPage} \n          disabled={!pagination.hasNextPage}\n        >\n          Next\n        </button>\n      </div>\n    </div>\n  );\n}\n\n// Advanced filtering component\nfunction AdvancedFilters() {\n  const selectedTags = useUnderstate(selectedTags);\n  const availableTags = useUnderstate(availableTags);\n  const dateRange = useUnderstate(dateRange);\n  const priorityRange = useUnderstate(priorityRange);\n\n  return (\n    <div className=\"advanced-filters\">\n      {/* Tag filters */}\n      <div className=\"tag-filters\">\n        <h3>Tags</h3>\n        {availableTags.map(tag => (\n          <label key={tag}>\n            <input\n              type=\"checkbox\"\n              checked={selectedTags.includes(tag)}\n              onChange={() => toggleTag(tag)}\n            />\n            {tag}\n          </label>\n        ))}\n      </div>\n\n      {/* Date range */}\n      <div className=\"date-range\">\n        <h3>Date Range</h3>\n        <input\n          type=\"date\"\n          value={dateRange.start?.toISOString().split('T')[0] || ''}\n          onChange={(e) => setDateRange(\n            e.target.value ? new Date(e.target.value) : null,\n            dateRange.end\n          )}\n        />\n        <input\n          type=\"date\"\n          value={dateRange.end?.toISOString().split('T')[0] || ''}\n          onChange={(e) => setDateRange(\n            dateRange.start,\n            e.target.value ? new Date(e.target.value) : null\n          )}\n        />\n      </div>\n\n      {/* Priority range */}\n      <div className=\"priority-range\">\n        <h3>Priority Range</h3>\n        <input\n          type=\"range\"\n          min=\"1\"\n          max=\"3\"\n          value={priorityRange.min}\n          onChange={(e) => setPriorityRange(\n            parseInt(e.target.value),\n            priorityRange.max\n          )}\n        />\n        <input\n          type=\"range\"\n          min=\"1\"\n          max=\"3\"\n          value={priorityRange.max}\n          onChange={(e) => setPriorityRange(\n            priorityRange.min,\n            parseInt(e.target.value)\n          )}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport { TodoList, AdvancedFilters };",
  "formvalidation": "import { state, derived, action } from 'react-understate';\n\n// Form state\nconst formData = state({\n  email: '',\n  password: '',\n  confirmPassword: '',\n  name: '',\n  age: '',\n}, { name: 'formData' });\n\nconst touched = state({\n  email: false,\n  password: false,\n  confirmPassword: false,\n  name: false,\n  age: false,\n}, { name: 'touched' });\n\nconst errors = state({\n  email: '',\n  password: '',\n  confirmPassword: '',\n  name: '',\n  age: '',\n}, { name: 'errors' });\n\n// Validation rules\nconst validationRules = {\n  email: (value: string) => {\n    if (!value) return 'Email is required';\n    if (!/^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/.test(value)) {\n      return 'Invalid email format';\n    }\n    return '';\n  },\n  \n  password: (value: string) => {\n    if (!value) return 'Password is required';\n    if (value.length < 8) return 'Password must be at least 8 characters';\n    if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)/.test(value)) {\n      return 'Password must contain uppercase, lowercase, and number';\n    }\n    return '';\n  },\n  \n  confirmPassword: (value: string) => {\n    const password = formData().password;\n    if (!value) return 'Please confirm your password';\n    if (value !== password) return 'Passwords do not match';\n    return '';\n  },\n  \n  name: (value: string) => {\n    if (!value) return 'Name is required';\n    if (value.length < 2) return 'Name must be at least 2 characters';\n    return '';\n  },\n  \n  age: (value: string) => {\n    if (!value) return 'Age is required';\n    const age = parseInt(value);\n    if (isNaN(age) || age < 18 || age > 120) {\n      return 'Age must be between 18 and 120';\n    }\n    return '';\n  },\n};\n\n// Derived validation state\nexport const fieldErrors = derived(() => {\n  const data = formData();\n  const touchedFields = touched();\n  \n  const fieldErrors: Record<string, string> = {};\n  \n  Object.keys(data).forEach(field => {\n    const value = data[field as keyof typeof data];\n    const isTouched = touchedFields[field as keyof typeof touchedFields];\n    \n    if (isTouched) {\n      const rule = validationRules[field as keyof typeof validationRules];\n      fieldErrors[field] = rule ? rule(value) : '';\n    }\n  });\n  \n  return fieldErrors;\n}, { name: 'fieldErrors' });\n\nexport const isFormValid = derived(() => {\n  const data = formData();\n  const fieldErrorsValue = fieldErrors();\n  \n  return Object.keys(data).every(field => {\n    const value = data[field as keyof typeof data];\n    const error = fieldErrorsValue[field];\n    return value && !error;\n  });\n}, { name: 'isFormValid' });\n\nexport const isFormDirty = derived(() => {\n  const data = formData();\n  return Object.values(data).some(value => value !== '');\n}, { name: 'isFormDirty' });\n\n// Actions\nexport const setFieldValue = action((field: string, value: string) => {\n  console.log('action: setting field value', field, value);\n  formData(prev => ({ ...prev, [field]: value }));\n}, { name: 'setFieldValue' });\n\nexport const setFieldTouched = action((field: string, isTouched: boolean = true) => {\n  console.log('action: setting field touched', field, isTouched);\n  touched(prev => ({ ...prev, [field]: isTouched }));\n}, { name: 'setFieldTouched' });\n\nexport const validateField = action((field: string) => {\n  console.log('action: validating field', field);\n  const data = formData();\n  const value = data[field as keyof typeof data];\n  const rule = validationRules[field as keyof typeof validationRules];\n  \n  if (rule) {\n    const error = rule(value);\n    errors(prev => ({ ...prev, [field]: error }));\n  }\n}, { name: 'validateField' });\n\nexport const validateForm = action(() => {\n  console.log('action: validating entire form');\n  const data = formData();\n  \n  Object.keys(data).forEach(field => {\n    validateField(field);\n  });\n}, { name: 'validateForm' });\n\nexport const resetForm = action(() => {\n  console.log('action: resetting form');\n  formData({\n    email: '',\n    password: '',\n    confirmPassword: '',\n    name: '',\n    age: '',\n  });\n  touched({\n    email: false,\n    password: false,\n    confirmPassword: false,\n    name: false,\n    age: false,\n  });\n  errors({\n    email: '',\n    password: '',\n    confirmPassword: '',\n    name: '',\n    age: '',\n  });\n}, { name: 'resetForm' });",
  "formvalidation2": "// Async validation\nconst asyncValidationState = state({\n  email: { validating: false, error: '' },\n  username: { validating: false, error: '' },\n}, { name: 'asyncValidationState' });\n\nexport const validateEmailAsync = action(async (email: string) => {\n  console.log('action: validating email async', email);\n  \n  if (!email) return;\n  \n  asyncValidationState(prev => ({\n    ...prev,\n    email: { validating: true, error: '' },\n  }));\n  \n  try {\n    const response = await fetch(`/api/validate-email?email=${encodeURIComponent(email)}`);\n    const result = await response.json();\n    \n    if (!result.available) {\n      asyncValidationState(prev => ({\n        ...prev,\n        email: { validating: false, error: 'Email is already taken' },\n      }));\n    } else {\n      asyncValidationState(prev => ({\n        ...prev,\n        email: { validating: false, error: '' },\n      }));\n    }\n  } catch (error) {\n    asyncValidationState(prev => ({\n      ...prev,\n      email: { validating: false, error: 'Validation failed' },\n    }));\n  }\n}, { name: 'validateEmailAsync' });\n\n// Debounced validation\nlet validationTimeout: number | null = null;\n\nexport const debouncedValidation = action((field: string, value: string) => {\n  console.log('action: debounced validation', field, value);\n  \n  if (validationTimeout) {\n    clearTimeout(validationTimeout);\n  }\n  \n  validationTimeout = window.setTimeout(() => {\n    if (field === 'email') {\n      validateEmailAsync(value);\n    } else {\n      validateField(field);\n    }\n  }, 500);\n}, { name: 'debouncedValidation' });\n\n// Cross-field validation\nexport const crossFieldValidation = derived(() => {\n  const data = formData();\n  const errors: Record<string, string> = {};\n  \n  // Password confirmation\n  if (data.password && data.confirmPassword && data.password !== data.confirmPassword) {\n    errors.confirmPassword = 'Passwords do not match';\n  }\n  \n  // Age and email domain validation\n  if (data.age && data.email) {\n    const age = parseInt(data.age);\n    const emailDomain = data.email.split('@')[1];\n    \n    if (age < 18 && emailDomain === 'company.com') {\n      errors.email = 'Company email requires age 18+';\n    }\n  }\n  \n  return errors;\n}, { name: 'crossFieldValidation' });\n\n// Conditional validation\nexport const conditionalValidation = derived(() => {\n  const data = formData();\n  const errors: Record<string, string> = {};\n  \n  // Only validate phone if user wants notifications\n  if (data.wantNotifications && !data.phone) {\n    errors.phone = 'Phone number required for notifications';\n  }\n  \n  // Only validate company if user is employed\n  if (data.employmentStatus === 'employed' && !data.company) {\n    errors.company = 'Company name required for employed users';\n  }\n  \n  return errors;\n}, { name: 'conditionalValidation' });",
  "formvalidation3": "// Form submission state\nconst submissionState = state({\n  isSubmitting: false,\n  isSubmitted: false,\n  submitError: '',\n  submitSuccess: false,\n}, { name: 'submissionState' });\n\n// Form submission\nexport const submitForm = action(async () => {\n  console.log('action: submitting form');\n  \n  // Validate form first\n  validateForm();\n  \n  const isValid = isFormValid();\n  if (!isValid) {\n    console.log('action: form is invalid, not submitting');\n    return;\n  }\n  \n  submissionState(prev => ({\n    ...prev,\n    isSubmitting: true,\n    submitError: '',\n  }));\n  \n  try {\n    const data = formData();\n    const response = await fetch('/api/submit-form', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    const result = await response.json();\n    \n    submissionState(prev => ({\n      ...prev,\n      isSubmitting: false,\n      isSubmitted: true,\n      submitSuccess: true,\n    }));\n    \n    // Reset form on success\n    resetForm();\n    \n  } catch (error) {\n    submissionState(prev => ({\n      ...prev,\n      isSubmitting: false,\n      submitError: error instanceof Error ? error.message : 'Submission failed',\n    }));\n  }\n}, { name: 'submitForm' });\n\n// Form reset with confirmation\nexport const resetFormWithConfirmation = action(() => {\n  console.log('action: resetting form with confirmation');\n  \n  if (isFormDirty()) {\n    const confirmed = window.confirm(\n      'You have unsaved changes. Are you sure you want to reset the form?'\n    );\n    \n    if (!confirmed) return;\n  }\n  \n  resetForm();\n  submissionState({\n    isSubmitting: false,\n    isSubmitted: false,\n    submitError: '',\n    submitSuccess: false,\n  });\n}, { name: 'resetFormWithConfirmation' });\n\n// Auto-save functionality\nlet autoSaveTimeout: number | null = null;\n\nexport const autoSave = action(() => {\n  console.log('action: auto-saving form');\n  \n  if (autoSaveTimeout) {\n    clearTimeout(autoSaveTimeout);\n  }\n  \n  autoSaveTimeout = window.setTimeout(async () => {\n    if (isFormDirty() && !isFormValid()) {\n      // Don't auto-save invalid forms\n      return;\n    }\n    \n    try {\n      const data = formData();\n      await fetch('/api/auto-save', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n      });\n      \n      console.log('action: form auto-saved');\n    } catch (error) {\n      console.error('action: auto-save failed', error);\n    }\n  }, 2000); // Auto-save after 2 seconds of inactivity\n}, { name: 'autoSave' });",
  "formvalidation4": "// Validation utility functions\nexport const validators = {\n  required: (value: string) => value ? '' : 'This field is required',\n  \n  minLength: (min: number) => (value: string) =>\n    value.length >= min ? '' : `Must be at least ${min} characters`,\n  \n  maxLength: (max: number) => (value: string) =>\n    value.length <= max ? '' : `Must be no more than ${max} characters`,\n  \n  email: (value: string) => {\n    if (!value) return '';\n    const emailRegex = /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/;\n    return emailRegex.test(value) ? '' : 'Invalid email format';\n  },\n  \n  phone: (value: string) => {\n    if (!value) return '';\n    const phoneRegex = /^\\\\+?[1-9]\\\\d{1,14}$/;\n    return phoneRegex.test(value.replace(/[\\\\s-()]/g, '')) ? '' : 'Invalid phone number';\n  },\n  \n  url: (value: string) => {\n    if (!value) return '';\n    try {\n      new URL(value);\n      return '';\n    } catch {\n      return 'Invalid URL format';\n    }\n  },\n  \n  numeric: (value: string) => {\n    if (!value) return '';\n    return !isNaN(Number(value)) ? '' : 'Must be a number';\n  },\n  \n  range: (min: number, max: number) => (value: string) => {\n    if (!value) return '';\n    const num = Number(value);\n    return num >= min && num <= max ? '' : `Must be between ${min} and ${max}`,\n  },\n  \n  pattern: (regex: RegExp, message: string) => (value: string) =>\n    regex.test(value) ? '' : message,\n  \n  custom: (fn: (value: string) => string | Promise<string>) => fn,\n};\n\n// Form validation factory\nexport const createFormValidation = <T extends Record<string, any>>(\n  initialValues: T,\n  validationSchema: Record<keyof T, (value: any) => string | Promise<string>>\n) => {\n  const values = state(initialValues, { name: 'formValues' });\n  const touched = state(\n    Object.keys(initialValues).reduce((acc, key) => ({ ...acc, [key]: false }), {} as Record<keyof T, boolean>),\n    { name: 'formTouched' }\n  );\n  const errors = state(\n    Object.keys(initialValues).reduce((acc, key) => ({ ...acc, [key]: '' }), {} as Record<keyof T, string>),\n    { name: 'formErrors' }\n  );\n  \n  const fieldErrors = derived(() => {\n    const currentValues = values();\n    const touchedFields = touched();\n    const errors: Record<keyof T, string> = {} as any;\n    \n    Object.keys(currentValues).forEach(field => {\n      const value = currentValues[field];\n      const isTouched = touchedFields[field];\n      \n      if (isTouched) {\n        const validator = validationSchema[field];\n        if (validator) {\n          const result = validator(value);\n          if (typeof result === 'string') {\n            errors[field] = result;\n          }\n        }\n      }\n    });\n    \n    return errors;\n  }, { name: 'fieldErrors' });\n  \n  const isValid = derived(() => {\n    const fieldErrorsValue = fieldErrors();\n    return Object.values(fieldErrorsValue).every(error => !error);\n  }, { name: 'isValid' });\n  \n  const setFieldValue = action((field: keyof T, value: any) => {\n    values(prev => ({ ...prev, [field]: value }));\n  }, { name: 'setFieldValue' });\n  \n  const setFieldTouched = action((field: keyof T, isTouched: boolean = true) => {\n    touched(prev => ({ ...prev, [field]: isTouched }));\n  }, { name: 'setFieldTouched' });\n  \n  const validateField = action(async (field: keyof T) => {\n    const value = values()[field];\n    const validator = validationSchema[field];\n    \n    if (validator) {\n      const result = await validator(value);\n      errors(prev => ({ ...prev, [field]: result }));\n    }\n  }, { name: 'validateField' });\n  \n  const reset = action(() => {\n    values(initialValues);\n    touched(Object.keys(initialValues).reduce((acc, key) => ({ ...acc, [key]: false }), {} as Record<keyof T, boolean>));\n    errors(Object.keys(initialValues).reduce((acc, key) => ({ ...acc, [key]: '' }), {} as Record<keyof T, string>));\n  }, { name: 'reset' });\n  \n  return {\n    values,\n    touched,\n    errors,\n    fieldErrors,\n    isValid,\n    setFieldValue,\n    setFieldTouched,\n    validateField,\n    reset,\n  };\n};\n\n// Usage example\nconst userForm = createFormValidation(\n  {\n    name: '',\n    email: '',\n    age: '',\n  },\n  {\n    name: validators.required,\n    email: validators.email,\n    age: validators.custom((value) => {\n      const age = parseInt(value);\n      if (isNaN(age)) return 'Must be a number';\n      if (age < 18) return 'Must be 18 or older';\n      if (age > 120) return 'Must be 120 or younger';\n      return '';\n    }),\n  }\n);",
  "formvalidation5": "import React from 'react';\nimport { useUnderstate } from 'react-understate';\nimport {\n  formData,\n  fieldErrors,\n  isFormValid,\n  isFormDirty,\n  submissionState,\n  setFieldValue,\n  setFieldTouched,\n  submitForm,\n  resetForm,\n} from './formStore';\n\nfunction ContactForm() {\n  const form = useUnderstate(formData);\n  const errors = useUnderstate(fieldErrors);\n  const isValid = useUnderstate(isFormValid);\n  const isDirty = useUnderstate(isFormDirty);\n  const submission = useUnderstate(submissionState);\n\n  const handleFieldChange = (field: string, value: string) => {\n    setFieldValue(field, value);\n    setFieldTouched(field, true);\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    submitForm();\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"contact-form\">\n      <h2>Contact Form</h2>\n      \n      {/* Name field */}\n      <div className=\"form-field\">\n        <label htmlFor=\"name\">Name *</label>\n        <input\n          id=\"name\"\n          type=\"text\"\n          value={form.name}\n          onChange={(e) => handleFieldChange('name', e.target.value)}\n          onBlur={() => setFieldTouched('name', true)}\n          className={errors.name ? 'error' : ''}\n        />\n        {errors.name && <span className=\"error-message\">{errors.name}</span>}\n      </div>\n\n      {/* Email field */}\n      <div className=\"form-field\">\n        <label htmlFor=\"email\">Email *</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          value={form.email}\n          onChange={(e) => handleFieldChange('email', e.target.value)}\n          onBlur={() => setFieldTouched('email', true)}\n          className={errors.email ? 'error' : ''}\n        />\n        {errors.email && <span className=\"error-message\">{errors.email}</span>}\n      </div>\n\n      {/* Password field */}\n      <div className=\"form-field\">\n        <label htmlFor=\"password\">Password *</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={form.password}\n          onChange={(e) => handleFieldChange('password', e.target.value)}\n          onBlur={() => setFieldTouched('password', true)}\n          className={errors.password ? 'error' : ''}\n        />\n        {errors.password && <span className=\"error-message\">{errors.password}</span>}\n      </div>\n\n      {/* Confirm Password field */}\n      <div className=\"form-field\">\n        <label htmlFor=\"confirmPassword\">Confirm Password *</label>\n        <input\n          id=\"confirmPassword\"\n          type=\"password\"\n          value={form.confirmPassword}\n          onChange={(e) => handleFieldChange('confirmPassword', e.target.value)}\n          onBlur={() => setFieldTouched('confirmPassword', true)}\n          className={errors.confirmPassword ? 'error' : ''}\n        />\n        {errors.confirmPassword && <span className=\"error-message\">{errors.confirmPassword}</span>}\n      </div>\n\n      {/* Age field */}\n      <div className=\"form-field\">\n        <label htmlFor=\"age\">Age *</label>\n        <input\n          id=\"age\"\n          type=\"number\"\n          value={form.age}\n          onChange={(e) => handleFieldChange('age', e.target.value)}\n          onBlur={() => setFieldTouched('age', true)}\n          className={errors.age ? 'error' : ''}\n        />\n        {errors.age && <span className=\"error-message\">{errors.age}</span>}\n      </div>\n\n      {/* Form status */}\n      {submission.submitError && (\n        <div className=\"error-message form-error\">\n          {submission.submitError}\n        </div>\n      )}\n      \n      {submission.submitSuccess && (\n        <div className=\"success-message\">\n          Form submitted successfully!\n        </div>\n      )}\n\n      {/* Form actions */}\n      <div className=\"form-actions\">\n        <button\n          type=\"button\"\n          onClick={resetForm}\n          disabled={!isDirty}\n        >\n          Reset\n        </button>\n        \n        <button\n          type=\"submit\"\n          disabled={!isValid || submission.isSubmitting}\n        >\n          {submission.isSubmitting ? 'Submitting...' : 'Submit'}\n        </button>\n      </div>\n\n      {/* Form info */}\n      <div className=\"form-info\">\n        <p>Form is {isValid ? 'valid' : 'invalid'}</p>\n        <p>Form is {isDirty ? 'dirty' : 'clean'}</p>\n      </div>\n    </form>\n  );\n}\n\n// Reusable form field component\nfunction FormField({ \n  field, \n  label, \n  type = 'text', \n  required = false \n}: {\n  field: string;\n  label: string;\n  type?: string;\n  required?: boolean;\n}) {\n  const form = useUnderstate(formData);\n  const errors = useUnderstate(fieldErrors);\n  const value = form[field as keyof typeof form] || '';\n\n  return (\n    <div className=\"form-field\">\n      <label htmlFor={field}>\n        {label} {required && '*'}\n      </label>\n      <input\n        id={field}\n        type={type}\n        value={value}\n        onChange={(e) => setFieldValue(field, e.target.value)}\n        onBlur={() => setFieldTouched(field, true)}\n        className={errors[field] ? 'error' : ''}\n      />\n      {errors[field] && (\n        <span className=\"error-message\">{errors[field]}</span>\n      )}\n    </div>\n  );\n}\n\nexport { ContactForm, FormField };",
  "installation": "<!-- UMD build -->\n<script src=\"https://unpkg.com/react-understate@latest/dist/react-understate.umd.js\"></script>\n\n<!-- ES Module build -->\n<script type=\"module\">\n  import { state, derived, effect } from 'https://unpkg.com/react-understate@latest/dist/react-understate.esm.js'\n</script>",
  "introduction2": "import { state, action } from 'react-understate';\n\nexport const count = state(0, 'count');\n\nexport const increment = action(() => {\n  count.value++;\n}, 'increment');\n\nexport const decrement = action(() => {\n  count.value--;\n}, 'decrement');\n\nexport const reset = action(() => {\n  count.value = 0;\n}, 'reset');\n",
  "introduction3": "import React from 'react';\nimport { useUnderstate } from 'react-understate';\nimport * as store from './introduction-2';\n\nfunction BearCounter() {\n  const { count } = useUnderstate(store);\n  return <h1>{count} bears around here...</h1>;\n}\n\nfunction Controls() {\n  const { increment } = useUnderstate(store);\n  return <button onClick={increment}>one up</button>;\n}\n",
  "keyboardshortcuts": "import { state, action, effect } from 'react-understate';\n\n// State\nconst count = state(0, 'count');\n\n// Actions\nconst increment = action(() => {\n  count.value++;\n}, 'increment');\n\nconst decrement = action(() => {\n  count.value--;\n}, 'decrement');\n\nconst reset = action(() => {\n  count.value = 0;\n}, 'reset');\n\n// Keyboard shortcuts effect\nconst setupKeyboardShortcuts = effect(() => {\n  const handleKeyDown = (event: KeyboardEvent) => {\n    // Prevent default for handled keys\n    const handled = true;\n    \n    switch (event.key) {\n      case 'ArrowUp':\n      case '+':\n        increment();\n        break;\n      case 'ArrowDown':\n      case '-':\n        decrement();\n        break;\n      case 'r':\n      case 'R':\n        if (event.ctrlKey || event.metaKey) {\n          reset();\n        } else {\n          handled = false;\n        }\n        break;\n      default:\n        handled = false;\n    }\n    \n    if (handled) {\n      event.preventDefault();\n    }\n  };\n\n  document.addEventListener('keydown', handleKeyDown);\n  \n  // Cleanup\n  return () => {\n    document.removeEventListener('keydown', handleKeyDown);\n  };\n}, 'setupKeyboardShortcuts');",
  "keyboardshortcuts2": "const mode = state<'normal' | 'editing' | 'selecting'>('normal', 'mode');\nconst selectedItems = state<string[]>([], 'selectedItems');\n\nconst setupConditionalShortcuts = effect(() => {\n  const handleKeyDown = (event: KeyboardEvent) => {\n    const currentMode = mode.value;\n    \n    // Global shortcuts (work in any mode)\n    if (event.ctrlKey || event.metaKey) {\n      switch (event.key) {\n        case 's':\n          saveDocument();\n          event.preventDefault();\n          return;\n        case 'z':\n          if (event.shiftKey) {\n            redo();\n          } else {\n            undo();\n          }\n          event.preventDefault();\n          return;\n      }\n    }\n    \n    // Mode-specific shortcuts\n    switch (currentMode) {\n      case 'normal':\n        handleNormalModeKeys(event);\n        break;\n      case 'editing':\n        handleEditingModeKeys(event);\n        break;\n      case 'selecting':\n        handleSelectingModeKeys(event);\n        break;\n    }\n  };\n\n  document.addEventListener('keydown', handleKeyDown);\n  return () => document.removeEventListener('keydown', handleKeyDown);\n}, [mode], 'conditionalShortcuts');\n\nconst handleNormalModeKeys = action((event: KeyboardEvent) => {\n  switch (event.key) {\n    case 'n':\n      createNewItem();\n      event.preventDefault();\n      break;\n    case 'e':\n      enterEditMode();\n      event.preventDefault();\n      break;\n    case 'Delete':\n      deleteSelectedItems();\n      event.preventDefault();\n      break;\n  }\n}, 'handleNormalModeKeys');",
  "keyboardshortcuts3": "const handleShortcutsWithModifiers = action((event: KeyboardEvent) => {\n  const { key, ctrlKey, metaKey, shiftKey, altKey } = event;\n  const cmdOrCtrl = ctrlKey || metaKey; // Cmd on Mac, Ctrl on Windows/Linux\n\n  // Text editing shortcuts\n  if (cmdOrCtrl) {\n    switch (key) {\n      case 'a':\n        selectAll();\n        event.preventDefault();\n        break;\n      case 'c':\n        copySelection();\n        event.preventDefault();\n        break;\n      case 'v':\n        pasteFromClipboard();\n        event.preventDefault();\n        break;\n      case 'x':\n        cutSelection();\n        event.preventDefault();\n        break;\n      case 'z':\n        if (shiftKey) {\n          redo();\n        } else {\n          undo();\n        }\n        event.preventDefault();\n        break;\n      case 'f':\n        openFindDialog();\n        event.preventDefault();\n        break;\n      case 'n':\n        if (shiftKey) {\n          createNewFolder();\n        } else {\n          createNewFile();\n        }\n        event.preventDefault();\n        break;\n    }\n  }\n  \n  // Alt/Option shortcuts\n  if (altKey) {\n    switch (key) {\n      case 'ArrowUp':\n        moveSelectionUp();\n        event.preventDefault();\n        break;\n      case 'ArrowDown':\n        moveSelectionDown();\n        event.preventDefault();\n        break;\n    }\n  }\n  \n  // Shift shortcuts (usually for selection)\n  if (shiftKey && !cmdOrCtrl) {\n    switch (key) {\n      case 'ArrowUp':\n        extendSelectionUp();\n        event.preventDefault();\n        break;\n      case 'ArrowDown':\n        extendSelectionDown();\n        event.preventDefault();\n        break;\n    }\n  }\n}, 'handleShortcutsWithModifiers');",
  "keyboardshortcuts4": "const setupFocusAwareShortcuts = effect(() => {\n  const handleKeyDown = (event: KeyboardEvent) => {\n    const target = event.target as HTMLElement;\n    \n    // Don't handle shortcuts if user is typing in an input\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return;\n    }\n    \n    // Only handle shortcuts when the main app area is focused\n    if (!target.closest('.app-main')) {\n      return;\n    }\n    \n    // Now handle the shortcuts\n    switch (event.key) {\n      case 'j':\n        selectNext();\n        event.preventDefault();\n        break;\n      case 'k':\n        selectPrevious();\n        event.preventDefault();\n        break;\n      case 'Enter':\n        openSelected();\n        event.preventDefault();\n        break;\n    }\n  };\n\n  document.addEventListener('keydown', handleKeyDown);\n  return () => document.removeEventListener('keydown', handleKeyDown);\n}, 'focusAwareShortcuts');",
  "keyboardshortcuts5": "// Calculator.tsx\nimport React, { useEffect } from 'react';\nimport { useUnderstate } from 'react-understate';\nimport { calculatorStore } from './calculatorStore';\n\nfunction Calculator() {\n  const { displayValue, operation, handleKeyDown, clear } = useUnderstate(calculatorStore);\n\n  // Set up keyboard shortcuts\n  useEffect(() => {\n    const handleKey = (event: KeyboardEvent) => {\n      handleKeyDown(event);\n    };\n\n    document.addEventListener('keydown', handleKey);\n    return () => document.removeEventListener('keydown', handleKey);\n  }, [handleKeyDown]);\n\n  return (\n    <div \n      className=\"calculator\"\n      tabIndex={0} // Make it focusable\n      onKeyDown={(e) => handleKeyDown(e.nativeEvent)}\n    >\n      <div className=\"display\">\n        {displayValue}\n        {operation && <span className=\"operation\">{operation}</span>}\n      </div>\n      \n      <div className=\"keypad\">\n        <button onClick={clear}>Clear (Esc)</button>\n        {/* Other buttons... */}\n      </div>\n      \n      <div className=\"shortcuts-help\">\n        <h4>Keyboard Shortcuts:</h4>\n        <ul>\n          <li><kbd>0-9</kbd> - Input digits</li>\n          <li><kbd>+ - * /</kbd> - Operations</li>\n          <li><kbd>Enter</kbd> or <kbd>=</kbd> - Calculate</li>\n          <li><kbd>Esc</kbd> - Clear</li>\n          <li><kbd>.</kbd> - Decimal point</li>\n          <li><kbd>%</kbd> - Percentage</li>\n          <li><kbd>P</kbd> - Plus/minus toggle</li>\n        </ul>\n      </div>\n    </div>\n  );\n}",
  "keyboardshortcuts6": "// keyboardShortcuts.test.ts\nimport { fireEvent } from '@testing-library/react';\nimport { calculatorStore } from './calculatorStore';\n\ndescribe('Calculator Keyboard Shortcuts', () => {\n  beforeEach(() => {\n    calculatorStore.clear();\n  });\n\n  test('number keys input digits', () => {\n    const event = new KeyboardEvent('keydown', { key: '5' });\n    calculatorStore.handleKeyDown(event);\n    \n    expect(calculatorStore.displayValue.value).toBe('5');\n  });\n\n  test('operation keys perform operations', () => {\n    // Input: 5 + 3 =\n    fireEvent.keyDown(document, { key: '5' });\n    fireEvent.keyDown(document, { key: '+' });\n    fireEvent.keyDown(document, { key: '3' });\n    fireEvent.keyDown(document, { key: 'Enter' });\n    \n    expect(calculatorStore.displayValue.value).toBe('8');\n  });\n\n  test('escape key clears calculator', () => {\n    calculatorStore.inputDigit('123');\n    fireEvent.keyDown(document, { key: 'Escape' });\n    \n    expect(calculatorStore.displayValue.value).toBe('0');\n  });\n\n  test('prevents default for handled keys', () => {\n    const event = new KeyboardEvent('keydown', { key: '+' });\n    const preventDefaultSpy = jest.spyOn(event, 'preventDefault');\n    \n    calculatorStore.handleKeyDown(event);\n    \n    expect(preventDefaultSpy).toHaveBeenCalled();\n  });\n});",
  "keyboardshortcuts7": "// keyboardShortcuts.test.ts\nimport { fireEvent } from '@testing-library/react';\nimport { calculatorStore } from './calculatorStore';\n\ndescribe('Calculator Keyboard Shortcuts', () => {\n  beforeEach(() => {\n    calculatorStore.clear();\n  });\n\n  test('number keys input digits', () => {\n    const event = new KeyboardEvent('keydown', { key: '5' });\n    calculatorStore.handleKeyDown(event);\n    \n    expect(calculatorStore.displayValue.value).toBe('5');\n  });\n\n  test('operation keys perform operations', () => {\n    // Input: 5 + 3 =\n    fireEvent.keyDown(document, { key: '5' });\n    fireEvent.keyDown(document, { key: '+' });\n    fireEvent.keyDown(document, { key: '3' });\n    fireEvent.keyDown(document, { key: 'Enter' });\n    \n    expect(calculatorStore.displayValue.value).toBe('8');\n  });\n\n  test('escape key clears calculator', () => {\n    calculatorStore.inputDigit('123');\n    fireEvent.keyDown(document, { key: 'Escape' });\n    \n    expect(calculatorStore.displayValue.value).toBe('0');\n  });\n\n  test('prevents default for handled keys', () => {\n    const event = new KeyboardEvent('keydown', { key: '+' });\n    const preventDefaultSpy = jest.spyOn(event, 'preventDefault');\n    \n    calculatorStore.handleKeyDown(event);\n    \n    expect(preventDefaultSpy).toHaveBeenCalled();\n  });\n});",
  "localstorage": "import { state, derived, action, persistLocalStorage } from 'react-understate';\n\n// Simple persistent state\nexport const theme = state('light', {\n  name: 'theme',\n  persist: persistLocalStorage('app-theme'),\n});\n\nexport const userPreferences = state({\n  language: 'en',\n  notifications: true,\n  autoSave: true,\n}, {\n  name: 'userPreferences',\n  persist: persistLocalStorage('user-preferences'),\n});\n\n// The state will automatically load from localStorage on initialization\n// and save to localStorage whenever it changes\n\n// Actions to modify persistent state\nexport const setTheme = action((newTheme: 'light' | 'dark') => {\n  console.log('action: setting theme to', newTheme);\n  theme(newTheme); // Automatically persisted\n}, { name: 'setTheme' });\n\nexport const updatePreferences = action((updates: Partial<typeof userPreferences>) => {\n  console.log('action: updating preferences', updates);\n  userPreferences(prev => ({ ...prev, ...updates }));\n}, { name: 'updatePreferences' });",
  "localstorage2": "import { state, derived, action, effect, persistLocalStorage } from 'react-understate';\n\n// Types\ntype UserSettings = {\n  theme: 'light' | 'dark' | 'auto';\n  language: string;\n  timezone: string;\n  notifications: {\n    email: boolean;\n    push: boolean;\n    sound: boolean;\n  };\n  privacy: {\n    analytics: boolean;\n    tracking: boolean;\n  };\n};\n\ntype AppData = {\n  recentFiles: string[];\n  bookmarks: { id: string; name: string; url: string }[];\n  workspace: {\n    sidebar: boolean;\n    panels: Record<string, boolean>;\n  };\n};\n\n// Default values\nconst defaultSettings: UserSettings = {\n  theme: 'auto',\n  language: 'en',\n  timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n  notifications: {\n    email: true,\n    push: true,\n    sound: false,\n  },\n  privacy: {\n    analytics: false,\n    tracking: false,\n  },\n};\n\nconst defaultAppData: AppData = {\n  recentFiles: [],\n  bookmarks: [],\n  workspace: {\n    sidebar: true,\n    panels: {},\n  },\n};\n\n// Persistent state\nexport const userSettings = state(defaultSettings, {\n  name: 'userSettings',\n  persist: persistLocalStorage('user-settings-v2'), // Version in key for migrations\n});\n\nexport const appData = state(defaultAppData, {\n  name: 'appData',\n  persist: persistLocalStorage('app-data-v1'),\n});\n\n// Non-persistent state for session data\nexport const sessionData = state({\n  lastActivity: new Date(),\n  currentTab: 'main',\n  tempData: null as any,\n}, { name: 'sessionData' });\n\n// Derived values from persistent state\nexport const isDarkMode = derived(() => {\n  const theme = userSettings().theme;\n  if (theme === 'auto') {\n    // Check system preference\n    return window.matchMedia('(prefers-color-scheme: dark)').matches;\n  }\n  return theme === 'dark';\n}, { name: 'isDarkMode' });\n\nexport const effectiveLanguage = derived(() => {\n  const lang = userSettings().language;\n  // Fallback to browser language if not set\n  return lang || navigator.language.split('-')[0];\n}, { name: 'effectiveLanguage' });\n\nexport const notificationSettings = derived(() => {\n  return userSettings().notifications;\n}, { name: 'notificationSettings' });\n\n// Actions for settings\nexport const updateUserSettings = action((updates: Partial<UserSettings>) => {\n  console.log('action: updating user settings', updates);\n  userSettings(prev => ({\n    ...prev,\n    ...updates,\n    // Deep merge nested objects\n    notifications: updates.notifications \n      ? { ...prev.notifications, ...updates.notifications }\n      : prev.notifications,\n    privacy: updates.privacy\n      ? { ...prev.privacy, ...updates.privacy }\n      : prev.privacy,\n  }));\n}, { name: 'updateUserSettings' });\n\nexport const toggleTheme = action(() => {\n  const current = userSettings().theme;\n  const next = current === 'light' ? 'dark' : 'light';\n  console.log('action: toggling theme from', current, 'to', next);\n  updateUserSettings({ theme: next });\n}, { name: 'toggleTheme' });\n\nexport const resetSettings = action(() => {\n  console.log('action: resetting settings to defaults');\n  userSettings(defaultSettings);\n}, { name: 'resetSettings' });\n\n// Actions for app data\nexport const addRecentFile = action((filePath: string) => {\n  console.log('action: adding recent file', filePath);\n  appData(prev => ({\n    ...prev,\n    recentFiles: [\n      filePath,\n      ...prev.recentFiles.filter(f => f !== filePath).slice(0, 9) // Keep 10 max\n    ],\n  }));\n}, { name: 'addRecentFile' });\n\nexport const addBookmark = action((bookmark: { name: string; url: string }) => {\n  console.log('action: adding bookmark', bookmark);\n  const id = Date.now().toString();\n  appData(prev => ({\n    ...prev,\n    bookmarks: [...prev.bookmarks, { ...bookmark, id }],\n  }));\n}, { name: 'addBookmark' });\n\nexport const removeBookmark = action((id: string) => {\n  console.log('action: removing bookmark', id);\n  appData(prev => ({\n    ...prev,\n    bookmarks: prev.bookmarks.filter(b => b.id !== id),\n  }));\n}, { name: 'removeBookmark' });\n\nexport const updateWorkspace = action((updates: Partial<AppData['workspace']>) => {\n  console.log('action: updating workspace', updates);\n  appData(prev => ({\n    ...prev,\n    workspace: { ...prev.workspace, ...updates },\n  }));\n}, { name: 'updateWorkspace' });",
  "localstorage3": "import { effect } from 'react-understate';\n\n// Effect to sync changes across tabs\nexport const crossTabSyncEffect = effect(() => {\n  console.log('effect: setting up cross-tab sync');\n  \n  const handleStorageChange = (event: StorageEvent) => {\n    if (!event.key || !event.newValue) return;\n    \n    try {\n      // Handle user settings sync\n      if (event.key === 'user-settings-v2') {\n        const newSettings = JSON.parse(event.newValue);\n        console.log('effect: syncing user settings from other tab');\n        userSettings(newSettings);\n      }\n      \n      // Handle app data sync\n      if (event.key === 'app-data-v1') {\n        const newAppData = JSON.parse(event.newValue);\n        console.log('effect: syncing app data from other tab');\n        appData(newAppData);\n      }\n    } catch (error) {\n      console.error('effect: failed to sync from other tab', error);\n    }\n  };\n  \n  window.addEventListener('storage', handleStorageChange);\n  \n  return () => {\n    window.removeEventListener('storage', handleStorageChange);\n  };\n}, { name: 'crossTabSyncEffect' });\n\n// Manual sync trigger (useful for testing or forced sync)\nexport const syncFromStorage = action(() => {\n  console.log('action: manually syncing from storage');\n  \n  try {\n    const settingsData = localStorage.getItem('user-settings-v2');\n    if (settingsData) {\n      userSettings(JSON.parse(settingsData));\n    }\n    \n    const appDataStr = localStorage.getItem('app-data-v1');\n    if (appDataStr) {\n      appData(JSON.parse(appDataStr));\n    }\n  } catch (error) {\n    console.error('action: failed to sync from storage', error);\n  }\n}, { name: 'syncFromStorage' });",
  "localstorage4": "// Migration utilities\ntype Migration<T> = (oldData: any) => T;\n\nconst settingsMigrations: Record<string, Migration<UserSettings>> = {\n  'user-settings-v1': (oldData) => {\n    // Migrate from v1 to v2 structure\n    return {\n      theme: oldData.darkMode ? 'dark' : 'light', // Changed from boolean to string\n      language: oldData.lang || 'en', // Renamed field\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, // New field\n      notifications: {\n        email: oldData.emailNotifications ?? true,\n        push: oldData.pushNotifications ?? true,\n        sound: false, // New field\n      },\n      privacy: {\n        analytics: false, // New section\n        tracking: false,\n      },\n    };\n  },\n};\n\n// Custom persistence with migration support\nexport const createMigratedState = <T>(\n  defaultValue: T,\n  currentKey: string,\n  migrations: Record<string, Migration<T>> = {}\n) => {\n  // Try to load from current version first\n  let initialValue = defaultValue;\n  \n  try {\n    const currentData = localStorage.getItem(currentKey);\n    if (currentData) {\n      initialValue = JSON.parse(currentData);\n    } else {\n      // Look for old versions and migrate\n      for (const [oldKey, migrate] of Object.entries(migrations)) {\n        const oldData = localStorage.getItem(oldKey);\n        if (oldData) {\n          console.log(`Migrating data from ${oldKey} to ${currentKey}`);\n          initialValue = migrate(JSON.parse(oldData));\n          \n          // Clean up old key\n          localStorage.removeItem(oldKey);\n          break;\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Failed to load or migrate data, using defaults:', error);\n    initialValue = defaultValue;\n  }\n  \n  return state(initialValue, {\n    name: currentKey,\n    persist: persistLocalStorage(currentKey),\n  });\n};\n\n// Usage with migration\nexport const migratedUserSettings = createMigratedState(\n  defaultSettings,\n  'user-settings-v2',\n  settingsMigrations\n);",
  "localstorage5": "// State with mixed persistence needs\nexport const editorState = state({\n  // Persistent data\n  settings: {\n    fontSize: 14,\n    theme: 'vs-dark',\n    wordWrap: true,\n  },\n  recentFiles: [] as string[],\n  \n  // Session-only data (not persisted)\n  currentFile: null as string | null,\n  isLoading: false,\n  errors: [] as string[],\n}, { name: 'editorState' });\n\n// Derived state for persistent parts only\nexport const persistentEditorData = derived(() => {\n  const state = editorState();\n  return {\n    settings: state.settings,\n    recentFiles: state.recentFiles,\n  };\n}, { name: 'persistentEditorData' });\n\n// Effect to save only persistent data\nexport const saveEditorDataEffect = effect(() => {\n  const persistentData = persistentEditorData();\n  \n  try {\n    localStorage.setItem('editor-data', JSON.stringify(persistentData));\n  } catch (error) {\n    console.error('effect: failed to save editor data', error);\n  }\n}, { name: 'saveEditorDataEffect' });\n\n// Action to load persistent data\nexport const loadEditorData = action(() => {\n  console.log('action: loading editor data');\n  \n  try {\n    const saved = localStorage.getItem('editor-data');\n    if (saved) {\n      const persistentData = JSON.parse(saved);\n      \n      editorState(prev => ({\n        ...prev,\n        settings: persistentData.settings || prev.settings,\n        recentFiles: persistentData.recentFiles || prev.recentFiles,\n        // Keep session data unchanged\n      }));\n    }\n  } catch (error) {\n    console.error('action: failed to load editor data', error);\n  }\n}, { name: 'loadEditorData' });\n\n// Custom persistence for complex scenarios\nexport const createSelectivePersistence = <T, K extends keyof T>(\n  stateInstance: any,\n  storageKey: string,\n  persistentKeys: K[]\n) => {\n  // Save effect\n  const saveEffect = effect(() => {\n    const fullState = stateInstance();\n    const persistentData = persistentKeys.reduce((acc, key) => {\n      acc[key] = fullState[key];\n      return acc;\n    }, {} as Pick<T, K>);\n    \n    try {\n      localStorage.setItem(storageKey, JSON.stringify(persistentData));\n    } catch (error) {\n      console.error(`Failed to persist ${storageKey}`, error);\n    }\n  }, { name: `save-${storageKey}` });\n  \n  // Load action\n  const loadAction = action(() => {\n    try {\n      const saved = localStorage.getItem(storageKey);\n      if (saved) {\n        const persistentData = JSON.parse(saved);\n        stateInstance((prev: T) => ({ ...prev, ...persistentData }));\n      }\n    } catch (error) {\n      console.error(`Failed to load ${storageKey}`, error);\n    }\n  }, { name: `load-${storageKey}` });\n  \n  return { saveEffect, loadAction };\n};\n\n// Usage\nconst { saveEffect: saveUIEffect, loadAction: loadUIData } = \n  createSelectivePersistence(\n    editorState,\n    'ui-settings',\n    ['settings', 'recentFiles'] // Only these keys will be persisted\n  );",
  "localstorage6": "import React, { useEffect } from 'react';\nimport { useUnderstate } from 'react-understate';\nimport {\n  userSettings,\n  appData,\n  isDarkMode,\n  updateUserSettings,\n  toggleTheme,\n  addRecentFile,\n  loadEditorData,\n  crossTabSyncEffect,\n} from './persistenceStore';\n\nfunction SettingsPanel() {\n  const settings = useUnderstate(userSettings);\n  const darkMode = useUnderstate(isDarkMode);\n  const data = useUnderstate(appData);\n\n  useEffect(() => {\n    // Initialize cross-tab sync\n    crossTabSyncEffect;\n    loadEditorData();\n  }, []);\n\n  return (\n    <div className={darkMode ? 'dark-theme' : 'light-theme'}>\n      <h2>Settings</h2>\n      \n      {/* Theme Toggle */}\n      <div>\n        <label>\n          Theme:\n          <select\n            value={settings.theme}\n            onChange={(e) => updateUserSettings({ \n              theme: e.target.value as 'light' | 'dark' | 'auto' \n            })}\n          >\n            <option value=\"light\">Light</option>\n            <option value=\"dark\">Dark</option>\n            <option value=\"auto\">Auto</option>\n          </select>\n        </label>\n        <button onClick={toggleTheme}>Toggle</button>\n      </div>\n\n      {/* Language */}\n      <div>\n        <label>\n          Language:\n          <select\n            value={settings.language}\n            onChange={(e) => updateUserSettings({ language: e.target.value })}\n          >\n            <option value=\"en\">English</option>\n            <option value=\"es\">Spanish</option>\n            <option value=\"fr\">French</option>\n          </select>\n        </label>\n      </div>\n\n      {/* Notifications */}\n      <div>\n        <h3>Notifications</h3>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={settings.notifications.email}\n            onChange={(e) => updateUserSettings({\n              notifications: {\n                ...settings.notifications,\n                email: e.target.checked,\n              },\n            })}\n          />\n          Email notifications\n        </label>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={settings.notifications.push}\n            onChange={(e) => updateUserSettings({\n              notifications: {\n                ...settings.notifications,\n                push: e.target.checked,\n              },\n            })}\n          />\n          Push notifications\n        </label>\n      </div>\n\n      {/* Recent Files */}\n      <div>\n        <h3>Recent Files</h3>\n        <button onClick={() => addRecentFile('/path/to/new/file.txt')}>\n          Add Test File\n        </button>\n        <ul>\n          {data.recentFiles.map((file, index) => (\n            <li key={index}>{file}</li>\n          ))}\n        </ul>\n      </div>\n\n      {/* Storage Info */}\n      <div>\n        <h3>Storage Info</h3>\n        <p>Current theme: {darkMode ? 'Dark' : 'Light'}</p>\n        <p>Effective language: {settings.language}</p>\n        <p>Total bookmarks: {data.bookmarks.length}</p>\n      </div>\n    </div>\n  );\n}\n\n// Hook for localStorage with state\nfunction useLocalStorageState<T>(key: string, defaultValue: T) {\n  const [value, setValue] = React.useState<T>(() => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch {\n      return defaultValue;\n    }\n  });\n\n  const setStoredValue = React.useCallback((newValue: T) => {\n    try {\n      setValue(newValue);\n      localStorage.setItem(key, JSON.stringify(newValue));\n    } catch (error) {\n      console.error('Failed to save to localStorage:', error);\n    }\n  }, [key]);\n\n  return [value, setStoredValue] as const;\n}\n\n// Component using the hook\nfunction SimplePersistedComponent() {\n  const [count, setCount] = useLocalStorageState('simple-counter', 0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}\n\nexport { SettingsPanel, SimplePersistedComponent };",
  "localstorage7": "import React, { useEffect } from 'react';\nimport { useUnderstate } from 'react-understate';\nimport {\n  userSettings,\n  appData,\n  isDarkMode,\n  updateUserSettings,\n  toggleTheme,\n  addRecentFile,\n  loadEditorData,\n  crossTabSyncEffect,\n} from './persistenceStore';\n\nfunction SettingsPanel() {\n  const settings = useUnderstate(userSettings);\n  const darkMode = useUnderstate(isDarkMode);\n  const data = useUnderstate(appData);\n\n  useEffect(() => {\n    // Initialize cross-tab sync\n    crossTabSyncEffect;\n    loadEditorData();\n  }, []);\n\n  return (\n    <div className={darkMode ? 'dark-theme' : 'light-theme'}>\n      <h2>Settings</h2>\n      \n      {/* Theme Toggle */}\n      <div>\n        <label>\n          Theme:\n          <select\n            value={settings.theme}\n            onChange={(e) => updateUserSettings({ \n              theme: e.target.value as 'light' | 'dark' | 'auto' \n            })}\n          >\n            <option value=\"light\">Light</option>\n            <option value=\"dark\">Dark</option>\n            <option value=\"auto\">Auto</option>\n          </select>\n        </label>\n        <button onClick={toggleTheme}>Toggle</button>\n      </div>\n\n      {/* Language */}\n      <div>\n        <label>\n          Language:\n          <select\n            value={settings.language}\n            onChange={(e) => updateUserSettings({ language: e.target.value })}\n          >\n            <option value=\"en\">English</option>\n            <option value=\"es\">Spanish</option>\n            <option value=\"fr\">French</option>\n          </select>\n        </label>\n      </div>\n\n      {/* Notifications */}\n      <div>\n        <h3>Notifications</h3>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={settings.notifications.email}\n            onChange={(e) => updateUserSettings({\n              notifications: {\n                ...settings.notifications,\n                email: e.target.checked,\n              },\n            })}\n          />\n          Email notifications\n        </label>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={settings.notifications.push}\n            onChange={(e) => updateUserSettings({\n              notifications: {\n                ...settings.notifications,\n                push: e.target.checked,\n              },\n            })}\n          />\n          Push notifications\n        </label>\n      </div>\n\n      {/* Recent Files */}\n      <div>\n        <h3>Recent Files</h3>\n        <button onClick={() => addRecentFile('/path/to/new/file.txt')}>\n          Add Test File\n        </button>\n        <ul>\n          {data.recentFiles.map((file, index) => (\n            <li key={index}>{file}</li>\n          ))}\n        </ul>\n      </div>\n\n      {/* Storage Info */}\n      <div>\n        <h3>Storage Info</h3>\n        <p>Current theme: {darkMode ? 'Dark' : 'Light'}</p>\n        <p>Effective language: {settings.language}</p>\n        <p>Total bookmarks: {data.bookmarks.length}</p>\n      </div>\n    </div>\n  );\n}\n\n// Hook for localStorage with state\nfunction useLocalStorageState<T>(key: string, defaultValue: T) {\n  const [value, setValue] = React.useState<T>(() => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch {\n      return defaultValue;\n    }\n  });\n\n  const setStoredValue = React.useCallback((newValue: T) => {\n    try {\n      setValue(newValue);\n      localStorage.setItem(key, JSON.stringify(newValue));\n    } catch (error) {\n      console.error('Failed to save to localStorage:', error);\n    }\n  }, [key]);\n\n  return [value, setStoredValue] as const;\n}\n\n// Component using the hook\nfunction SimplePersistedComponent() {\n  const [count, setCount] = useLocalStorageState('simple-counter', 0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}\n\nexport { SettingsPanel, SimplePersistedComponent };",
  "performanceoptimization": "// ❌ One large state - changing name updates everything\nconst user = state({\n  profile: { name: '', email: '', bio: '' },\n  preferences: { theme: 'light', notifications: true },\n  activities: [...], // Large array\n  settings: { privacy: 'public', language: 'en' },\n});\n\n// ✅ Split into focused states\nconst userProfile = state({ name: '', email: '', bio: '' });\nconst userPreferences = state({ theme: 'light', notifications: true });\nconst userActivities = state([...]);\nconst userSettings = state({ privacy: 'public', language: 'en' });\n\n// Components only re-render when their specific state changes\nfunction ProfileComponent() {\n  const [profile] = useUnderstate(userProfile);\n  // Only re-renders when profile changes, not when preferences change\n}\n\nfunction PreferencesComponent() {\n  const [preferences] = useUnderstate(userPreferences);\n  // Only re-renders when preferences change, not when profile changes\n}",
  "performanceoptimization10": "import { configureDebug } from 'react-understate';\n\n// Enable debugging in development\nif (process.env.NODE_ENV === 'development') {\n  configureDebug({\n    enabled: true,\n    showFile: true,\n    showTimestamp: true,\n    performanceThreshold: 16, // Log slow operations\n  });\n}",
  "performanceoptimization11": "const expensiveOperation = action(async (data) => {\n  const startTime = performance.now();\n  \n  try {\n    // Your expensive operation\n    const result = await processLargeDataset(data);\n    \n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    if (duration > 100) { // Log operations over 100ms\n      console.warn(`Slow operation: ${duration.toFixed(2)}ms`);\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Operation failed:', error);\n    throw error;\n  }\n}, 'expensiveOperation');",
  "performanceoptimization2": "const settings = state({ theme: 'light', lang: 'en' });\n\n// ❌ Wrong - mutating doesn't trigger updates\nsettings.value.theme = 'dark'; // Won't update components!\n\n// ✅ Correct - replace the object\nsettings.value = { ...settings.value, theme: 'dark' };\n\n// ✅ Also correct - completely new object\nsettings.value = { theme: 'dark', lang: 'en' };\n\n// ✅ For arrays, use immutable operations\nconst items = state([1, 2, 3]);\n\n// ❌ Wrong\nitems.value.push(4); // Won't trigger updates!\n\n// ✅ Correct\nitems.value = [...items.value, 4];\nitems.value = items.value.filter(item => item !== 2);",
  "performanceoptimization3": "// ❌ Inefficient - accesses entire user object\nconst userDisplay = derived(() => {\n  const user = fullUserObject(); // Large object with many properties\n  return `${user.firstName} ${user.lastName} (${user.email})`;\n});\n\n// ✅ Efficient - only depends on specific properties\nconst firstName = state('John');\nconst lastName = state('Doe');\nconst email = state('john@example.com');\n\nconst userDisplay = derived(() => {\n  return `${firstName.value} ${lastName.value} (${email.value})`;\n});",
  "performanceoptimization4": "const orders = state([]);\n\n// Break down complex computation into steps\nconst validOrders = derived(() => {\n  return orders.value.filter(order => order.status !== 'cancelled');\n});\n\nconst ordersByMonth = derived(() => {\n  const valid = validOrders.value;\n  \n  return valid.reduce((acc, order) => {\n    const month = order.date.getMonth();\n    if (!acc[month]) acc[month] = [];\n    acc[month].push(order);\n    return acc;\n  }, {} as Record<number, Order[]>);\n});\n\nconst monthlyRevenue = derived(() => {\n  const byMonth = ordersByMonth.value;\n  \n  return Object.entries(byMonth).map(([month, orders]) => ({\n    month: parseInt(month),\n    revenue: orders.reduce((sum, order) => sum + order.total, 0),\n    orderCount: orders.length,\n  }));\n});",
  "performanceoptimization5": "import { state, batch, useUnderstate } from 'react-understate';\n\nconst firstName = state('');\nconst lastName = state('');\nconst email = state('');\nconst phone = state('');\n\n// Without batching - triggers 4 re-renders\nconst updateUserUnbatched = (data) => {\n  firstName.value = data.firstName;\n  lastName.value = data.lastName;\n  email.value = data.email;\n  phone.value = data.phone;\n};\n\n// With batching - triggers only 1 re-render\nconst updateUserBatched = (data) => {\n  batch(() => {\n    firstName.value = data.firstName;\n    lastName.value = data.lastName;\n    email.value = data.email;\n    phone.value = data.phone;\n  });\n};",
  "performanceoptimization6": "import { state, action, batch } from 'react-understate';\n\nconst formData = state({\n  firstName: '',\n  lastName: '',\n  email: '',\n  phone: '',\n});\n\nconst updateForm = action((newData) => {\n  batch(() => {\n    formData.value = { ...formData.value, ...newData };\n  });\n}, 'updateForm');\n\nconst resetForm = action(() => {\n  batch(() => {\n    formData.value = {\n      firstName: '',\n      lastName: '',\n      email: '',\n      phone: '',\n    };\n  });\n}, 'resetForm');",
  "performanceoptimization7": "const showAdvancedStats = state(false);\nconst userData = state({ /* large user object */ });\n\n// Only compute expensive stats when needed\nconst conditionalStats = derived(() => {\n  const shouldShow = showAdvancedStats.value;\n  \n  if (!shouldShow) {\n    return { enabled: false };\n  }\n  \n  // Only access expensive data when actually needed\n  const user = userData.value;\n  return {\n    enabled: true,\n    totalOrders: user.orders.length,\n    averageOrderValue: user.orders.reduce((sum, order) => sum + order.total, 0) / user.orders.length,\n    // More expensive computations...\n  };\n});",
  "performanceoptimization8": "import { state, effect } from 'react-understate';\n\nconst data = state([]);\n\n// Effect with proper cleanup\nconst dataEffect = effect(() => {\n  const interval = setInterval(() => {\n    // Update data periodically\n    data.value = [...data.value, { id: Date.now(), value: Math.random() }];\n  }, 1000);\n  \n  // Return cleanup function\n  return () => {\n    clearInterval(interval);\n  };\n}, 'dataEffect');\n\n// Manual cleanup when needed\nconst cleanup = dataEffect;\n// Later...\ncleanup();",
  "performanceoptimization9": "// For large datasets that might be garbage collected\nconst largeDataSet = new WeakMap();\nconst processedItems = new WeakSet();\n\nconst processLargeItem = (item) => {\n  if (processedItems.has(item)) {\n    return largeDataSet.get(item);\n  }\n  \n  // Expensive processing...\n  const result = expensiveProcessing(item);\n  \n  largeDataSet.set(item, result);\n  processedItems.add(item);\n  \n  return result;\n};",
  "quickstart": "import { action, state } from 'react-understate';\n\n// Create a reactive state with initial value\nexport const count = state(0, 'count');\n\n// Create an action to increment the count\nexport const increment = action(() => count.value + 1);\n\n// Create an action to decrement the count\nexport const decrement = action(() => count.value - 1);\n\n// Create an action to reset the count\nexport const reset = action(() => (count.value = 0));\n",
  "quickstart2": "import React from 'react';\nimport { useSubscribe } from 'react-understate';\n\nfunction Counter() {\n  // Subscribe to state changes\n  const { count: currentCount } = useSubscribe({ count });\n\n  const increment = () => count.set(currentCount + 1);\n  const decrement = () => count.set(currentCount - 1);\n  const reset = () => count.set(0);\n\n  return (\n    <div>\n      <h2>Count: {currentCount}</h2>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}",
  "quickstart3": "import { state, derived, useSubscribe } from 'react-understate';\n\nconst count = state(0);\n\n// Derived state automatically recalculates\nconst doubled = derived(() => count.value * 2);\nconst isEven = derived(() => count.value % 2 === 0);\n\nfunction EnhancedCounter() {\n  const { count: currentCount, doubled: doubledValue, isEven } = useSubscribe({\n    count,\n    doubled,\n    isEven\n  });\n\n  return (\n    <div>\n      <h2>Count: {currentCount}</h2>\n      <p>Doubled: {doubledValue}</p>\n      <p>Is Even: {isEven ? 'Yes' : 'No'}</p>\n      <button onClick={() => count.value = currentCount + 1}>\n        Increment\n      </button>\n    </div>\n  );\n}",
  "quickstartArrays": "import React from 'react';\nimport { arrayState, useUnderstate } from 'react-understate';\n\n// Create array state for a todo list\nconst todos = arrayState<string>(['Learn React', 'Build app'], {\n  name: 'todos',\n});\n\n// Derived value for todo count\nconst todoCount = () => todos.length;\n\n// Actions for todo operations\nconst addTodo = (text: string) => {\n  todos.push(text);\n};\n\nconst removeTodo = (index: number) => {\n  todos.splice(index, 1);\n};\n\nconst clearTodos = () => {\n  todos.clear();\n};\n\n// React component\nfunction TodoList() {\n  const [todoItems] = useUnderstate(todos);\n  const [count] = useUnderstate({ todoCount });\n\n  return (\n    <div>\n      <h3>Todo List ({count} items)</h3>\n\n      <div>\n        <input\n          type=\"text\"\n          placeholder=\"Add a todo...\"\n          onKeyDown={e => {\n            if (e.key === 'Enter') {\n              const input = e.target as HTMLInputElement;\n              if (input.value.trim()) {\n                addTodo(input.value.trim());\n                input.value = '';\n              }\n            }\n          }}\n        />\n        <button onClick={clearTodos}>Clear All</button>\n      </div>\n\n      <ul>\n        {todoItems.map((todo, index) => (\n          <li key={index}>\n            {todo}\n            <button onClick={() => removeTodo(index)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n\n      {todoItems.length === 0 && <p>No todos yet. Add one above!</p>}\n    </div>\n  );\n}\n\nexport { TodoList, addTodo, removeTodo, clearTodos };\n\n",
  "quickstartBasicCounter": "import { useUnderstate } from 'react-understate';\nimport * as store from './quickstart';\n\nexport function Counter() {\n  // Subscribe to state changes\n  const { count, increment, decrement, reset } = useUnderstate(store);\n\n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n",
  "quickstartBatching": "import { state, batch, effect } from 'react-understate';\n\nexport const firstName = state<null | string>(null, 'firstName');\nexport const lastName = state<null | string>(null, 'lastName');\n\neffect(() => {\n  console.log(`${firstName.value} ${lastName.value}`);\n});\n\n// Batch updates to prevent multiple re-renders\nbatch(() => {\n  firstName.value = 'John';\n  lastName.value = 'Doe';\n});\n\n// Logs: \"John Doe\"\n",
  "quickstartDerivedState": "import { state, derived, useSubscribe } from 'react-understate';\n\nconst count = state(0);\n\n// Derived state automatically recalculates\nconst doubled = derived(() => count.value * 2);\nconst isEven = derived(() => count.value % 2 === 0);\n\nfunction EnhancedCounter() {\n  const {\n    count: currentCount,\n    doubled: doubledValue,\n    isEven,\n  } = useSubscribe({\n    count,\n    doubled,\n    isEven,\n  });\n\n  return (\n    <div>\n      <h2>Count: {currentCount}</h2>\n      <p>Doubled: {doubledValue}</p>\n      <p>Is Even: {isEven ? 'Yes' : 'No'}</p>\n      <button onClick={() => (count.value = currentCount + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n",
  "quickstartEffects": "import { state, effect, action } from 'react-understate';\n\nconst count = state(0);\n\n// Effect runs whenever count changes\neffect(() => {\n  console.log('state: Count changed to:', count.value);\n});\n\n// Create actions for state updates\nconst setCount = action((value: number) => {\n  count.value = value;\n}, 'setCount');\n\n// Use actions to update state\nsetCount(5);\n// Logs: \"state: Count changed to: 5\"\n\nsetCount(10);\n// Logs: \"state: Count changed to: 10\"\n",
  "quickstartObjects": "import { state, useUnderstate } from 'react-understate';\n\nconst store = {\n  user: state({\n    name: 'John Doe',\n    email: 'john@example.com',\n    age: 30,\n  }),\n  updateName: (name: string) => {\n    user.value = { ...user.value, name };\n  },\n  incrementAge: () => {\n    user.value = { ...user.value, age: user.value.age + 1 };\n  },\n};\n\nexport function UserProfile() {\n  const { user, updateName, incrementAge } = useUnderstate(store);\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n      <p>Age: {user.age}</p>\n      <button onClick={() => updateName('Jane Doe')}>Change Name</button>\n      <button onClick={incrementAge}>Birthday!</button>\n    </div>\n  );\n}\n",
  "stateManagementArrayState": "import { arrayState, state, action } from 'react-understate';\n\n// Basic array state\nconst items = arrayState<string>(['apple', 'banana', 'cherry'], {\n  name: 'fruits',\n});\n\n// Array state with objects\ntype Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nconst todos = arrayState<Todo>(\n  [\n    { id: 1, text: 'Learn React', completed: false },\n    { id: 2, text: 'Build app', completed: true },\n  ],\n  { name: 'todos' },\n);\n\n// Regular state for comparison\nconst regularArray = state<string[]>(['a', 'b', 'c'], 'regularArray');\n\n// Actions for array operations\nconst addItem = action((item: string) => {\n  items.push(item);\n}, 'addItem');\n\nconst removeItem = action((index: number) => {\n  items.splice(index, 1);\n}, 'removeItem');\n\nconst updateItem = action((index: number, newItem: string) => {\n  items.splice(index, 1, newItem);\n}, 'updateItem');\n\nconst sortItems = action(() => {\n  items.sort();\n}, 'sortItems');\n\n// Todo actions\nconst addTodo = action((text: string) => {\n  const newId = Math.max(...todos.map(t => t.id), 0) + 1;\n  todos.push({ id: newId, text, completed: false });\n}, 'addTodo');\n\nconst toggleTodo = action((id: number) => {\n  const index = todos.findIndex(todo => todo.id === id);\n  if (index !== -1) {\n    todos.splice(index, 1, {\n      ...todos[index],\n      completed: !todos[index].completed,\n    });\n  }\n}, 'toggleTodo');\n\nconst clearCompleted = action(() => {\n  todos.filter(todo => !todo.completed);\n}, 'clearCompleted');\n\n// Derived values\nconst completedTodos = () => todos.filter(todo => todo.completed);\nconst pendingTodos = () => todos.filter(todo => !todo.completed);\nconst todoStats = () => ({\n  total: todos.length,\n  completed: completedTodos().length,\n  pending: pendingTodos().length,\n});\n\n// Array state methods demonstration\nconst demonstrateArrayMethods = () => {\n  // Mutating methods (trigger subscriptions)\n  items.push('date', 'elderberry');\n  items.pop();\n  items.unshift('apricot');\n  items.shift();\n  items.splice(1, 2, 'blueberry', 'coconut');\n  items.sort();\n  items.reverse();\n  items.fill('grape', 1, 3);\n\n  // Non-mutating methods (don't trigger subscriptions)\n  const first = items.at(0);\n  const last = items.at(-1);\n  const sliced = items.slice(1, 3);\n  const joined = items.join(', ');\n  const found = items.find(item => item.startsWith('b'));\n  const filtered = items.filter(item => item.length > 5);\n  const mapped = items.map(item => item.toUpperCase());\n  const reduced = items.reduce((acc, item) => acc + item.length, 0);\n\n  // Utility methods\n  items.clear();\n  items.set(['new', 'array', 'items']);\n  items.batch(arr => {\n    arr.push('batch1');\n    arr.push('batch2');\n    arr.sort();\n  });\n};\n\nexport {\n  items,\n  todos,\n  regularArray,\n  addItem,\n  removeItem,\n  updateItem,\n  sortItems,\n  addTodo,\n  toggleTodo,\n  clearCompleted,\n  completedTodos,\n  pendingTodos,\n  todoStats,\n  demonstrateArrayMethods,\n};\n\n",
  "stateManagementComposition": "import { state, derived } from 'react-understate';\n\n// ❌ Avoid: Monolithic state\nexport const badAppState = state({\n  user: { id: 1, name: 'John' },\n  todos: [{ id: 1, text: 'Learn React' }],\n  ui: { theme: 'dark', sidebar: true },\n  settings: { notifications: true },\n  // ... everything in one giant object\n});\n\n// ✅ Good: Atomic state composition\nexport const user = state(\n  {\n    id: null as number | null,\n    name: '',\n    email: '',\n  },\n  { name: 'user' },\n);\n\ntype Todo = { id: number; text: string };\nexport const todos = state<Todo[]>([], { name: 'todos' });\n\nexport const uiSettings = state(\n  {\n    theme: 'light' as 'light' | 'dark',\n    sidebarOpen: false,\n  },\n  { name: 'uiSettings' },\n);\n\nexport const userSettings = state(\n  {\n    notifications: true,\n    autoSave: false,\n    language: 'en',\n  },\n  { name: 'userSettings' },\n);\n\n// Compose when needed\nexport const appData = derived(\n  () => ({\n    user: user(),\n    todos: todos(),\n    ui: uiSettings(),\n    settings: userSettings(),\n  }),\n  { name: 'appData' },\n);\n",
  "stateManagementCreatingState": "import { state } from 'react-understate';\n\n// Simple primitive state\nexport const count = state(0, { name: 'count' });\nexport const message = state('Hello World', { name: 'message' });\nexport const isVisible = state(true, { name: 'isVisible' });\n\n// Object state\nexport type User = {\n  id: number | null;\n  name: string;\n  email: string;\n  isLoggedIn: boolean;\n};\n\nexport const user = state<User>(\n  {\n    id: null,\n    name: '',\n    email: '',\n    isLoggedIn: false,\n  },\n  { name: 'user' },\n);\n\n// Array state\nexport const items = state<string[]>([], { name: 'items' });\n\n// Complex nested state\nexport const appState = state(\n  {\n    ui: {\n      theme: 'light' as 'light' | 'dark',\n      sidebar: {\n        open: false,\n        width: 250,\n      },\n    },\n    data: {\n      users: [] as User[],\n      loading: false,\n      error: null as string | null,\n    },\n  },\n  { name: 'appState' },\n);\n",
  "stateManagementEntityPattern": "import { state, action, batch } from 'react-understate';\n\ntype Todo = {\n  id: string;\n  text: string;\n  completed: boolean;\n  createdAt: Date;\n};\n\nexport const todos = state<Todo[]>([], { name: 'todos' });\nexport const selectedTodoId = state<string | null>(null, {\n  name: 'selectedTodoId',\n});\n\n// Helper actions for complex operations\nexport const addTodo = action(\n  (text: string) => {\n    console.log('action: adding todo', text);\n\n    const newTodo: Todo = {\n      id: `todo-${Date.now()}`,\n      text,\n      completed: false,\n      createdAt: new Date(),\n    };\n\n    todos(prev => [...prev, newTodo]);\n  },\n  { name: 'addTodo' },\n);\n\nexport const updateTodo = action(\n  (id: string, updates: Partial<Todo>) => {\n    console.log('action: updating todo', id, updates);\n\n    todos(prev =>\n      prev.map(todo => (todo.id === id ? { ...todo, ...updates } : todo)),\n    );\n  },\n  { name: 'updateTodo' },\n);\n\nexport const deleteTodo = action(\n  (id: string) => {\n    console.log('action: deleting todo', id);\n\n    todos(prev => prev.filter(todo => todo.id !== id));\n\n    // Clear selection if deleted todo was selected\n    if (selectedTodoId() === id) {\n      selectedTodoId(null);\n    }\n  },\n  { name: 'deleteTodo' },\n);\n\nexport const toggleTodo = action(\n  (id: string) => {\n    console.log('action: toggling todo', id);\n\n    updateTodo(id, {\n      completed: !todos().find(t => t.id === id)?.completed,\n    });\n  },\n  { name: 'toggleTodo' },\n);\n\n// Batch operations for performance\nexport const markAllCompleted = action(\n  () => {\n    console.log('action: marking all todos completed');\n\n    batch(() => {\n      todos(prev => prev.map(todo => ({ ...todo, completed: true })));\n    });\n  },\n  { name: 'markAllCompleted' },\n);\n\nexport const clearCompleted = action(\n  () => {\n    console.log('action: clearing completed todos');\n\n    const completedIds = todos()\n      .filter(t => t.completed)\n      .map(t => t.id);\n\n    batch(() => {\n      todos(prev => prev.filter(todo => !todo.completed));\n\n      // Clear selection if selected todo was completed\n      if (selectedTodoId() && completedIds.includes(selectedTodoId()!)) {\n        selectedTodoId(null);\n      }\n    });\n  },\n  { name: 'clearCompleted' },\n);\n",
  "stateManagementNormalization": "import { state, action, batch, derived } from 'react-understate';\n\n// ❌ Avoid: Nested relational data\nexport const badState = state({\n  posts: [\n    {\n      id: 1,\n      title: 'Post 1',\n      author: { id: 1, name: 'John', email: 'john@example.com' },\n      comments: [\n        { id: 1, text: 'Great post!', author: { id: 2, name: 'Jane' } },\n        { id: 2, text: 'Thanks!', author: { id: 1, name: 'John' } },\n      ],\n    },\n  ],\n});\n\n// ✅ Good: Normalized state structure\nexport const users = state<Record<string, User>>({}, { name: 'users' });\nexport const posts = state<Record<string, Post>>({}, { name: 'posts' });\nexport const comments = state<Record<string, Comment>>(\n  {},\n  { name: 'comments' },\n);\n\nexport type User = {\n  id: string;\n  name: string;\n  email: string;\n};\n\nexport type Post = {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  commentIds: string[];\n};\n\nexport type Comment = {\n  id: string;\n  text: string;\n  postId: string;\n  authorId: string;\n};\n\n// Actions for normalized updates\nexport const addUser = action(\n  (user: User) => {\n    console.log('action: adding user', user.id);\n    users(prev => ({ ...prev, [user.id]: user }));\n  },\n  { name: 'addUser' },\n);\n\nexport const addPost = action(\n  (post: Omit<Post, 'commentIds'>) => {\n    console.log('action: adding post', post.id);\n    posts(prev => ({\n      ...prev,\n      [post.id]: { ...post, commentIds: [] },\n    }));\n  },\n  { name: 'addPost' },\n);\n\nexport const addComment = action(\n  (comment: Comment) => {\n    console.log('action: adding comment', comment.id);\n\n    batch(() => {\n      // Add comment\n      comments(prev => ({ ...prev, [comment.id]: comment }));\n\n      // Update post's comment list\n      posts(prev => ({\n        ...prev,\n        [comment.postId]: {\n          ...prev[comment.postId],\n          commentIds: [...prev[comment.postId].commentIds, comment.id],\n        },\n      }));\n    });\n  },\n  { name: 'addComment' },\n);\n\n// Selectors for denormalized views\nexport const getPostWithAuthor = (postId: string) =>\n  derived(\n    () => {\n      const post = posts()[postId];\n      const author = post ? users()[post.authorId] : null;\n\n      return post && author ? { ...post, author } : null;\n    },\n    { name: `postWithAuthor-${postId}` },\n  );\n\nexport const getPostWithComments = (postId: string) =>\n  derived(\n    () => {\n      const post = posts()[postId];\n      if (!post) return null;\n\n      const postComments = post.commentIds\n        .map(id => {\n          const comment = comments()[id];\n          const author = comment ? users()[comment.authorId] : null;\n          return comment && author ? { ...comment, author } : null;\n        })\n        .filter(Boolean) as Array<Comment & { author: User }>;\n\n      return {\n        ...post,\n        author: users()[post.authorId],\n        comments: postComments,\n      };\n    },\n    { name: `postWithComments-${postId}` },\n  );\n",
  "stateManagementPerformance": "import { state, derived, action, batch, useUnderstate } from 'react-understate';\nimport React from 'react';\n\n// 1. Granular subscriptions\nconst user = state({ name: 'John', email: 'john@example.com' }, { name: 'user' });\n\n// ❌ Avoid: Subscribing to entire large objects\nexport function BadUserProfile() {\n  const userData = useUnderstate(user); // Re-renders on any user property change\n  return <h1>{userData.name}</h1>; // Only needs name\n}\n\n// ✅ Good: Subscribe to specific properties\nexport const userName = derived(() => user().name, { name: 'userName' });\n\nexport function GoodUserProfile() {\n  const name = useUnderstate(userName); // Only re-renders when name changes\n  return <h1>{name}</h1>;\n}\n\n// 2. Memoized selectors for expensive computations\nconst largeDataSet = state<Array<{ id: number; name: string; category: string; active: boolean; priority: number }>>([], { name: 'largeDataSet' });\n\nexport const expensiveComputation = derived(() => {\n  const data = largeDataSet();\n  \n  // Expensive calculation only runs when data changes\n  return data\n    .filter(item => item.active)\n    .sort((a, b) => b.priority - a.priority)\n    .map(item => ({\n      ...item,\n      displayName: `${item.name} (${item.category})`,\n    }));\n}, { name: 'expensiveComputation' });\n\n// 3. Conditional subscriptions\nconst shouldShowList = state(true, { name: 'shouldShowList' });\nconst expensiveItems = derived(() => expensiveComputation(), { name: 'expensiveItems' });\n\nexport function ConditionalList() {\n  const showList = useUnderstate(shouldShowList);\n  \n  // Only subscribe to items when list is visible\n  const items = useUnderstate(showList ? expensiveItems : state([]));\n  \n  return showList ? (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  ) : null;\n}\n\n// 4. Batching updates for better performance\nconst todos = state<Array<{ id: string; text: string }>>([], { name: 'todos' });\nconst uiSettings = state({ theme: 'light' as 'light' | 'dark' }, { name: 'uiSettings' });\n\nexport const batchedUpdate = action(() => {\n  console.log('action: performing batched update');\n  \n  batch(() => {\n    // All these updates are batched into a single re-render\n    user(prev => ({ ...prev, name: 'New Name' }));\n    user(prev => ({ ...prev, email: 'new@email.com' }));\n    todos(prev => [...prev, { id: `${Date.now()}`, text: 'New todo' }]);\n    uiSettings(prev => ({ ...prev, theme: 'dark' }));\n  });\n}, { name: 'batchedUpdate' });\n\n// 5. Lazy initialization for expensive default values\nexport const expensiveState = state(() => {\n  // This function only runs once, when state is first accessed\n  console.log('Initializing expensive state...');\n  return performExpensiveCalculation();\n}, { name: 'expensiveState' });\n\nfunction performExpensiveCalculation() {\n  let sum = 0;\n  for (let i = 0; i < 10000; i++) sum += i;\n  return sum;\n}\n\n// 6. State splitting for large lists\nexport const createPaginatedState = <T,>(pageSize = 50) => {\n  const allItems = state<T[]>([], { name: 'allItems' });\n  const currentPage = state(0, { name: 'currentPage' });\n  \n  const totalPages = derived(() => \n    Math.ceil(allItems().length / pageSize)\n  , { name: 'totalPages' });\n  \n  const currentPageItems = derived(() => {\n    const items = allItems();\n    const page = currentPage();\n    const start = page * pageSize;\n    return items.slice(start, start + pageSize);\n  }, { name: 'currentPageItems' });\n  \n  return {\n    allItems,\n    currentPage,\n    totalPages,\n    currentPageItems,\n    pageSize,\n  };\n};\n\n\n",
  "stateManagementReadingState": "import React from 'react';\nimport { state, derived, useUnderstate } from 'react-understate';\n\nconst count = state(0, { name: 'count' });\nconst user = state({ name: 'John' }, { name: 'user' });\n\n// Direct access (outside React components)\nconst currentCount = count();\nconst currentUser = user();\n\n// In React components - single state\nexport function Counter() {\n  const countValue = useUnderstate(count);\n  return <div>Count: {countValue}</div>;\n}\n\n// In React components - multiple states\nexport function UserProfile() {\n  const { user: userData, count: countValue } = useUnderstate({\n    user,\n    count,\n  });\n\n  return (\n    <div>\n      <h1>{userData.name}</h1>\n      <p>Count: {countValue}</p>\n    </div>\n  );\n}\n\n// Selective subscription (performance optimization)\nexport function UserName() {\n  // Only re-renders when user.name changes\n  const userName = useUnderstate(derived(() => user().name));\n  return <h1>{userName}</h1>;\n}\n\n// Conditional subscription\nexport function ConditionalDisplay() {\n  const isVisible = state(true, { name: 'isVisible' });\n  const message = state('Hello', { name: 'message' });\n\n  const { isVisible: visible, message: msg } = useUnderstate({\n    isVisible,\n    message: isVisible() ? message : state(''), // Only subscribe when visible\n  });\n\n  return visible ? <p>{msg}</p> : null;\n}\n",
  "stateManagementUpdates": "import { state, action } from 'react-understate';\n\n// Basic states\nexport const count = state(0, { name: 'count' });\nexport const message = state('Hello World', { name: 'message' });\nexport const isVisible = state(true, { name: 'isVisible' });\nexport const items = state<string[]>([], { name: 'items' });\n\n// Object states\nexport type User = {\n  id: number | null;\n  name: string;\n  email: string;\n  isLoggedIn: boolean;\n  loading?: boolean;\n  error?: string | null;\n};\n\nexport const user = state<User>(\n  {\n    id: null,\n    name: '',\n    email: '',\n    isLoggedIn: false,\n    loading: false,\n    error: null,\n  },\n  { name: 'user' },\n);\n\nexport const appState = state(\n  {\n    ui: {\n      theme: 'light' as 'light' | 'dark',\n      sidebar: {\n        open: false,\n        width: 250,\n      },\n    },\n  },\n  { name: 'appState' },\n);\n\n// ✅ Recommended: Use actions for state updates\nexport const setCount = action((value: number) => {\n  count(value);\n}, 'setCount');\n\nexport const setMessage = action((msg: string) => {\n  message(msg);\n}, 'setMessage');\n\nexport const setVisibility = action((visible: boolean) => {\n  isVisible(visible);\n}, 'setVisibility');\n\nexport const incrementCount = action(() => {\n  count(prev => prev + 1);\n}, 'incrementCount');\n\nexport const addItem = action((item: string) => {\n  items(prev => [...prev, item]);\n}, 'addItem');\n\nexport const updateUser = action((updates: Partial<User>) => {\n  user(prev => ({ ...prev, ...updates }));\n}, 'updateUser');\n\nexport const toggleSidebar = action(() => {\n  appState(prev => ({\n    ...prev,\n    ui: {\n      ...prev.ui,\n      sidebar: {\n        ...prev.ui.sidebar,\n        open: !prev.ui.sidebar.open,\n      },\n    },\n  }));\n}, 'toggleSidebar');\n\n// Multiple updates (automatically batched by the library)\nexport const updateProfile = action((name: string, email: string) => {\n  user(prev => ({ ...prev, name }));\n  user(prev => ({ ...prev, email }));\n}, 'updateProfile');\n\n// Mock async function\nasync function fetchUser(\n  id: number,\n): Promise<Pick<User, 'id' | 'name' | 'email'>> {\n  await new Promise(r => setTimeout(r, 10));\n  return { id, name: 'Jane Doe', email: 'jane@example.com' };\n}\n\n// Async updates using actions\nexport const loadUser = action(async (id: number) => {\n  user(prev => ({ ...prev, loading: true, error: null }));\n\n  try {\n    const userData = await fetchUser(id);\n    user(prev => ({\n      ...prev,\n      ...userData,\n      loading: false,\n      isLoggedIn: true,\n    }));\n  } catch (e) {\n    const err = e as Error;\n    user(prev => ({\n      ...prev,\n      loading: false,\n      error: err.message,\n    }));\n  }\n}, 'loadUser');\n",
  "stateapicontent": "import { state, useUnderstate } from 'react-understate';\n\n// Create state with any primitive value\nconst count = state(0);\nconst name = state('John Doe');\nconst isLoggedIn = state(false);\n\nfunction Counter() {\n  const [currentCount] = useUnderstate(count);\n  \n  return (\n    <div>\n      <h2>Count: {currentCount}</h2>\n      <button onClick={() => count.value++}>\n        Increment\n      </button>\n      <button onClick={() => count.value = 0}>\n        Reset\n      </button>\n    </div>\n  );\n}",
  "stateapicontent10": "import { state } from 'react-understate';\n\n// Create reusable state factories\nfunction createCounterState(initialValue = 0) {\n  const count = state(initialValue);\n  \n  return {\n    count,\n    increment: () => count.value++,\n    decrement: () => count.value--,\n    reset: () => count.value = initialValue,\n    setValue: (value: number) => count.value = value\n  };\n}\n\n// Use in different parts of your app\nconst headerCounter = createCounterState(0);\nconst sidebarCounter = createCounterState(10);\nconst modalCounter = createCounterState(5);",
  "stateapicontent11": "import { state, derived } from 'react-understate';\n\n// Compose multiple states\nconst cart = {\n  items: state([]),\n  discount: state(0),\n  \n  // Methods that work with multiple states\n  addItem: (item) => {\n    cart.items.value = [...cart.items.value, item];\n  },\n  \n  applyDiscount: (percentage) => {\n    cart.discount.value = percentage;\n  }\n};\n\n// Derived values from multiple states\nconst cartTotal = derived(() => {\n  const items = cart.items.value;\n  const discount = cart.discount.value;\n  \n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  return subtotal * (1 - discount / 100);\n});",
  "stateapicontent2": "import { state, useUnderstate } from 'react-understate';\n\n// Object state\nconst user = state({\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  preferences: {\n    theme: 'dark',\n    notifications: true\n  }\n});\n\n// Array state  \nconst todos = state([\n  { id: 1, text: 'Learn React Understate', completed: false },\n  { id: 2, text: 'Build awesome app', completed: false }\n]);\n\nfunction UserProfile() {\n  const [currentUser] = useUnderstate(user);\n  const [currentTodos] = useUnderstate(todos);\n  \n  const updateTheme = () => {\n    user.value = {\n      ...user.value,\n      preferences: {\n        ...user.value.preferences,\n        theme: user.value.preferences.theme === 'dark' ? 'light' : 'dark'\n      }\n    };\n  };\n  \n  const addTodo = (text: string) => {\n    todos.value = [\n      ...todos.value,\n      { id: Date.now(), text, completed: false }\n    ];\n  };\n  \n  return (\n    <div>\n      <h2>{currentUser.name}</h2>\n      <p>Theme: {currentUser.preferences.theme}</p>\n      <button onClick={updateTheme}>Toggle Theme</button>\n      \n      <h3>Todos ({currentTodos.length})</h3>\n      {currentTodos.map(todo => (\n        <div key={todo.id}>{todo.text}</div>\n      ))}\n    </div>\n  );\n}",
  "stateapicontent3": "import { state, useUnderstate } from 'react-understate';\n\n// Store functions in state\nconst mathOperation = state((a: number, b: number) => a + b);\nconst validationRules = state({\n  email: (email: string) => /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/.test(email),\n  password: (pwd: string) => pwd.length >= 8\n});\n\nfunction Calculator() {\n  const [operation] = useUnderstate(mathOperation);\n  const [rules] = useUnderstate(validationRules);\n  \n  const switchToMultiply = () => {\n    mathOperation.value = (a, b) => a * b;\n  };\n  \n  return (\n    <div>\n      <p>5 + 3 = {operation(5, 3)}</p>\n      <button onClick={switchToMultiply}>\n        Switch to Multiplication\n      </button>\n      \n      <p>Valid email: {rules.email('test@example.com') ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}",
  "stateapicontent4": "import { state } from 'react-understate';\n\nconst counter = state(0);\nconst settings = state({ theme: 'light', lang: 'en' });\n\n// Read values directly\nconsole.log(counter.value); // 0\nconsole.log(settings.value.theme); // 'light'\n\n// Update values directly\ncounter.value = 10;\ncounter.value++; // Now 11\n\n// Update objects (always replace the entire object)\nsettings.value = { ...settings.value, theme: 'dark' };\n\n// Or completely replace\nsettings.value = { theme: 'auto', lang: 'fr' };",
  "stateapicontent5": "import { state } from 'react-understate';\n\nconst count = state(0);\n\n// Subscribe to changes\nconst unsubscribe = count.subscribe((newValue, previousValue) => {\n  console.log(`Count changed from ${previousValue} to ${newValue}`);\n});\n\n// Trigger the subscription\ncount.value = 5; // Logs: \"Count changed from 0 to 5\"\ncount.value = 10; // Logs: \"Count changed from 5 to 10\"\n\n// Clean up when done\nunsubscribe();\n\n// Multiple subscribers\nconst unsubscribe1 = count.subscribe((value) => {\n  localStorage.setItem('count', String(value));\n});\n\nconst unsubscribe2 = count.subscribe((value) => {\n  if (value > 100) {\n    alert('Count is getting high!');\n  }\n});\n\n// Clean up all\nconst cleanup = () => {\n  unsubscribe1();\n  unsubscribe2();\n};",
  "stateapicontent6": "import { state, configureDebug } from 'react-understate';\n\n// Enable debugging globally\nconfigureDebug({ enabled: true, showFile: true });\n\n// Create state with debug names\nconst userCount = state(0, 'userCount');\nconst activeUsers = state([], 'activeUsersList');\nconst appSettings = state({\n  theme: 'light',\n  notifications: true\n}, 'appSettings');\n\n// Changes will now be logged with names:\nuserCount.value = 42; \n// Logs: \"[userCount] State changed from 0 to 42\"\n\nactiveUsers.value = [{ id: 1, name: 'John' }];\n// Logs: \"[activeUsersList] State changed from [] to [{ id: 1, name: 'John' }]\"",
  "stateapicontent7": "import { state, configureDebug } from 'react-understate';\n\n// Enable debugging globally\nconfigureDebug({ enabled: true, showFile: true });\n\n// Create state with debug names\nconst userCount = state(0, 'userCount');\nconst activeUsers = state([], 'activeUsersList');\nconst appSettings = state({\n  theme: 'light',\n  notifications: true\n}, 'appSettings');\n\n// Changes will now be logged with names:\nuserCount.value = 42; \n// Logs: \"[userCount] State changed from 0 to 42\"\n\nactiveUsers.value = [{ id: 1, name: 'John' }];\n// Logs: \"[activeUsersList] State changed from [] to [{ id: 1, name: 'John' }]\"",
  "stateapicontent8": "const settings = state({ theme: 'light', lang: 'en' });\n\n// ❌ Wrong - mutating doesn't trigger updates\nsettings.value.theme = 'dark'; // Won't update components!\n\n// ✅ Correct - replace the object\nsettings.value = { ...settings.value, theme: 'dark' };\n\n// ✅ Also correct - completely new object\nsettings.value = { theme: 'dark', lang: 'en' };",
  "stateapicontent9": "// ❌ One large state - changing name updates everything\nconst user = state({\n  profile: { name: '', email: '', bio: '' },\n  preferences: { theme: 'light', notifications: true },\n  activities: [...] // Large array\n});\n\n// ✅ Split into focused states\nconst userProfile = state({ name: '', email: '', bio: '' });\nconst userPreferences = state({ theme: 'light', notifications: true });\nconst userActivities = state([...]);\n\n// Components only re-render when their specific state changes",
  "statecomposition": "import { state } from 'react-understate';\n\n// Create reusable state factories\nfunction createCounterState(initialValue = 0) {\n  const count = state(initialValue);\n  \n  return {\n    count,\n    increment: () => count.value++,\n    decrement: () => count.value--,\n    reset: () => count.value = initialValue,\n    setValue: (value: number) => count.value = value,\n  };\n}\n\n// Use in different parts of your app\nconst headerCounter = createCounterState(0);\nconst sidebarCounter = createCounterState(10);\nconst modalCounter = createCounterState(5);\n\n// Each instance is independent\nheaderCounter.increment(); // Only affects headerCounter\nsidebarCounter.setValue(20); // Only affects sidebarCounter",
  "statecomposition2": "import { state, derived, action, batch } from 'react-understate';\n\n// Compose multiple states into a cohesive module\nconst cart = {\n  // State\n  items: state([]),\n  discount: state(0),\n  shipping: state(0),\n  taxRate: state(0.08),\n  \n  // Derived values\n  subtotal: derived(() => {\n    return cart.items.value.reduce((sum, item) => sum + item.price, 0);\n  }),\n  \n  discountAmount: derived(() => {\n    return cart.subtotal.value * (cart.discount.value / 100);\n  }),\n  \n  total: derived(() => {\n    const subtotal = cart.subtotal.value;\n    const discount = cart.discountAmount.value;\n    const shipping = cart.shipping.value;\n    const tax = (subtotal - discount + shipping) * cart.taxRate.value;\n    \n    return subtotal - discount + shipping + tax;\n  }),\n  \n  // Actions\n  addItem: action((item) => {\n    cart.items.value = [...cart.items.value, item];\n  }, 'addItem'),\n  \n  removeItem: action((itemId) => {\n    cart.items.value = cart.items.value.filter(item => item.id !== itemId);\n  }, 'removeItem'),\n  \n  updateQuantity: action((itemId, quantity) => {\n    cart.items.value = cart.items.value.map(item =>\n      item.id === itemId ? { ...item, quantity } : item\n    );\n  }, 'updateQuantity'),\n  \n  applyDiscount: action((percentage) => {\n    cart.discount.value = percentage;\n  }, 'applyDiscount'),\n  \n  setShipping: action((cost) => {\n    cart.shipping.value = cost;\n  }, 'setShipping'),\n  \n  // Complex actions that work with multiple states\n  clearCart: action(() => {\n    batch(() => {\n      cart.items.value = [];\n      cart.discount.value = 0;\n      cart.shipping.value = 0;\n    });\n  }, 'clearCart'),\n  \n  // Async actions\n  checkout: action(async () => {\n    try {\n      const response = await fetch('/api/checkout', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          items: cart.items.value,\n          discount: cart.discount.value,\n          shipping: cart.shipping.value,\n          total: cart.total.value,\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error('Checkout failed');\n      }\n      \n      cart.clearCart();\n      return await response.json();\n    } catch (error) {\n      console.error('Checkout error:', error);\n      throw error;\n    }\n  }, 'checkout'),\n};",
  "statecomposition3": "import { state, derived, action } from 'react-understate';\n\nfunction createFormState<T extends Record<string, any>>(\n  initialValues: T,\n  validationRules?: Partial<Record<keyof T, (value: any) => string | null>>\n) {\n  const values = state(initialValues);\n  const errors = state({} as Partial<Record<keyof T, string>>);\n  const touched = state({} as Partial<Record<keyof T, boolean>>);\n  const isSubmitting = state(false);\n  \n  // Derived values\n  const isValid = derived(() => {\n    return Object.values(errors.value).every(error => !error);\n  });\n  \n  const isDirty = derived(() => {\n    return JSON.stringify(values.value) !== JSON.stringify(initialValues);\n  });\n  \n  // Actions\n  const setValue = action((field: keyof T, value: any) => {\n    values.value = { ...values.value, [field]: value };\n    \n    // Clear error when user starts typing\n    if (errors.value[field]) {\n      errors.value = { ...errors.value, [field]: undefined };\n    }\n  }, 'setValue');\n  \n  const setTouched = action((field: keyof T) => {\n    touched.value = { ...touched.value, [field]: true };\n  }, 'setTouched');\n  \n  const validate = action(() => {\n    if (!validationRules) return true;\n    \n    const newErrors = {} as Partial<Record<keyof T, string>>;\n    \n    for (const [field, rule] of Object.entries(validationRules)) {\n      const value = values.value[field as keyof T];\n      const error = rule(value);\n      if (error) {\n        newErrors[field as keyof T] = error;\n      }\n    }\n    \n    errors.value = newErrors;\n    return Object.keys(newErrors).length === 0;\n  }, 'validate');\n  \n  const reset = action(() => {\n    values.value = initialValues;\n    errors.value = {};\n    touched.value = {};\n    isSubmitting.value = false;\n  }, 'reset');\n  \n  const submit = action(async (onSubmit: (values: T) => Promise<void>) => {\n    if (!validate()) return false;\n    \n    isSubmitting.value = true;\n    \n    try {\n      await onSubmit(values.value);\n      return true;\n    } catch (error) {\n      console.error('Form submission error:', error);\n      return false;\n    } finally {\n      isSubmitting.value = false;\n    }\n  }, 'submit');\n  \n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isValid,\n    isDirty,\n    setValue,\n    setTouched,\n    validate,\n    reset,\n    submit,\n  };\n}\n\n// Usage\nconst userForm = createFormState(\n  { name: '', email: '', age: 0 },\n  {\n    name: (value) => value.length < 2 ? 'Name must be at least 2 characters' : null,\n    email: (value) => !value.includes('@') ? 'Invalid email' : null,\n    age: (value) => value < 18 ? 'Must be 18 or older' : null,\n  }\n);",
  "statecomposition4": "import { state, derived, action } from 'react-understate';\n\n// Base user state\nconst userState = {\n  profile: state({ id: null, name: '', email: '' }),\n  isAuthenticated: state(false),\n  \n  login: action(async (credentials) => {\n    // Login logic...\n    userState.isAuthenticated.value = true;\n  }, 'login'),\n  \n  logout: action(() => {\n    userState.profile.value = { id: null, name: '', email: '' };\n    userState.isAuthenticated.value = false;\n  }, 'logout'),\n};\n\n// Preferences that depend on user\nconst preferencesState = {\n  theme: state('light'),\n  language: state('en'),\n  notifications: state(true),\n  \n  // Derived from user state\n  canEdit: derived(() => userState.isAuthenticated.value),\n  \n  updateTheme: action((theme) => {\n    if (preferencesState.canEdit.value) {\n      preferencesState.theme.value = theme;\n    }\n  }, 'updateTheme'),\n};\n\n// Settings that depend on both user and preferences\nconst settingsState = {\n  autoSave: state(true),\n  syncEnabled: state(false),\n  \n  // Derived from multiple states\n  isFullyConfigured: derived(() => {\n    return userState.isAuthenticated.value && \n           preferencesState.theme.value !== 'light' &&\n           settingsState.autoSave.value;\n  }),\n  \n  // Actions that work across modules\n  resetAll: action(() => {\n    preferencesState.theme.value = 'light';\n    preferencesState.language.value = 'en';\n    settingsState.autoSave.value = true;\n    settingsState.syncEnabled.value = false;\n  }, 'resetAll'),\n};",
  "statemanagement": "// ❌ Avoid: Direct state updates\nconst count = state(0, { name: 'count' });\n\n// Direct assignment\ncount.value = 42;\n\n// Direct function call\ncount(prev => prev + 1);\n\n// ✅ Good: Use actions for state updates\nconst count = state(0, { name: 'count' });\n\nconst setCount = action((value: number) => {\n  count.value = value;\n}, 'setCount');\n\nconst incrementCount = action(() => {\n  count.value = count.value + 1;\n}, 'incrementCount');\n\n// Use actions instead\nsetCount(42);\nincrementCount();",
  "statemanagement10": "// ❌ Don't mutate state directly\nconst badUpdate = () => {\n  const currentTodos = todos();\n  currentTodos.push(newTodo); // Mutates the array!\n  todos(currentTodos); // This won't trigger updates correctly\n};\n\n// ✅ Always create new objects/arrays\nconst goodUpdate = () => {\n  todos(prev => [...prev, newTodo]);\n};\n\n// ❌ Don't create state inside components\nfunction BadComponent() {\n  const [localState] = useState(() => state(0)); // Creates new state on every render!\n  return <div>{useUnderstate(localState)}</div>;\n}\n\n// ✅ Create state outside components or use useState for local state\nconst componentState = state(0, { name: 'componentState' });\n\nfunction GoodComponent() {\n  const value = useUnderstate(componentState);\n  return <div>{value}</div>;\n}\n\n// ❌ Don't use state for derived values\nconst totalItems = state(0, { name: 'totalItems' });\n\nconst updateTotal = () => {\n  totalItems(todos().length); // Manual sync required!\n};\n\n// ✅ Use derived for computed values\nconst totalItems = derived(() => todos().length, { name: 'totalItems' });\n\n// ❌ Don't ignore batching for multiple updates\nconst slowUpdate = () => {\n  user(prev => ({ ...prev, name: 'John' }));    // Triggers re-render\n  user(prev => ({ ...prev, email: 'john@...' })); // Triggers re-render\n  user(prev => ({ ...prev, age: 30 }));           // Triggers re-render\n};\n\n// ✅ Use batch() for multiple related updates\nconst fastUpdate = () => {\n  batch(() => {\n    user(prev => ({ ...prev, name: 'John' }));\n    user(prev => ({ ...prev, email: 'john@...' }));\n    user(prev => ({ ...prev, age: 30 }));\n    // Only one re-render for all updates\n  });\n};\n\n// ❌ Don't create circular dependencies\nconst a = derived(() => b() + 1, { name: 'a' });\nconst b = derived(() => a() + 1, { name: 'b' }); // Circular!\n\n// ✅ Design dependencies as a directed acyclic graph\nconst base = state(0, { name: 'base' });\nconst derived1 = derived(() => base() + 1, { name: 'derived1' });\nconst derived2 = derived(() => derived1() * 2, { name: 'derived2' });",
  "statemanagement2": "import { configureDebug } from 'react-understate';\n\n// Enable debug logging in development\nif (process.env.NODE_ENV === 'development') {\n  configureDebug({\n    enabled: true,\n    logStateChanges: true,\n    logActionCalls: true,\n    logDerivedUpdates: true,\n    filter: (name) => {\n      // Only log specific states/actions\n      return name.includes('user') || name.includes('todo');\n    },\n  });\n}\n\n// Custom debug logging for specific states\nexport const debuggedUser = state({ name: '', email: '' }, {\n  name: 'debuggedUser',\n  debug: {\n    logChanges: true,\n    beforeChange: (oldValue, newValue) => {\n      console.log('User changing from:', oldValue, 'to:', newValue);\n    },\n    afterChange: (newValue) => {\n      console.log('User changed to:', newValue);\n    },\n  },\n});\n\n// Debug utilities\nexport const stateSnapshot = () => {\n  return {\n    user: user(),\n    todos: todos(),\n    ui: uiSettings(),\n    timestamp: new Date().toISOString(),\n  };\n};\n\nexport const logStateSnapshot = action(() => {\n  console.log('action: logging state snapshot');\n  console.table(stateSnapshot());\n}, { name: 'logStateSnapshot' });\n\n// Performance monitoring\nexport const performanceMonitor = effect(() => {\n  const startTime = performance.now();\n  \n  // Track expensive derived value\n  const result = expensiveComputation();\n  \n  const endTime = performance.now();\n  const duration = endTime - startTime;\n  \n  if (duration > 16) { // Longer than one frame\n    console.warn(`Expensive computation took ${duration.toFixed(2)}ms`);\n  }\n  \n  return result;\n}, { name: 'performanceMonitor' });",
  "statemanagement3": "// 1. Loading states pattern\nexport const createAsyncState = <T>(initialData: T) => {\n  const data = state(initialData, { name: 'data' });\n  const loading = state(false, { name: 'loading' });\n  const error = state<string | null>(null, { name: 'error' });\n  \n  const isIdle = derived(() => !loading() && !error(), { name: 'isIdle' });\n  const hasError = derived(() => error() !== null, { name: 'hasError' });\n  \n  return { data, loading, error, isIdle, hasError };\n};\n\n// 2. Form state pattern\nexport const createFormState = <T extends Record<string, any>>(initialValues: T) => {\n  const values = state(initialValues, { name: 'formValues' });\n  const errors = state<Partial<Record<keyof T, string>>>({}, { name: 'formErrors' });\n  const touched = state<Partial<Record<keyof T, boolean>>>({}, { name: 'formTouched' });\n  const isSubmitting = state(false, { name: 'isSubmitting' });\n  \n  const isValid = derived(() => Object.keys(errors()).length === 0, { name: 'isValid' });\n  const isDirty = derived(() => {\n    const current = values();\n    return Object.keys(current).some(key => current[key] !== initialValues[key]);\n  }, { name: 'isDirty' });\n  \n  const setValue = action((field: keyof T, value: any) => {\n    values(prev => ({ ...prev, [field]: value }));\n    touched(prev => ({ ...prev, [field]: true }));\n  }, { name: 'setValue' });\n  \n  const setError = action((field: keyof T, error: string) => {\n    errors(prev => ({ ...prev, [field]: error }));\n  }, { name: 'setError' });\n  \n  const clearError = action((field: keyof T) => {\n    errors(prev => {\n      const { [field]: _, ...rest } = prev;\n      return rest;\n    });\n  }, { name: 'clearError' });\n  \n  const reset = action(() => {\n    values(initialValues);\n    errors({});\n    touched({});\n    isSubmitting(false);\n  }, { name: 'reset' });\n  \n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isValid,\n    isDirty,\n    setValue,\n    setError,\n    clearError,\n    reset,\n  };\n};\n\n// 3. Modal/Dialog state pattern\nexport const createModalState = () => {\n  const isOpen = state(false, { name: 'modalOpen' });\n  const data = state<any>(null, { name: 'modalData' });\n  \n  const open = action((modalData?: any) => {\n    console.log('action: opening modal');\n    isOpen(true);\n    if (modalData !== undefined) {\n      data(modalData);\n    }\n  }, { name: 'openModal' });\n  \n  const close = action(() => {\n    console.log('action: closing modal');\n    isOpen(false);\n    data(null);\n  }, { name: 'closeModal' });\n  \n  const toggle = action(() => {\n    console.log('action: toggling modal');\n    isOpen(prev => !prev);\n  }, { name: 'toggleModal' });\n  \n  return { isOpen, data, open, close, toggle };\n};\n\n// Usage examples\nexport const userAsyncState = createAsyncState({ id: null, name: '', email: '' });\nexport const loginForm = createFormState({ email: '', password: '' });\nexport const confirmModal = createModalState();",
  "statemanagement4": "// ❌ Don't mutate state directly\nconst badUpdate = () => {\n  const currentTodos = todos();\n  currentTodos.push(newTodo); // Mutates the array!\n  todos(currentTodos); // This won't trigger updates correctly\n};\n\n// ✅ Always create new objects/arrays\nconst goodUpdate = () => {\n  todos(prev => [...prev, newTodo]);\n};\n\n// ❌ Don't create state inside components\nfunction BadComponent() {\n  const [localState] = useState(() => state(0)); // Creates new state on every render!\n  return <div>{useUnderstate(localState)}</div>;\n}\n\n// ✅ Create state outside components or use useState for local state\nconst componentState = state(0, { name: 'componentState' });\n\nfunction GoodComponent() {\n  const value = useUnderstate(componentState);\n  return <div>{value}</div>;\n}\n\n// ❌ Don't use state for derived values\nconst totalItems = state(0, { name: 'totalItems' });\n\nconst updateTotal = () => {\n  totalItems(todos().length); // Manual sync required!\n};\n\n// ✅ Use derived for computed values\nconst totalItems = derived(() => todos().length, { name: 'totalItems' });\n\n// ❌ Don't ignore batching for multiple updates\nconst slowUpdate = () => {\n  user(prev => ({ ...prev, name: 'John' }));    // Triggers re-render\n  user(prev => ({ ...prev, email: 'john@...' })); // Triggers re-render\n  user(prev => ({ ...prev, age: 30 }));           // Triggers re-render\n};\n\n// ✅ Use batch() for multiple related updates\nconst fastUpdate = () => {\n  batch(() => {\n    user(prev => ({ ...prev, name: 'John' }));\n    user(prev => ({ ...prev, email: 'john@...' }));\n    user(prev => ({ ...prev, age: 30 }));\n    // Only one re-render for all updates\n  });\n};\n\n// ❌ Don't create circular dependencies\nconst a = derived(() => b() + 1, { name: 'a' });\nconst b = derived(() => a() + 1, { name: 'b' }); // Circular!\n\n// ✅ Design dependencies as a directed acyclic graph\nconst base = state(0, { name: 'base' });\nconst derived1 = derived(() => base() + 1, { name: 'derived1' });\nconst derived2 = derived(() => derived1() * 2, { name: 'derived2' });",
  "statemanagement5": "// Entity management pattern\ntype Todo = {\n  id: string;\n  text: string;\n  completed: boolean;\n  createdAt: Date;\n};\n\nexport const todos = state<Todo[]>([], { name: 'todos' });\nexport const selectedTodoId = state<string | null>(null, { name: 'selectedTodoId' });\n\n// Helper actions for complex operations\nexport const addTodo = action((text: string) => {\n  console.log('action: adding todo', text);\n  \n  const newTodo: Todo = {\n    id: \\`todo-\\${Date.now()}\\`,\n    text,\n    completed: false,\n    createdAt: new Date(),\n  };\n  \n  todos(prev => [...prev, newTodo]);\n}, { name: 'addTodo' });\n\nexport const updateTodo = action((id: string, updates: Partial<Todo>) => {\n  console.log('action: updating todo', id, updates);\n  \n  todos(prev => prev.map(todo =>\n    todo.id === id ? { ...todo, ...updates } : todo\n  ));\n}, { name: 'updateTodo' });\n\nexport const deleteTodo = action((id: string) => {\n  console.log('action: deleting todo', id);\n  \n  todos(prev => prev.filter(todo => todo.id !== id));\n  \n  // Clear selection if deleted todo was selected\n  if (selectedTodoId() === id) {\n    selectedTodoId(null);\n  }\n}, { name: 'deleteTodo' });\n\nexport const toggleTodo = action((id: string) => {\n  console.log('action: toggling todo', id);\n  \n  updateTodo(id, { \n    completed: !todos().find(t => t.id === id)?.completed \n  });\n}, { name: 'toggleTodo' });\n\n// Batch operations for performance\nexport const markAllCompleted = action(() => {\n  console.log('action: marking all todos completed');\n  \n  batch(() => {\n    todos(prev => prev.map(todo => ({ ...todo, completed: true })));\n  });\n}, { name: 'markAllCompleted' });\n\nexport const clearCompleted = action(() => {\n  console.log('action: clearing completed todos');\n  \n  const completedIds = todos().filter(t => t.completed).map(t => t.id);\n  \n  batch(() => {\n    todos(prev => prev.filter(todo => !todo.completed));\n    \n    // Clear selection if selected todo was completed\n    if (selectedTodoId() && completedIds.includes(selectedTodoId()!)) {\n      selectedTodoId(null);\n    }\n  });\n}, { name: 'clearCompleted' });",
  "statemanagement6": "// ❌ Avoid: Nested relational data\nconst badState = state({\n  posts: [\n    {\n      id: 1,\n      title: 'Post 1',\n      author: { id: 1, name: 'John', email: 'john@example.com' },\n      comments: [\n        { id: 1, text: 'Great post!', author: { id: 2, name: 'Jane' } },\n        { id: 2, text: 'Thanks!', author: { id: 1, name: 'John' } },\n      ],\n    },\n    // ... more posts with duplicated author data\n  ],\n});\n\n// ✅ Good: Normalized state structure\nexport const users = state<Record<string, User>>({}, { name: 'users' });\nexport const posts = state<Record<string, Post>>({}, { name: 'posts' });\nexport const comments = state<Record<string, Comment>>({}, { name: 'comments' });\n\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n};\n\ntype Post = {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  commentIds: string[];\n};\n\ntype Comment = {\n  id: string;\n  text: string;\n  postId: string;\n  authorId: string;\n};\n\n// Actions for normalized updates\nexport const addUser = action((user: User) => {\n  console.log('action: adding user', user.id);\n  users(prev => ({ ...prev, [user.id]: user }));\n}, { name: 'addUser' });\n\nexport const addPost = action((post: Omit<Post, 'commentIds'>) => {\n  console.log('action: adding post', post.id);\n  posts(prev => ({\n    ...prev,\n    [post.id]: { ...post, commentIds: [] },\n  }));\n}, { name: 'addPost' });\n\nexport const addComment = action((comment: Comment) => {\n  console.log('action: adding comment', comment.id);\n  \n  batch(() => {\n    // Add comment\n    comments(prev => ({ ...prev, [comment.id]: comment }));\n    \n    // Update post's comment list\n    posts(prev => ({\n      ...prev,\n      [comment.postId]: {\n        ...prev[comment.postId],\n        commentIds: [...prev[comment.postId].commentIds, comment.id],\n      },\n    }));\n  });\n}, { name: 'addComment' });\n\n// Selectors for denormalized views\nexport const getPostWithAuthor = (postId: string) => derived(() => {\n  const post = posts()[postId];\n  const author = post ? users()[post.authorId] : null;\n  \n  return post && author ? { ...post, author } : null;\n}, { name: \\`postWithAuthor-\\${postId}\\` });\n\nexport const getPostWithComments = (postId: string) => derived(() => {\n  const post = posts()[postId];\n  if (!post) return null;\n  \n  const postComments = post.commentIds.map(id => {\n    const comment = comments()[id];\n    const author = comment ? users()[comment.authorId] : null;\n    return comment && author ? { ...comment, author } : null;\n  }).filter(Boolean);\n  \n  return {\n    ...post,\n    author: users()[post.authorId],\n    comments: postComments,\n  };\n}, { name: \\`postWithComments-\\${postId}\\` });",
  "statemanagement7": "// 1. Granular subscriptions\n// ❌ Avoid: Subscribing to entire large objects\nfunction UserProfile() {\n  const userData = useUnderstate(user); // Re-renders on any user property change\n  return <h1>{userData.name}</h1>; // Only needs name\n}\n\n// ✅ Good: Subscribe to specific properties\nconst userName = derived(() => user().name, { name: 'userName' });\n\nfunction UserProfile() {\n  const name = useUnderstate(userName); // Only re-renders when name changes\n  return <h1>{name}</h1>;\n}\n\n// 2. Memoized selectors for expensive computations\nexport const expensiveComputation = derived(() => {\n  const data = largeDataSet();\n  \n  // Expensive calculation only runs when data changes\n  return data\n    .filter(item => item.active)\n    .sort((a, b) => b.priority - a.priority)\n    .map(item => ({\n      ...item,\n      displayName: \\`\\${item.name} (\\${item.category})\\`,\n    }));\n}, { name: 'expensiveComputation' });\n\n// 3. Conditional subscriptions\nfunction ConditionalList() {\n  const showList = useUnderstate(shouldShowList);\n  \n  // Only subscribe to items when list is visible\n  const items = useUnderstate(showList ? expensiveItems : state([]));\n  \n  return showList ? (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  ) : null;\n}\n\n// 4. Batching updates for better performance\nexport const batchedUpdate = action(() => {\n  console.log('action: performing batched update');\n  \n  batch(() => {\n    // All these updates are batched into a single re-render\n    user(prev => ({ ...prev, name: 'New Name' }));\n    user(prev => ({ ...prev, email: 'new@email.com' }));\n    todos(prev => [...prev, newTodo]);\n    uiSettings(prev => ({ ...prev, theme: 'dark' }));\n  });\n}, { name: 'batchedUpdate' });\n\n// 5. Lazy initialization for expensive default values\nexport const expensiveState = state(() => {\n  // This function only runs once, when state is first accessed\n  console.log('Initializing expensive state...');\n  return performExpensiveCalculation();\n}, { name: 'expensiveState' });\n\n// 6. State splitting for large lists\n// Instead of one large array, split into chunks\nexport const createPaginatedState = <T>(pageSize = 50) => {\n  const allItems = state<T[]>([], { name: 'allItems' });\n  const currentPage = state(0, { name: 'currentPage' });\n  \n  const totalPages = derived(() => \n    Math.ceil(allItems().length / pageSize)\n  , { name: 'totalPages' });\n  \n  const currentPageItems = derived(() => {\n    const items = allItems();\n    const page = currentPage();\n    const start = page * pageSize;\n    return items.slice(start, start + pageSize);\n  }, { name: 'currentPageItems' });\n  \n  return {\n    allItems,\n    currentPage,\n    totalPages,\n    currentPageItems,\n    pageSize,\n  };\n};",
  "statemanagement8": "import { configureDebug } from 'react-understate';\n\n// Enable debug logging in development\nif (process.env.NODE_ENV === 'development') {\n  configureDebug({\n    enabled: true,\n    logStateChanges: true,\n    logActionCalls: true,\n    logDerivedUpdates: true,\n    filter: (name) => {\n      // Only log specific states/actions\n      return name.includes('user') || name.includes('todo');\n    },\n  });\n}\n\n// Custom debug logging for specific states\nexport const debuggedUser = state({ name: '', email: '' }, {\n  name: 'debuggedUser',\n  debug: {\n    logChanges: true,\n    beforeChange: (oldValue, newValue) => {\n      console.log('User changing from:', oldValue, 'to:', newValue);\n    },\n    afterChange: (newValue) => {\n      console.log('User changed to:', newValue);\n    },\n  },\n});\n\n// Debug utilities\nexport const stateSnapshot = () => {\n  return {\n    user: user(),\n    todos: todos(),\n    ui: uiSettings(),\n    timestamp: new Date().toISOString(),\n  };\n};\n\nexport const logStateSnapshot = action(() => {\n  console.log('action: logging state snapshot');\n  console.table(stateSnapshot());\n}, { name: 'logStateSnapshot' });\n\n// Performance monitoring\nexport const performanceMonitor = effect(() => {\n  const startTime = performance.now();\n  \n  // Track expensive derived value\n  const result = expensiveComputation();\n  \n  const endTime = performance.now();\n  const duration = endTime - startTime;\n  \n  if (duration > 16) { // Longer than one frame\n    console.warn(\\`Expensive computation took \\${duration.toFixed(2)}ms\\`);\n  }\n  \n  return result;\n}, { name: 'performanceMonitor' });",
  "statemanagement9": "// 1. Loading states pattern\nexport const createAsyncState = <T>(initialData: T) => {\n  const data = state(initialData, { name: 'data' });\n  const loading = state(false, { name: 'loading' });\n  const error = state<string | null>(null, { name: 'error' });\n  \n  const isIdle = derived(() => !loading() && !error(), { name: 'isIdle' });\n  const hasError = derived(() => error() !== null, { name: 'hasError' });\n  \n  return { data, loading, error, isIdle, hasError };\n};\n\n// 2. Form state pattern\nexport const createFormState = <T extends Record<string, any>>(initialValues: T) => {\n  const values = state(initialValues, { name: 'formValues' });\n  const errors = state<Partial<Record<keyof T, string>>>({}, { name: 'formErrors' });\n  const touched = state<Partial<Record<keyof T, boolean>>>({}, { name: 'formTouched' });\n  const isSubmitting = state(false, { name: 'isSubmitting' });\n  \n  const isValid = derived(() => Object.keys(errors()).length === 0, { name: 'isValid' });\n  const isDirty = derived(() => {\n    const current = values();\n    return Object.keys(current).some(key => current[key] !== initialValues[key]);\n  }, { name: 'isDirty' });\n  \n  const setValue = action((field: keyof T, value: any) => {\n    values(prev => ({ ...prev, [field]: value }));\n    touched(prev => ({ ...prev, [field]: true }));\n  }, { name: 'setValue' });\n  \n  const setError = action((field: keyof T, error: string) => {\n    errors(prev => ({ ...prev, [field]: error }));\n  }, { name: 'setError' });\n  \n  const clearError = action((field: keyof T) => {\n    errors(prev => {\n      const { [field]: _, ...rest } = prev;\n      return rest;\n    });\n  }, { name: 'clearError' });\n  \n  const reset = action(() => {\n    values(initialValues);\n    errors({});\n    touched({});\n    isSubmitting(false);\n  }, { name: 'reset' });\n  \n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isValid,\n    isDirty,\n    setValue,\n    setError,\n    clearError,\n    reset,\n  };\n};\n\n// 3. Modal/Dialog state pattern\nexport const createModalState = () => {\n  const isOpen = state(false, { name: 'modalOpen' });\n  const data = state<any>(null, { name: 'modalData' });\n  \n  const open = action((modalData?: any) => {\n    console.log('action: opening modal');\n    isOpen(true);\n    if (modalData !== undefined) {\n      data(modalData);\n    }\n  }, { name: 'openModal' });\n  \n  const close = action(() => {\n    console.log('action: closing modal');\n    isOpen(false);\n    data(null);\n  }, { name: 'closeModal' });\n  \n  const toggle = action(() => {\n    console.log('action: toggling modal');\n    isOpen(prev => !prev);\n  }, { name: 'toggleModal' });\n  \n  return { isOpen, data, open, close, toggle };\n};\n\n// Usage examples\nexport const userAsyncState = createAsyncState({ id: null, name: '', email: '' });\nexport const loginForm = createFormState({ email: '', password: '' });\nexport const confirmModal = createModalState();",
  "storepattern": "// store.ts\nimport { state, derived, action } from 'react-understate';\n\n// State variables\nconst count = state(0, 'count');\nconst multiplier = state(2, 'multiplier');\n\n// Derived values\nexport const result = derived(() => count.value * multiplier.value, 'result');\n\n// Actions\nexport const increment = action(() => {\n  count.value++;\n}, 'increment');\n\nexport const setCount = action((value: number) => {\n  count.value = value;\n}, 'setCount');\n\nexport const setMultiplier = action((value: number) => {\n  multiplier.value = value;\n}, 'setMultiplier');\n\n// Export the store object\nexport const counterStore = {\n  // State access\n  count,\n  multiplier,\n  \n  // Computed values\n  result,\n  \n  // Actions\n  increment,\n  setCount,\n  setMultiplier,\n};",
  "storepattern2": "// todoStore.ts\nimport {\n  state,\n  derived,\n  action,\n  persistLocalStorage,\n} from 'react-understate';\n\n// Types\nexport type Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nexport type FilterType = 'all' | 'active' | 'completed';\n\n// State variables\nconst todos = state<Todo[]>([], 'todos');\nconst filter = state<FilterType>('all', 'todosFilter');\nconst newTodo = state('', 'newTodo');\n\n// Persistence\npersistLocalStorage(todos, 'todos');\npersistLocalStorage(filter, 'todos-filter');\n\n// Derived values\nexport const filteredTodos = derived(() => {\n  switch (filter.value) {\n    case 'active':\n      return todos.value.filter(todo => !todo.completed);\n    case 'completed':\n      return todos.value.filter(todo => todo.completed);\n    default:\n      return todos.value;\n  }\n}, 'filteredTodos');\n\nexport const activeCount = derived(\n  () => todos.value.filter(todo => !todo.completed).length,\n  'activeCount',\n);\n\nexport const completedCount = derived(\n  () => todos.value.filter(todo => todo.completed).length,\n  'completedCount',\n);\n\nexport const totalCount = derived(() => todos.value.length, 'totalCount');\n\nexport const hasCompletedTodos = derived(\n  () => completedCount.value > 0,\n  'hasCompletedTodos',\n);\n\nexport const allCompleted = derived(\n  () => totalCount.value > 0 && activeCount.value === 0,\n  'allCompleted',\n);\n\n// Actions\nexport const setNewTodo = action((text: string) => {\n  newTodo.value = text;\n}, 'setNewTodo');\n\nexport const setFilter = action((newFilter: FilterType) => {\n  filter.value = newFilter;\n}, 'setFilter');\n\nexport const addTodo = action(() => {\n  if (newTodo.value.trim()) {\n    todos.value = [\n      ...todos.value,\n      {\n        id: Date.now(),\n        text: newTodo.value.trim(),\n        completed: false,\n      },\n    ];\n    newTodo.value = '';\n  }\n}, 'addTodo');\n\nexport const toggleTodo = action((id: number) => {\n  todos.value = todos.value.map(todo =>\n    todo.id === id ? { ...todo, completed: !todo.completed } : todo,\n  );\n}, 'toggleTodo');\n\nexport const removeTodo = action((id: number) => {\n  todos.value = todos.value.filter(todo => todo.id !== id);\n}, 'removeTodo');\n\nexport const updateTodo = action((id: number, text: string) => {\n  todos.value = todos.value.map(todo =>\n    todo.id === id ? { ...todo, text } : todo,\n  );\n}, 'updateTodo');\n\nexport const clearCompleted = action(() => {\n  todos.value = todos.value.filter(todo => !todo.completed);\n}, 'clearCompleted');\n\nexport const toggleAll = action(() => {\n  const shouldComplete = !allCompleted.value;\n  todos.value = todos.value.map(todo => ({\n    ...todo,\n    completed: shouldComplete,\n  }));\n}, 'toggleAll');\n\n// Export the complete store\nexport const todoStore = {\n  // State access\n  todos,\n  filter,\n  newTodo,\n  \n  // Computed values\n  filteredTodos,\n  activeCount,\n  completedCount,\n  totalCount,\n  hasCompletedTodos,\n  allCompleted,\n  \n  // Actions\n  setNewTodo,\n  setFilter,\n  addTodo,\n  toggleTodo,\n  removeTodo,\n  updateTodo,\n  clearCompleted,\n  toggleAll,\n};",
  "storepattern3": "// TodoApp.tsx\nimport React from 'react';\nimport { useUnderstate } from 'react-understate';\nimport { todoStore } from './todoStore';\n\nfunction TodoApp() {\n  const {\n    filteredTodos,\n    newTodo,\n    activeCount,\n    hasCompletedTodos,\n    filter,\n    addTodo,\n    setNewTodo,\n    toggleTodo,\n    removeTodo,\n    setFilter,\n    clearCompleted,\n    toggleAll,\n  } = useUnderstate(todoStore);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    addTodo();\n  };\n\n  return (\n    <div className=\"todo-app\">\n      <header>\n        <h1>Todos</h1>\n        <form onSubmit={handleSubmit}>\n          <input\n            type=\"text\"\n            placeholder=\"What needs to be done?\"\n            value={newTodo}\n            onChange={(e) => setNewTodo(e.target.value)}\n          />\n        </form>\n      </header>\n\n      <main>\n        {filteredTodos.length > 0 && (\n          <button onClick={toggleAll}>\n            {allCompleted ? '☑️' : '☐'} Toggle All\n          </button>\n        )}\n\n        <ul className=\"todo-list\">\n          {filteredTodos.map(todo => (\n            <li key={todo.id} className={todo.completed ? 'completed' : ''}>\n              <input\n                type=\"checkbox\"\n                checked={todo.completed}\n                onChange={() => toggleTodo(todo.id)}\n              />\n              <span>{todo.text}</span>\n              <button onClick={() => removeTodo(todo.id)}>×</button>\n            </li>\n          ))}\n        </ul>\n      </main>\n\n      <footer>\n        <span>{activeCount} items left</span>\n        \n        <div className=\"filters\">\n          {(['all', 'active', 'completed'] as const).map(filterType => (\n            <button\n              key={filterType}\n              className={filter === filterType ? 'active' : ''}\n              onClick={() => setFilter(filterType)}\n            >\n              {filterType.charAt(0).toUpperCase() + filterType.slice(1)}\n            </button>\n          ))}\n        </div>\n\n        {hasCompletedTodos && (\n          <button onClick={clearCompleted}>\n            Clear completed\n          </button>\n        )}\n      </footer>\n    </div>\n  );\n}",
  "storepattern4": "// Compose multiple stores\nimport { todoStore } from './todoStore';\nimport { userStore } from './userStore';\nimport { settingsStore } from './settingsStore';\n\n// Create a root store that combines all features\nexport const appStore = {\n  ...todoStore,\n  ...userStore,\n  ...settingsStore,\n};\n\n// Or organize by namespaces\nexport const appStore = {\n  todos: todoStore,\n  user: userStore,\n  settings: settingsStore,\n};\n\n// Usage in component\nfunction App() {\n  const { todos, user, settings } = useUnderstate(appStore);\n  // ... component logic\n}",
  "storepattern5": "export const addTodoWithValidation = action((text: string) => {\n  // Validation logic\n  if (!text.trim()) {\n    console.warn('Cannot add empty todo');\n    return;\n  }\n  \n  if (text.length > 100) {\n    console.warn('Todo text too long');\n    return;\n  }\n  \n  // Check for duplicates\n  if (todos.value.some(todo => todo.text === text.trim())) {\n    console.warn('Todo already exists');\n    return;\n  }\n  \n  // Add the todo\n  todos.value = [\n    ...todos.value,\n    {\n      id: Date.now(),\n      text: text.trim(),\n      completed: false,\n    },\n  ];\n  \n  // Clear input\n  newTodo.value = '';\n}, 'addTodoWithValidation');",
  "storepattern6": "export const saveTodoToServer = action(async (todo: Todo) => {\n  try {\n    // Optimistic update\n    todos.value = [...todos.value, todo];\n    \n    // Save to server\n    const response = await fetch('/api/todos', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(todo),\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to save todo');\n    }\n    \n    const savedTodo = await response.json();\n    \n    // Update with server response\n    todos.value = todos.value.map(t => \n      t.id === todo.id ? savedTodo : t\n    );\n    \n  } catch (error) {\n    // Rollback on error\n    todos.value = todos.value.filter(t => t.id !== todo.id);\n    console.error('Failed to save todo:', error);\n  }\n}, 'saveTodoToServer');",
  "storepattern7": "// todoStore.test.ts\nimport { todoStore } from './todoStore';\n\ndescribe('Todo Store', () => {\n  beforeEach(() => {\n    // Reset state before each test\n    todoStore.todos.value = [];\n    todoStore.filter.value = 'all';\n    todoStore.newTodo.value = '';\n  });\n\n  test('adds a todo', () => {\n    todoStore.setNewTodo('Learn React Understate');\n    todoStore.addTodo();\n    \n    expect(todoStore.todos.value).toHaveLength(1);\n    expect(todoStore.todos.value[0].text).toBe('Learn React Understate');\n    expect(todoStore.newTodo.value).toBe('');\n  });\n\n  test('filters todos correctly', () => {\n    // Add some todos\n    todoStore.setNewTodo('Active todo');\n    todoStore.addTodo();\n    \n    todoStore.setNewTodo('Completed todo');\n    todoStore.addTodo();\n    todoStore.toggleTodo(todoStore.todos.value[1].id);\n    \n    // Test filtering\n    todoStore.setFilter('active');\n    expect(todoStore.filteredTodos.value).toHaveLength(1);\n    expect(todoStore.filteredTodos.value[0].completed).toBe(false);\n    \n    todoStore.setFilter('completed');\n    expect(todoStore.filteredTodos.value).toHaveLength(1);\n    expect(todoStore.filteredTodos.value[0].completed).toBe(true);\n  });\n\n  test('computes statistics correctly', () => {\n    // Add mixed todos\n    todoStore.setNewTodo('Todo 1');\n    todoStore.addTodo();\n    todoStore.setNewTodo('Todo 2');\n    todoStore.addTodo();\n    \n    // Complete one\n    todoStore.toggleTodo(todoStore.todos.value[0].id);\n    \n    expect(todoStore.totalCount.value).toBe(2);\n    expect(todoStore.activeCount.value).toBe(1);\n    expect(todoStore.completedCount.value).toBe(1);\n    expect(todoStore.hasCompletedTodos.value).toBe(true);\n  });\n});",
  "testing": "import { state, derived, action } from 'react-understate';\n\n// Basic state testing\ndescribe('State Testing', () => {\n  test('should initialize with correct value', () => {\n    const count = state(0, { name: 'count' });\n    expect(count()).toBe(0);\n  });\n\n  test('should update value correctly', () => {\n    const count = state(0, { name: 'count' });\n    \n    count(5);\n    expect(count()).toBe(5);\n    \n    count(prev => prev + 1);\n    expect(count()).toBe(6);\n  });\n\n  test('should handle object state updates', () => {\n    const user = state({ name: '', email: '' }, { name: 'user' });\n    \n    user(prev => ({ ...prev, name: 'John' }));\n    expect(user()).toEqual({ name: 'John', email: '' });\n    \n    user(prev => ({ ...prev, email: 'john@example.com' }));\n    expect(user()).toEqual({ name: 'John', email: 'john@example.com' });\n  });\n\n  test('should handle array state updates', () => {\n    const items = state<string[]>([], { name: 'items' });\n    \n    items(prev => [...prev, 'item1']);\n    expect(items()).toEqual(['item1']);\n    \n    items(prev => [...prev, 'item2']);\n    expect(items()).toEqual(['item1', 'item2']);\n    \n    items(prev => prev.filter(item => item !== 'item1'));\n    expect(items()).toEqual(['item2']);\n  });\n});\n\n// State with complex logic\ndescribe('Complex State Logic', () => {\n  test('should handle conditional updates', () => {\n    const isLoggedIn = state(false, { name: 'isLoggedIn' });\n    const user = state(null, { name: 'user' });\n    \n    const login = action((userData: any) => {\n      isLoggedIn(true);\n      user(userData);\n    }, { name: 'login' });\n    \n    const logout = action(() => {\n      isLoggedIn(false);\n      user(null);\n    }, { name: 'logout' });\n    \n    // Test login\n    login({ id: 1, name: 'John' });\n    expect(isLoggedIn()).toBe(true);\n    expect(user()).toEqual({ id: 1, name: 'John' });\n    \n    // Test logout\n    logout();\n    expect(isLoggedIn()).toBe(false);\n    expect(user()).toBe(null);\n  });\n\n  test('should handle state validation', () => {\n    const email = state('', { name: 'email' });\n    const isValidEmail = (email: string) => /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/.test(email);\n    \n    const setEmail = action((newEmail: string) => {\n      if (isValidEmail(newEmail)) {\n        email(newEmail);\n      } else {\n        throw new Error('Invalid email format');\n      }\n    }, { name: 'setEmail' });\n    \n    // Test valid email\n    setEmail('test@example.com');\n    expect(email()).toBe('test@example.com');\n    \n    // Test invalid email\n    expect(() => setEmail('invalid-email')).toThrow('Invalid email format');\n    expect(email()).toBe('test@example.com'); // Should not change\n  });\n});",
  "testing2": "// Testing derived values\ndescribe('Derived Values Testing', () => {\n  test('should compute derived value correctly', () => {\n    const firstName = state('John', { name: 'firstName' });\n    const lastName = state('Doe', { name: 'lastName' });\n    \n    const fullName = derived(() => `${firstName()} ${lastName()}`, {\n      name: 'fullName',\n    });\n    \n    expect(fullName()).toBe('John Doe');\n  });\n\n  test('should update when dependencies change', () => {\n    const count = state(0, { name: 'count' });\n    const multiplier = state(2, { name: 'multiplier' });\n    \n    const doubled = derived(() => count() * multiplier(), {\n      name: 'doubled',\n    });\n    \n    expect(doubled()).toBe(0);\n    \n    count(5);\n    expect(doubled()).toBe(10);\n    \n    multiplier(3);\n    expect(doubled()).toBe(15);\n  });\n\n  test('should handle complex derived logic', () => {\n    const todos = state<Todo[]>([], { name: 'todos' });\n    const filter = state('all', { name: 'filter' });\n    \n    const filteredTodos = derived(() => {\n      const allTodos = todos();\n      const currentFilter = filter();\n      \n      switch (currentFilter) {\n        case 'active':\n          return allTodos.filter(todo => !todo.completed);\n        case 'completed':\n          return allTodos.filter(todo => todo.completed);\n        default:\n          return allTodos;\n      }\n    }, { name: 'filteredTodos' });\n    \n    // Test with different filters\n    todos([\n      { id: '1', text: 'Todo 1', completed: false },\n      { id: '2', text: 'Todo 2', completed: true },\n    ]);\n    \n    expect(filteredTodos()).toHaveLength(2);\n    \n    filter('active');\n    expect(filteredTodos()).toHaveLength(1);\n    expect(filteredTodos()[0].text).toBe('Todo 1');\n    \n    filter('completed');\n    expect(filteredTodos()).toHaveLength(1);\n    expect(filteredTodos()[0].text).toBe('Todo 2');\n  });\n\n  test('should handle async derived values', async () => {\n    const userId = state<number | null>(null, { name: 'userId' });\n    \n    const userData = derived(async () => {\n      const id = userId();\n      if (!id) return null;\n      \n      // Simulate async operation\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return { id, name: `User ${id}` };\n    }, { name: 'userData' });\n    \n    userId(1);\n    \n    // Wait for async operation\n    await new Promise(resolve => setTimeout(resolve, 20));\n    \n    const data = await userData();\n    expect(data).toEqual({ id: 1, name: 'User 1' });\n  });\n});\n\n// Testing derived value performance\ndescribe('Derived Value Performance', () => {\n  test('should not recalculate unnecessarily', () => {\n    let calculationCount = 0;\n    \n    const base = state(0, { name: 'base' });\n    const expensive = derived(() => {\n      calculationCount++;\n      return base() * 2;\n    }, { name: 'expensive' });\n    \n    // Initial calculation\n    expect(expensive()).toBe(0);\n    expect(calculationCount).toBe(1);\n    \n    // Accessing without dependency change\n    expect(expensive()).toBe(0);\n    expect(calculationCount).toBe(1); // Should not recalculate\n    \n    // Dependency change\n    base(5);\n    expect(expensive()).toBe(10);\n    expect(calculationCount).toBe(2); // Should recalculate\n  });\n});",
  "testing3": "// Testing actions\ndescribe('Action Testing', () => {\n  test('should update state correctly', () => {\n    const count = state(0, { name: 'count' });\n    \n    const increment = action(() => {\n      count(prev => prev + 1);\n    }, { name: 'increment' });\n    \n    increment();\n    expect(count()).toBe(1);\n    \n    increment();\n    expect(count()).toBe(2);\n  });\n\n  test('should handle async actions', async () => {\n    const data = state(null, { name: 'data' });\n    const loading = state(false, { name: 'loading' });\n    const error = state(null, { name: 'error' });\n    \n    const fetchData = action(async () => {\n      loading(true);\n      error(null);\n      \n      try {\n        const result = await mockFetch('/api/data');\n        data(result);\n      } catch (err) {\n        error(err.message);\n      } finally {\n        loading(false);\n      }\n    }, { name: 'fetchData' });\n    \n    // Mock fetch function\n    const mockFetch = jest.fn().mockResolvedValue({ id: 1, name: 'Test' });\n    \n    await fetchData();\n    \n    expect(loading()).toBe(false);\n    expect(data()).toEqual({ id: 1, name: 'Test' });\n    expect(error()).toBe(null);\n  });\n\n  test('should handle action errors', async () => {\n    const error = state(null, { name: 'error' });\n    \n    const riskyAction = action(async () => {\n      throw new Error('Something went wrong');\n    }, { name: 'riskyAction' });\n    \n    await expect(riskyAction()).rejects.toThrow('Something went wrong');\n  });\n\n  test('should handle action composition', () => {\n    const user = state(null, { name: 'user' });\n    const isLoggedIn = state(false, { name: 'isLoggedIn' });\n    \n    const setUser = action((userData: any) => {\n      user(userData);\n    }, { name: 'setUser' });\n    \n    const login = action((userData: any) => {\n      setUser(userData);\n      isLoggedIn(true);\n    }, { name: 'login' });\n    \n    login({ id: 1, name: 'John' });\n    \n    expect(user()).toEqual({ id: 1, name: 'John' });\n    expect(isLoggedIn()).toBe(true);\n  });\n});\n\n// Testing action side effects\ndescribe('Action Side Effects', () => {\n  test('should call external functions', () => {\n    const mockCallback = jest.fn();\n    const count = state(0, { name: 'count' });\n    \n    const incrementWithCallback = action(() => {\n      count(prev => prev + 1);\n      mockCallback(count());\n    }, { name: 'incrementWithCallback' });\n    \n    incrementWithCallback();\n    \n    expect(mockCallback).toHaveBeenCalledWith(1);\n    expect(count()).toBe(1);\n  });\n\n  test('should handle API calls', async () => {\n    const mockApi = {\n      save: jest.fn().mockResolvedValue({ id: 1 }),\n      load: jest.fn().mockResolvedValue({ id: 1, name: 'Test' }),\n    };\n    \n    const data = state(null, { name: 'data' });\n    \n    const saveData = action(async (dataToSave: any) => {\n      const result = await mockApi.save(dataToSave);\n      data(result);\n    }, { name: 'saveData' });\n    \n    await saveData({ name: 'Test' });\n    \n    expect(mockApi.save).toHaveBeenCalledWith({ name: 'Test' });\n    expect(data()).toEqual({ id: 1 });\n  });\n});",
  "testing4": "// Testing effects\ndescribe('Effect Testing', () => {\n  test('should execute effect on dependency change', () => {\n    const count = state(0, { name: 'count' });\n    const effectSpy = jest.fn();\n    \n    const testEffect = effect(() => {\n      effectSpy(count());\n    }, { name: 'testEffect' });\n    \n    // Initial execution\n    expect(effectSpy).toHaveBeenCalledWith(0);\n    \n    // Dependency change\n    count(5);\n    expect(effectSpy).toHaveBeenCalledWith(5);\n    \n    count(10);\n    expect(effectSpy).toHaveBeenCalledWith(10);\n  });\n\n  test('should handle effect cleanup', () => {\n    const isActive = state(true, { name: 'isActive' });\n    const cleanupSpy = jest.fn();\n    \n    const testEffect = effect(() => {\n      if (isActive()) {\n        const interval = setInterval(() => {\n          console.log('tick');\n        }, 100);\n        \n        return () => {\n          cleanupSpy();\n          clearInterval(interval);\n        };\n      }\n    }, { name: 'testEffect' });\n    \n    // Trigger cleanup\n    isActive(false);\n    \n    // Wait for cleanup\n    setTimeout(() => {\n      expect(cleanupSpy).toHaveBeenCalled();\n    }, 200);\n  });\n\n  test('should handle async effects', async () => {\n    const userId = state<number | null>(null, { name: 'userId' });\n    const userData = state(null, { name: 'userData' });\n    \n    const userEffect = effect(async () => {\n      const id = userId();\n      if (id) {\n        const data = await mockFetchUser(id);\n        userData(data);\n      }\n    }, { name: 'userEffect' });\n    \n    // Mock fetch function\n    const mockFetchUser = jest.fn().mockResolvedValue({ id: 1, name: 'John' });\n    \n    userId(1);\n    \n    // Wait for async effect\n    await new Promise(resolve => setTimeout(resolve, 10));\n    \n    expect(mockFetchUser).toHaveBeenCalledWith(1);\n    expect(userData()).toEqual({ id: 1, name: 'John' });\n  });\n\n  test('should handle effect errors', () => {\n    const shouldError = state(false, { name: 'shouldError' });\n    const errorSpy = jest.fn();\n    \n    const errorEffect = effect(() => {\n      if (shouldError()) {\n        throw new Error('Effect error');\n      }\n    }, { name: 'errorEffect' });\n    \n    // Mock console.error to catch error\n    const originalError = console.error;\n    console.error = errorSpy;\n    \n    shouldError(true);\n    \n    expect(errorSpy).toHaveBeenCalled();\n    \n    console.error = originalError;\n  });\n});\n\n// Testing effect dependencies\ndescribe('Effect Dependencies', () => {\n  test('should only depend on accessed state', () => {\n    const state1 = state(0, { name: 'state1' });\n    const state2 = state(0, { name: 'state2' });\n    const effectSpy = jest.fn();\n    \n    const selectiveEffect = effect(() => {\n      // Only depends on state1\n      effectSpy(state1());\n    }, { name: 'selectiveEffect' });\n    \n    // Initial execution\n    expect(effectSpy).toHaveBeenCalledWith(0);\n    \n    // Change state1 - should trigger\n    state1(5);\n    expect(effectSpy).toHaveBeenCalledWith(5);\n    \n    // Change state2 - should not trigger\n    state2(10);\n    expect(effectSpy).toHaveBeenCalledTimes(2); // Only initial + state1 change\n  });\n});",
  "testing5": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { useUnderstate } from 'react-understate';\n\n// Test component\nconst Counter = () => {\n  const count = useUnderstate(counterState);\n  const increment = useUnderstate(incrementAction);\n  \n  return (\n    <div>\n      <span data-testid=\"count\">{count}</span>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n};\n\n// Testing React components\ndescribe('React Component Testing', () => {\n  beforeEach(() => {\n    // Reset state before each test\n    counterState(0);\n  });\n\n  test('should render initial state', () => {\n    render(<Counter />);\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('0');\n  });\n\n  test('should update when state changes', () => {\n    render(<Counter />);\n    \n    // Update state directly\n    counterState(5);\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('5');\n  });\n\n  test('should handle user interactions', () => {\n    render(<Counter />);\n    \n    const button = screen.getByText('Increment');\n    fireEvent.click(button);\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('1');\n  });\n\n  test('should handle multiple state subscriptions', () => {\n    const MultiStateComponent = () => {\n      const count = useUnderstate(counterState);\n      const name = useUnderstate(nameState);\n      \n      return (\n        <div>\n          <span data-testid=\"count\">{count}</span>\n          <span data-testid=\"name\">{name}</span>\n        </div>\n      );\n    };\n    \n    render(<MultiStateComponent />);\n    \n    counterState(5);\n    nameState('John');\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('5');\n    expect(screen.getByTestId('name')).toHaveTextContent('John');\n  });\n});\n\n// Testing component with effects\ndescribe('Component with Effects', () => {\n  test('should handle effect cleanup on unmount', () => {\n    const cleanupSpy = jest.fn();\n    \n    const EffectComponent = () => {\n      const count = useUnderstate(counterState);\n      \n      React.useEffect(() => {\n        const interval = setInterval(() => {\n          console.log('tick');\n        }, 100);\n        \n        return () => {\n          cleanupSpy();\n          clearInterval(interval);\n        };\n      }, [count]);\n      \n      return <div>{count}</div>;\n    };\n    \n    const { unmount } = render(<EffectComponent />);\n    \n    // Unmount component\n    unmount();\n    \n    expect(cleanupSpy).toHaveBeenCalled();\n  });\n});\n\n// Testing async components\ndescribe('Async Component Testing', () => {\n  test('should handle async state updates', async () => {\n    const AsyncComponent = () => {\n      const data = useUnderstate(asyncDataState);\n      const loading = useUnderstate(loadingState);\n      \n      if (loading) {\n        return <div>Loading...</div>;\n      }\n      \n      return <div data-testid=\"data\">{data?.name}</div>;\n    };\n    \n    render(<AsyncComponent />);\n    \n    // Trigger async update\n    loadingState(true);\n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n    \n    // Simulate async completion\n    await waitFor(() => {\n      loadingState(false);\n      asyncDataState({ name: 'Test Data' });\n    });\n    \n    expect(screen.getByTestId('data')).toHaveTextContent('Test Data');\n  });\n});",
  "testing6": "// Integration testing\ndescribe('Integration Tests', () => {\n  test('should handle complete user flow', async () => {\n    // Setup\n    const user = state(null, { name: 'user' });\n    const isLoggedIn = state(false, { name: 'isLoggedIn' });\n    const todos = state<Todo[]>([], { name: 'todos' });\n    \n    const login = action(async (credentials: any) => {\n      const userData = await mockLogin(credentials);\n      user(userData);\n      isLoggedIn(true);\n    }, { name: 'login' });\n    \n    const addTodo = action((text: string) => {\n      const newTodo: Todo = {\n        id: Date.now().toString(),\n        text,\n        completed: false,\n      };\n      todos(prev => [...prev, newTodo]);\n    }, { name: 'addTodo' });\n    \n    const toggleTodo = action((id: string) => {\n      todos(prev => prev.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      ));\n    }, { name: 'toggleTodo' });\n    \n    // Mock API\n    const mockLogin = jest.fn().mockResolvedValue({ id: 1, name: 'John' });\n    \n    // Test complete flow\n    await login({ email: 'john@example.com', password: 'password' });\n    \n    expect(isLoggedIn()).toBe(true);\n    expect(user()).toEqual({ id: 1, name: 'John' });\n    \n    addTodo('Learn React Understate');\n    addTodo('Write tests');\n    \n    expect(todos()).toHaveLength(2);\n    expect(todos()[0].text).toBe('Learn React Understate');\n    \n    toggleTodo(todos()[0].id);\n    \n    expect(todos()[0].completed).toBe(true);\n    expect(todos()[1].completed).toBe(false);\n  });\n\n  test('should handle state persistence', () => {\n    // Setup persistence\n    const settings = state({\n      theme: 'light',\n      language: 'en',\n    }, { name: 'settings' });\n    \n    const saveSettings = action((newSettings: any) => {\n      settings(newSettings);\n      localStorage.setItem('settings', JSON.stringify(newSettings));\n    }, { name: 'saveSettings' });\n    \n    const loadSettings = action(() => {\n      const saved = localStorage.getItem('settings');\n      if (saved) {\n        settings(JSON.parse(saved));\n      }\n    }, { name: 'loadSettings' });\n    \n    // Test save\n    saveSettings({ theme: 'dark', language: 'es' });\n    \n    expect(settings()).toEqual({ theme: 'dark', language: 'es' });\n    expect(localStorage.getItem('settings')).toBe(\n      JSON.stringify({ theme: 'dark', language: 'es' })\n    );\n    \n    // Test load\n    settings({ theme: 'light', language: 'en' }); // Reset\n    loadSettings();\n    \n    expect(settings()).toEqual({ theme: 'dark', language: 'es' });\n  });\n});\n\n// Testing error boundaries\ndescribe('Error Boundary Testing', () => {\n  test('should handle state errors gracefully', () => {\n    const errorState = state(null, { name: 'errorState' });\n    \n    const riskyAction = action(() => {\n      throw new Error('State error');\n    }, { name: 'riskyAction' });\n    \n    // Mock error boundary\n    const ErrorBoundary = ({ children }: { children: React.ReactNode }) => {\n      const [hasError, setHasError] = React.useState(false);\n      \n      React.useEffect(() => {\n        const handleError = () => setHasError(true);\n        window.addEventListener('error', handleError);\n        return () => window.removeEventListener('error', handleError);\n      }, []);\n      \n      if (hasError) {\n        return <div>Error occurred</div>;\n      }\n      \n      return <>{children}</>;\n    };\n    \n    const TestComponent = () => {\n      const count = useUnderstate(counterState);\n      \n      return (\n        <div>\n          <span>{count}</span>\n          <button onClick={riskyAction}>Risky Action</button>\n        </div>\n      );\n    };\n    \n    render(\n      <ErrorBoundary>\n        <TestComponent />\n      </ErrorBoundary>\n    );\n    \n    // Trigger error\n    fireEvent.click(screen.getByText('Risky Action'));\n    \n    // Error should be caught by boundary\n    expect(screen.getByText('Error occurred')).toBeInTheDocument();\n  });\n});",
  "testing7": "// Testing utilities\nexport const createTestState = <T>(initialValue: T, name: string) => {\n  const stateInstance = state(initialValue, { name });\n  const updates: T[] = [initialValue];\n  \n  const originalSet = stateInstance;\n  const wrappedSet = (value: T | ((prev: T) => T)) => {\n    const newValue = typeof value === 'function' ? (value as Function)(stateInstance()) : value;\n    updates.push(newValue);\n    return originalSet(value);\n  };\n  \n  return {\n    state: stateInstance,\n    updates,\n    reset: () => {\n      updates.length = 1;\n      updates[0] = initialValue;\n      stateInstance(initialValue);\n    },\n    getLastUpdate: () => updates[updates.length - 1],\n    getUpdateCount: () => updates.length - 1,\n  };\n};\n\n// Usage\ndescribe('Testing Utilities', () => {\n  test('should track state updates', () => {\n    const { state, updates, getUpdateCount } = createTestState(0, 'testCount');\n    \n    expect(getUpdateCount()).toBe(0);\n    \n    state(5);\n    expect(getUpdateCount()).toBe(1);\n    expect(updates).toEqual([0, 5]);\n    \n    state(prev => prev + 1);\n    expect(getUpdateCount()).toBe(2);\n    expect(updates).toEqual([0, 5, 6]);\n  });\n});\n\n// Mock utilities\nexport const createMockState = <T>(initialValue: T) => {\n  let value = initialValue;\n  const subscribers = new Set<() => void>();\n  \n  const mockState = (newValue?: T | ((prev: T) => T)) => {\n    if (newValue !== undefined) {\n      value = typeof newValue === 'function' ? (newValue as Function)(value) : newValue;\n      subscribers.forEach(callback => callback());\n    }\n    return value;\n  };\n  \n  mockState.subscribe = (callback: () => void) => {\n    subscribers.add(callback);\n    return () => subscribers.delete(callback);\n  };\n  \n  return mockState;\n};\n\n// Test helpers for React components\nexport const renderWithState = (\n  component: React.ReactElement,\n  initialState: Record<string, any> = {}\n) => {\n  // Setup initial state\n  Object.entries(initialState).forEach(([key, value]) => {\n    // This would need to be implemented based on your state management\n    // For example, if you have a global state registry\n  });\n  \n  return render(component);\n};\n\n// Async testing utilities\nexport const waitForState = async (\n  stateGetter: () => any,\n  expectedValue: any,\n  timeout = 1000\n) => {\n  const start = Date.now();\n  \n  while (Date.now() - start < timeout) {\n    if (stateGetter() === expectedValue) {\n      return;\n    }\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n  \n  throw new Error(`State did not reach expected value within ${timeout}ms`);\n};\n\n// Usage\ntest('should wait for async state update', async () => {\n  const data = state(null, { name: 'data' });\n  \n  // Simulate async update\n  setTimeout(() => {\n    data({ id: 1, name: 'Test' });\n  }, 100);\n  \n  await waitForState(() => data(), { id: 1, name: 'Test' });\n  \n  expect(data()).toEqual({ id: 1, name: 'Test' });\n});\n\n// Performance testing utilities\nexport const measurePerformance = async (fn: () => void | Promise<void>) => {\n  const start = performance.now();\n  await fn();\n  const end = performance.now();\n  return end - start;\n};\n\n// Usage\ntest('should measure performance', async () => {\n  const duration = await measurePerformance(async () => {\n    // Perform some operation\n    await new Promise(resolve => setTimeout(resolve, 100));\n  });\n  \n  expect(duration).toBeGreaterThan(100);\n  expect(duration).toBeLessThan(200);\n});",
  "testing8": "// ✅ DO: Test behavior, not implementation\nconst goodTest = () => {\n  const count = state(0, { name: 'count' });\n  const increment = action(() => count(prev => prev + 1), { name: 'increment' });\n  \n  increment();\n  expect(count()).toBe(1); // Test the behavior, not the implementation\n};\n\n// ❌ DON'T: Test implementation details\nconst badTest = () => {\n  const count = state(0, { name: 'count' });\n  const increment = action(() => count(prev => prev + 1), { name: 'increment' });\n  \n  // Don't test internal implementation\n  expect(increment.toString()).toContain('prev => prev + 1');\n};\n\n// ✅ DO: Use descriptive test names\ndescribe('User Authentication', () => {\n  test('should login user with valid credentials', () => {\n    // Test implementation\n  });\n  \n  test('should reject login with invalid credentials', () => {\n    // Test implementation\n  });\n  \n  test('should logout user and clear session', () => {\n    // Test implementation\n  });\n});\n\n// ❌ DON'T: Use vague test names\ndescribe('Auth', () => {\n  test('should work', () => {\n    // What exactly should work?\n  });\n});\n\n// ✅ DO: Test edge cases\ndescribe('Edge Cases', () => {\n  test('should handle empty arrays', () => {\n    const items = state<string[]>([], { name: 'items' });\n    const filtered = derived(() => items().filter(item => item.length > 0), {\n      name: 'filtered',\n    });\n    \n    expect(filtered()).toEqual([]);\n  });\n  \n  test('should handle null values', () => {\n    const data = state(null, { name: 'data' });\n    const processed = derived(() => data()?.name || 'default', {\n      name: 'processed',\n    });\n    \n    expect(processed()).toBe('default');\n  });\n});\n\n// ✅ DO: Use setup and teardown\ndescribe('State Management', () => {\n  let testState: any;\n  \n  beforeEach(() => {\n    // Setup before each test\n    testState = state(0, { name: 'testState' });\n  });\n  \n  afterEach(() => {\n    // Cleanup after each test\n    testState(0);\n  });\n  \n  test('should increment state', () => {\n    testState(prev => prev + 1);\n    expect(testState()).toBe(1);\n  });\n});\n\n// ✅ DO: Test error conditions\ndescribe('Error Handling', () => {\n  test('should handle network errors', async () => {\n    const mockFetch = jest.fn().mockRejectedValue(new Error('Network error'));\n    \n    const fetchData = action(async () => {\n      const data = await mockFetch('/api/data');\n      return data;\n    }, { name: 'fetchData' });\n    \n    await expect(fetchData()).rejects.toThrow('Network error');\n  });\n});\n\n// ✅ DO: Use mocks appropriately\ndescribe('API Integration', () => {\n  test('should save data to API', async () => {\n    const mockSave = jest.fn().mockResolvedValue({ id: 1 });\n    \n    const saveData = action(async (data: any) => {\n      return await mockSave('/api/save', data);\n    }, { name: 'saveData' });\n    \n    const result = await saveData({ name: 'Test' });\n    \n    expect(mockSave).toHaveBeenCalledWith('/api/save', { name: 'Test' });\n    expect(result).toEqual({ id: 1 });\n  });\n});\n\n// ✅ DO: Test cleanup\ndescribe('Cleanup', () => {\n  test('should cleanup effects on unmount', () => {\n    const cleanupSpy = jest.fn();\n    \n    const testEffect = effect(() => {\n      return () => cleanupSpy();\n    }, { name: 'testEffect' });\n    \n    // Simulate unmount\n    // In a real test, you'd unmount the component\n    \n    expect(cleanupSpy).toHaveBeenCalled();\n  });\n});",
  "useunderstateapicontent": "import { state, useUnderstate, action } from 'react-understate';\n\n// Create a store object\nconst counterStore = {\n  count: state(0, 'count'),\n  increment: action(() => {\n    counterStore.count.value++;\n  }, 'increment'),\n  decrement: action(() => {\n    counterStore.count.value--;\n  }, 'decrement'),\n  reset: action(() => {\n    counterStore.count.value = 0;\n  }, 'reset')\n};\n\nfunction Counter() {\n  // Extract current values and actions\n  const { count, increment, decrement, reset } = useUnderstate(counterStore);\n  \n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}",
  "useunderstateapicontent10": "import { state, derived, useUnderstate, action } from 'react-understate';\n\n// Define your types\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\ninterface AppState {\n  currentUser: User | null;\n  theme: 'light' | 'dark';\n  language: 'en' | 'es' | 'fr';\n}\n\n// Type-safe store\nconst appStore = {\n  // Explicitly typed states\n  user: state<User | null>(null, 'user'),\n  theme: state<AppState['theme']>('light', 'theme'),\n  language: state<AppState['language']>('en', 'language'),\n  \n  // Derived values with inferred types\n  isAdmin: derived(() => {\n    return appStore.user.value?.role === 'admin';\n  }, 'isAdmin'),\n  \n  userDisplayName: derived(() => {\n    const user = appStore.user.value;\n    return user ? `${user.name} (${user.email})` : 'Guest';\n  }, 'userDisplayName'),\n  \n  // Type-safe actions\n  setUser: action((user: User) => {\n    appStore.user.value = user;\n  }, 'setUser'),\n  \n  logout: action(() => {\n    appStore.user.value = null;\n  }, 'logout'),\n  \n  updateTheme: action((theme: AppState['theme']) => {\n    appStore.theme.value = theme;\n  }, 'updateTheme')\n} as const; // 'as const' for better type inference\n\n// Type-safe component\nfunction UserProfile() {\n  // TypeScript infers all types automatically\n  const { \n    user,           // User | null\n    isAdmin,        // boolean\n    userDisplayName, // string\n    theme,          // 'light' | 'dark'\n    setUser,        // (user: User) => void\n    logout,         // () => void\n    updateTheme     // (theme: 'light' | 'dark') => void\n  } = useUnderstate(appStore);\n  \n  const handleLogin = () => {\n    setUser({\n      id: 1,\n      name: 'John Doe',\n      email: 'john@example.com',\n      role: 'user'\n    });\n  };\n  \n  return (\n    <div>\n      <h1>{userDisplayName}</h1>\n      {user ? (\n        <div>\n          <p>Role: {user.role}</p>\n          {isAdmin && <p>Admin privileges enabled</p>}\n          <button onClick={logout}>Logout</button>\n        </div>\n      ) : (\n        <button onClick={handleLogin}>Login</button>\n      )}\n      \n      <select \n        value={theme} \n        onChange={(e) => updateTheme(e.target.value as AppState['theme'])}\n      >\n        <option value=\"light\">Light</option>\n        <option value=\"dark\">Dark</option>\n      </select>\n    </div>\n  );\n}\n\n// Generic store factory for reusable patterns\nfunction createEntityStore<T extends { id: string | number }>() {\n  return {\n    entities: state<T[]>([], 'entities'),\n    selectedId: state<T['id'] | null>(null, 'selectedId'),\n    \n    selectedEntity: derived(() => {\n      const entities = createEntityStore<T>().entities.value;\n      const id = createEntityStore<T>().selectedId.value;\n      return entities.find(entity => entity.id === id) || null;\n    }),\n    \n    addEntity: action((entity: T) => {\n      const store = createEntityStore<T>();\n      store.entities.value = [...store.entities.value, entity];\n    }),\n    \n    selectEntity: action((id: T['id']) => {\n      const store = createEntityStore<T>();\n      store.selectedId.value = id;\n    })\n  };\n}",
  "useunderstateapicontent11": "import { render, screen, fireEvent } from '@testing-library/react';\nimport { state, useUnderstate, action } from 'react-understate';\n\n// Test store\nconst testStore = {\n  count: state(0, 'testCount'),\n  increment: action(() => {\n    testStore.count.value++;\n  }, 'testIncrement')\n};\n\n// Component under test\nfunction TestCounter() {\n  const { count, increment } = useUnderstate(testStore);\n  \n  return (\n    <div>\n      <span data-testid=\"count\">{count}</span>\n      <button data-testid=\"increment\" onClick={increment}>\n        Increment\n      </button>\n    </div>\n  );\n}\n\ndescribe('useUnderstate integration', () => {\n  beforeEach(() => {\n    // Reset state before each test\n    testStore.count.value = 0;\n  });\n  \n  it('should render current state value', () => {\n    render(<TestCounter />);\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('0');\n  });\n  \n  it('should update when state changes', () => {\n    render(<TestCounter />);\n    \n    const incrementButton = screen.getByTestId('increment');\n    fireEvent.click(incrementButton);\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('1');\n  });\n  \n  it('should update when state changes externally', () => {\n    render(<TestCounter />);\n    \n    // Update state outside component\n    testStore.count.value = 42;\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('42');\n  });\n  \n  it('should handle multiple rapid updates', () => {\n    render(<TestCounter />);\n    \n    const incrementButton = screen.getByTestId('increment');\n    \n    // Rapid clicks\n    fireEvent.click(incrementButton);\n    fireEvent.click(incrementButton);\n    fireEvent.click(incrementButton);\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('3');\n  });\n});",
  "useunderstateapicontent12": "// ✅ DO: Subscribe only to what you need\nfunction GoodComponent() {\n  const { user } = useUnderstate({ user: appStore.user });\n  return <div>{user?.name}</div>;\n}\n\n// ❌ DON'T: Subscribe to entire large stores\nfunction BadComponent() {\n  const everything = useUnderstate(appStore); // Re-renders on any change\n  return <div>{everything.user?.name}</div>;\n}\n\n// ✅ DO: Use custom hooks for reusable logic\nfunction useAuth() {\n  return useUnderstate({\n    user: authStore.user,\n    login: authStore.login,\n    logout: authStore.logout\n  });\n}\n\n// ✅ DO: Actions are stable - safe in dependency arrays\nfunction GoodEffect() {\n  const { loadData } = useUnderstate({ loadData: dataStore.loadData });\n  \n  useEffect(() => {\n    loadData();\n  }, [loadData]); // Safe - loadData reference is stable\n}\n\n// ❌ DON'T: Mutate state values directly\nfunction BadMutation() {\n  const { user } = useUnderstate({ user: userStore.user });\n  \n  const handleUpdate = () => {\n    user.name = 'New Name'; // ❌ Direct mutation\n    userStore.user.value = user; // ❌ Won't trigger updates\n  };\n}\n\n// ✅ DO: Create new objects for updates\nfunction GoodMutation() {\n  const { user, updateUser } = useUnderstate({\n    user: userStore.user,\n    updateUser: userStore.updateUser\n  });\n  \n  const handleUpdate = () => {\n    updateUser({ ...user, name: 'New Name' }); // ✅ Proper update\n  };\n}",
  "useunderstateapicontent2": "import { state, derived, useUnderstate, action } from 'react-understate';\n\n// Complex store with multiple states and computed values\nconst todoStore = {\n  // States\n  todos: state<Todo[]>([], 'todos'),\n  filter: state<'all' | 'active' | 'completed'>('all', 'filter'),\n  newTodoText: state('', 'newTodoText'),\n  \n  // Derived values\n  filteredTodos: derived(() => {\n    const todos = todoStore.todos.value;\n    switch (todoStore.filter.value) {\n      case 'active': return todos.filter(todo => !todo.completed);\n      case 'completed': return todos.filter(todo => todo.completed);\n      default: return todos;\n    }\n  }, 'filteredTodos'),\n  \n  todoStats: derived(() => {\n    const todos = todoStore.todos.value;\n    return {\n      total: todos.length,\n      completed: todos.filter(todo => todo.completed).length,\n      active: todos.filter(todo => !todo.completed).length\n    };\n  }, 'todoStats'),\n  \n  // Actions\n  addTodo: action(() => {\n    if (todoStore.newTodoText.value.trim()) {\n      todoStore.todos.value = [\n        ...todoStore.todos.value,\n        {\n          id: Date.now(),\n          text: todoStore.newTodoText.value.trim(),\n          completed: false\n        }\n      ];\n      todoStore.newTodoText.value = '';\n    }\n  }, 'addTodo'),\n  \n  toggleTodo: action((id: number) => {\n    todoStore.todos.value = todoStore.todos.value.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    );\n  }, 'toggleTodo'),\n  \n  setFilter: action((newFilter: typeof todoStore.filter.value) => {\n    todoStore.filter.value = newFilter;\n  }, 'setFilter')\n};\n\nfunction TodoApp() {\n  // Get all current values in one call\n  const {\n    filteredTodos,\n    todoStats,\n    newTodoText,\n    addTodo,\n    toggleTodo,\n    setFilter,\n    filter\n  } = useUnderstate(todoStore);\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    addTodo();\n  };\n  \n  return (\n    <div>\n      <h1>Todos ({todoStats.active} active, {todoStats.completed} completed)</h1>\n      \n      <form onSubmit={handleSubmit}>\n        <input\n          value={newTodoText}\n          onChange={(e) => todoStore.newTodoText.value = e.target.value}\n          placeholder=\"What needs to be done?\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n      \n      <div>\n        <button \n          onClick={() => setFilter('all')}\n          style={{ fontWeight: filter === 'all' ? 'bold' : 'normal' }}\n        >\n          All\n        </button>\n        <button \n          onClick={() => setFilter('active')}\n          style={{ fontWeight: filter === 'active' ? 'bold' : 'normal' }}\n        >\n          Active\n        </button>\n        <button \n          onClick={() => setFilter('completed')}\n          style={{ fontWeight: filter === 'completed' ? 'bold' : 'normal' }}\n        >\n          Completed\n        </button>\n      </div>\n      \n      <ul>\n        {filteredTodos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id)}\n            />\n            <span style={{\n              textDecoration: todo.completed ? 'line-through' : 'none'\n            }}>\n              {todo.text}\n            </span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
  "useunderstateapicontent3": "// Large store with many states\nconst appStore = {\n  user: state(null, 'user'),\n  theme: state('light', 'theme'),\n  notifications: state([], 'notifications'),\n  settings: state({}, 'settings'),\n  \n  // ... many more states and actions\n  updateTheme: action((theme: string) => {\n    appStore.theme.value = theme;\n  }, 'updateTheme')\n};\n\n// Component only subscribes to what it needs\nfunction ThemeToggle() {\n  // Only subscribes to theme and updateTheme - not other states\n  const { theme, updateTheme } = useUnderstate({\n    theme: appStore.theme,\n    updateTheme: appStore.updateTheme\n  });\n  \n  return (\n    <button onClick={() => updateTheme(theme === 'light' ? 'dark' : 'light')}>\n      Current theme: {theme}\n    </button>\n  );\n}\n\n// Another component subscribes to different parts\nfunction UserProfile() {\n  // Only subscribes to user state\n  const { user } = useUnderstate({\n    user: appStore.user\n  });\n  \n  if (!user) return <div>Please log in</div>;\n  \n  return <div>Welcome, {user.name}!</div>;\n}",
  "useunderstateapicontent4": "import { state, useUnderstate } from 'react-understate';\n\nconst count = state(0, 'count');\nconst name = state('John', 'name');\nconst isLoading = state(false, 'isLoading');\n\nfunction UserDisplay() {\n  // Array destructuring - order matches parameters\n  const [currentCount, currentName, loading] = useUnderstate(count, name, isLoading);\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h2>{currentName}</h2>\n      <p>Count: {currentCount}</p>\n      <button onClick={() => count.value++}>Increment</button>\n      <button onClick={() => name.value = 'Jane'}>Change Name</button>\n    </div>\n  );\n}\n\n// Single state subscription\nfunction SimpleCounter() {\n  const [currentCount] = useUnderstate(count);\n  \n  return (\n    <div>\n      Count: {currentCount}\n      <button onClick={() => count.value++}>+</button>\n    </div>\n  );\n}",
  "useunderstateapicontent5": "import { state, useUnderstate } from 'react-understate';\n\nconst user = state(null, 'user');\nconst userSettings = state(null, 'userSettings');\nconst publicData = state({}, 'publicData');\n\nfunction Dashboard() {\n  const { user: currentUser } = useUnderstate({ user });\n  \n  // Conditional subscription based on auth state\n  if (!currentUser) {\n    // Only subscribe to public data when not logged in\n    const { publicData: data } = useUnderstate({ publicData });\n    \n    return (\n      <div>\n        <h1>Public Dashboard</h1>\n        <div>Public info: {JSON.stringify(data)}</div>\n        <button onClick={() => user.value = { id: 1, name: 'John' }}>\n          Log In\n        </button>\n      </div>\n    );\n  }\n  \n  // Subscribe to user-specific data when logged in\n  const { userSettings: settings } = useUnderstate({ userSettings });\n  \n  return (\n    <div>\n      <h1>Welcome, {currentUser.name}!</h1>\n      <div>Settings: {JSON.stringify(settings)}</div>\n      <button onClick={() => user.value = null}>Log Out</button>\n    </div>\n  );\n}",
  "useunderstateapicontent6": "import { state, derived, useUnderstate, action } from 'react-understate';\n\n// Shopping cart store\nconst cartStore = {\n  items: state<CartItem[]>([], 'cartItems'),\n  discountCode: state('', 'discountCode'),\n  \n  subtotal: derived(() => \n    cartStore.items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)\n  , 'subtotal'),\n  \n  discount: derived(() => {\n    const code = cartStore.discountCode.value;\n    const subtotal = cartStore.subtotal.value;\n    \n    if (code === 'SAVE10') return subtotal * 0.1;\n    if (code === 'SAVE20') return subtotal * 0.2;\n    return 0;\n  }, 'discount'),\n  \n  total: derived(() => \n    cartStore.subtotal.value - cartStore.discount.value\n  , 'total'),\n  \n  addItem: action((item: CartItem) => {\n    const existing = cartStore.items.value.find(i => i.id === item.id);\n    if (existing) {\n      cartStore.items.value = cartStore.items.value.map(i =>\n        i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i\n      );\n    } else {\n      cartStore.items.value = [...cartStore.items.value, { ...item, quantity: 1 }];\n    }\n  }, 'addItem'),\n  \n  removeItem: action((id: string) => {\n    cartStore.items.value = cartStore.items.value.filter(item => item.id !== id);\n  }, 'removeItem')\n};\n\n// Custom hook for cart functionality\nfunction useShoppingCart() {\n  const cart = useUnderstate(cartStore);\n  \n  return {\n    ...cart,\n    isEmpty: cart.items.length === 0,\n    itemCount: cart.items.reduce((sum, item) => sum + item.quantity, 0),\n    hasDiscount: cart.discount > 0\n  };\n}\n\n// Custom hook for specific cart section\nfunction useCartSummary() {\n  const { subtotal, discount, total, hasDiscount } = useShoppingCart();\n  \n  return {\n    subtotal,\n    discount,\n    total,\n    hasDiscount,\n    savings: discount,\n    formattedTotal: `$${total.toFixed(2)}`\n  };\n}\n\n// Usage in components\nfunction CartSummary() {\n  const { subtotal, discount, formattedTotal, hasDiscount } = useCartSummary();\n  \n  return (\n    <div>\n      <p>Subtotal: ${subtotal.toFixed(2)}</p>\n      {hasDiscount && <p>Discount: -${discount.toFixed(2)}</p>}\n      <h3>Total: {formattedTotal}</h3>\n    </div>\n  );\n}\n\nfunction ProductList() {\n  const { addItem } = useShoppingCart();\n  \n  return (\n    <div>\n      {products.map(product => (\n        <div key={product.id}>\n          <h3>{product.name}</h3>\n          <p>${product.price}</p>\n          <button onClick={() => addItem(product)}>\n            Add to Cart\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}",
  "useunderstateapicontent7": "import { state, derived, useUnderstate, action } from 'react-understate';\n\n// Large application store\nconst appStore = {\n  // User data\n  user: state(null, 'user'),\n  userPreferences: state({}, 'userPreferences'),\n  userHistory: state([], 'userHistory'),\n  \n  // App data\n  currentPage: state('home', 'currentPage'),\n  sidebarOpen: state(false, 'sidebarOpen'),\n  notifications: state([], 'notifications'),\n  \n  // Heavy computed data\n  expensiveComputation: derived(() => {\n    // Expensive calculation\n    return computeExpensiveData(appStore.user.value);\n  }, 'expensiveComputation'),\n  \n  // Actions\n  toggleSidebar: action(() => {\n    appStore.sidebarOpen.value = !appStore.sidebarOpen.value;\n  }, 'toggleSidebar')\n};\n\n// ❌ Bad: Subscribes to entire store\nfunction BadComponent() {\n  // This component re-renders when ANY state changes\n  const everything = useUnderstate(appStore);\n  \n  return <div>{everything.currentPage}</div>;\n}\n\n// ✅ Good: Subscribe only to needed states\nfunction GoodComponent() {\n  // Only subscribes to currentPage - no re-renders for other changes\n  const { currentPage } = useUnderstate({\n    currentPage: appStore.currentPage\n  });\n  \n  return <div>{currentPage}</div>;\n}\n\n// ✅ Good: Separate components for different concerns\nfunction UserInfo() {\n  // Only subscribes to user-related states\n  const { user, userPreferences } = useUnderstate({\n    user: appStore.user,\n    userPreferences: appStore.userPreferences\n  });\n  \n  return <div>{user?.name} - Theme: {userPreferences.theme}</div>;\n}\n\nfunction Sidebar() {\n  // Only subscribes to sidebar state\n  const { sidebarOpen, toggleSidebar } = useUnderstate({\n    sidebarOpen: appStore.sidebarOpen,\n    toggleSidebar: appStore.toggleSidebar\n  });\n  \n  return (\n    <div className={sidebarOpen ? 'open' : 'closed'}>\n      <button onClick={toggleSidebar}>Toggle</button>\n      {/* Sidebar content */}\n    </div>\n  );\n}\n\n// ✅ Good: Memoized expensive computation\nfunction ExpensiveComponent() {\n  const { expensiveComputation } = useUnderstate({\n    expensiveComputation: appStore.expensiveComputation\n  });\n  \n  // The derived value is memoized and only recalculates when user changes\n  return <div>{expensiveComputation.result}</div>;\n}",
  "useunderstateapicontent8": "import React, { memo, useCallback } from 'react';\nimport { state, useUnderstate, action } from 'react-understate';\n\nconst todoStore = {\n  todos: state<Todo[]>([], 'todos'),\n  toggleTodo: action((id: number) => {\n    todoStore.todos.value = todoStore.todos.value.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    );\n  }, 'toggleTodo')\n};\n\n// Memoized todo item component\nconst TodoItem = memo<{ todo: Todo; onToggle: (id: number) => void }>(\n  ({ todo, onToggle }) => {\n    console.log(`Rendering todo: ${todo.text}`);\n    \n    return (\n      <li>\n        <input\n          type=\"checkbox\"\n          checked={todo.completed}\n          onChange={() => onToggle(todo.id)}\n        />\n        <span style={{\n          textDecoration: todo.completed ? 'line-through' : 'none'\n        }}>\n          {todo.text}\n        </span>\n      </li>\n    );\n  }\n);\n\nfunction TodoList() {\n  const { todos, toggleTodo } = useUnderstate(todoStore);\n  \n  // Actions are stable references, so useCallback is not needed\n  // But you can use it for consistency with other React patterns\n  const handleToggle = useCallback((id: number) => {\n    toggleTodo(id);\n  }, [toggleTodo]);\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem \n          key={todo.id} \n          todo={todo} \n          onToggle={handleToggle} \n        />\n      ))}\n    </ul>\n  );\n}",
  "useunderstateapicontent9": "import React from 'react';\nimport { state, useUnderstate, action } from 'react-understate';\n\nconst errorStore = {\n  hasError: state(false, 'hasError'),\n  errorMessage: state('', 'errorMessage'),\n  \n  setError: action((message: string) => {\n    errorStore.hasError.value = true;\n    errorStore.errorMessage.value = message;\n  }, 'setError'),\n  \n  clearError: action(() => {\n    errorStore.hasError.value = false;\n    errorStore.errorMessage.value = '';\n  }, 'clearError')\n};\n\nclass ErrorBoundary extends React.Component<\n  { children: React.ReactNode },\n  { hasError: boolean }\n> {\n  constructor(props: any) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error: Error) {\n    // Report error to global error store\n    errorStore.setError(error.message);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <ErrorDisplay />;\n    }\n    \n    return this.props.children;\n  }\n}\n\nfunction ErrorDisplay() {\n  const { errorMessage, clearError } = useUnderstate(errorStore);\n  \n  return (\n    <div style={{ padding: '20px', background: '#fee', border: '1px solid #f00' }}>\n      <h2>Something went wrong!</h2>\n      <p>{errorMessage}</p>\n      <button onClick={clearError}>Try Again</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <YourAppComponents />\n    </ErrorBoundary>\n  );\n}"
}
